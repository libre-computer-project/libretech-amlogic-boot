// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_for_mmc_register_map_h.pl
//
// and was applied to the file
//
// Project name: t6d
//
// Create time: Thu Mar 28 17:08:58 CST 2024 by chong.gu
//
// ../dmc_v26/rtl/dmc_reg.vh
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef MMC_REG_DEFINE
#else
#define MMC_REG_DEFINE

#define MMC0_Wr(addr, data) *(volatile uint32_t *)((addr<<2)+0xfe036000)=(data)
#define MMC0_Rd(addr) *(volatile uint32_t *)((addr<<2)+0xfe036000)
#define MMC1_Wr(addr, data) *(volatile uint32_t *)((addr<<2)+0xfe034000)=(data)
#define MMC1_Rd(addr) *(volatile uint32_t *)((addr<<2)+0xfe034000)
#ifdef ONE_DDR_SIM
#define MMC2_Wr(addr, data)
#define MMC2_Rd(addr)  0
#define MMC3_Wr(addr, data)
#define MMC3_Rd(addr)  0
#else
#define MMC2_Wr(addr, data) *(volatile uint32_t *)((addr<<2)+0xfe032000)=(data)
#define MMC2_Rd(addr) *(volatile uint32_t *)((addr<<2)+0xfe032000)
#define MMC3_Wr(addr, data) *(volatile uint32_t *)((addr<<2)+0xfe030000)=(data)
#define MMC3_Rd(addr) *(volatile uint32_t *)((addr<<2)+0xfe030000)
#endif

//
// Reading file:  ../dmc_v26/rtl/dmc_reg.vh
//

// -----------------------------------------------
// REG_BASE:  DMC_FREQ_REG_BASE = 0xfe036000
// -----------------------------------------------
//        REGISTER_BASE_ADDR  32'hfe036000

#define DMC_REQ_CTRL                               0x0000
  //bit 8.   enable dmc request of axibus chan 8.  AMFC Async interface.
  //bit 7.   enable dmc request of axibus chan 7.  DEV Async interface.
  //bit 6.   enable dmc request of axibus chan 6.  GE2D async interface.
  //bit 5.   enable dmc request of axibus chan 5.  reserved for dmc_test.
  //bit 4.   enable dmc request of axibus chan 4.  HEVC Async interface.
  //bit 3.   enable dmc request of axibus chan 3.  VPU1 Async interface.
  //bit 2.   enable dmc request of axibus chan 2.  VPU0 Async interface.
  //bit 1.   enable dmc request of axibus chan 1.  GPU Async interface.
  //bit 0.   enable dmc request of axibus chan 0.  CPU Async interface.

//DMC CLK and RESET domain register. please check DMC_SEC_APB_CTRLx register for access details.
#define DMC_SOFT_RST                               0x0001
  //bit 31~9. reserved for future.
  //bit 8:0. 8 software reset for 8 axi ports n clock domain.

#define DMC_SOFT_RST1                              0x0002
  //To reset the Async interface, you need to disable the interface both clock domain, then reset both n_clk and m_clk domain
  //bit 31~9 not used.  all channels are synchronous interface.
  //bit 8~0. 8 software reset for 8 axi ports master clock domain.

#define DMC_SOFT_RST2                              0x0003
  //bit 23  DMC channel 0 dfi misc module soft reset_n.
  //bit 22  DMC channel 0 dfi data module soft reset_n.
  //bit 21  DMC channel 0 dfi cmd module soft reset_n.
  //bit 20  DMC channel 0 dmc dram control module soft reset_n.
  //bit 19  DMC channel 0 dmc cmd filter module soft reset_n.
  //bit 18  DMC channel 0 dmc wbuf module soft reset_n.
  //bit 17  DMC channel 0 dmc rbuf module soft reset_n.
  //bit 16  DMC channel 0 dfi low power control module soft reset_n.
  //bit 9   DMC siu soft reset_n .
  //bit 8   DMC test soft reset_n .
  //bit 7   DMC read response soft reset_n .
  //bit 6   DMC read split soft reset_n.
  //bit 5.  DMC read sec check soft reset_n.
  //bit 4.  DMC write response module soft reset_n.
  //bit 3.  DMC wd ctrl module soft reset_n.
  //bit 2.  DMC qos monitor module soft reset_n.
  //bit 1.  not used.
  //bit 0.  not used.

#define DMC_RST_STS1                               0x0004
  //31~9.  not used.
  //8~0.   8 software reset for 8 axi ports master clock domain.. Read only.

#define DMC_CLKG_CTRL0                             0x0006
  //bit 31:9  not used.
  //bit 8:0.  enable the 8 axi interfaces  m_clk auto clock gating function. each 1 bit for one interface.
#define DMC_CLKG_CTRL1                             0x0007
  //bit 31:9. not used.
  //bit 8:0.  force to disable the 8 axi interfaces m_clk. each 1 bit for one interface.

#define DMC_CLKG_CTRL2                             0x0008
  //bit 23  enalbe auto clock gating for channel 0 dfi misc.
  //bit 22  enalbe auto clock gating for channel 0 dfi data.
  //bit 21  enable auto clock gating for channel 0 dfi command generation.
  //bit 20  enable auto clock gating for channel 0 dram controller
  //bit 19  enable auto clock gating for channel 0 command filter.
  //bit 18  enalbe auto clock gating for channel 0 wbuf generation.
  //bit 17  enalbe auto clock gating for channel 0 rbuf generation.
  //bit 8.  enalbe auto clock gating for test.
  //bit 7.  enalbe auto clock gating for rd response.
  //bit 6.  enalbe auto clock gating for read split.
  //bit 5.  enalbe auto clock gating for read sec check.
  //bit 4.  enalbe auto clock gating for write response.
  //bit 3.  enalbe auto clock gating for wd control.
  //bit 2.  enalbe auto clock gating for qos monitor.
  //bit 1:0.  not used.

#define DMC_CLKG_CTRL3                             0x0009
  //bit 23  force to disable the clock of channel 0 dfi misc.
  //bit 22  force to disable the clock of channel 0 dfi data.
  //bit 21  force to disable the clock of channel 0 dfi command generation.
  //bit 20  force to disable the clock of channel 0 dram controller
  //bit 19  force to disable the clock of channel 0 command filter.
  //bit 18  force to disable the clock of channel 0 wbuf generation.
  //bit 17  force to disable the clock of channel 0 rbuf generation.
  //bit 16  force to disable the clock of channel 0 lp ctrl.
  //bit 8.  test.
  //bit 7.  rd response.
  //bit 6.  read split.
  //bit 5.  read sec check.
  //bit 4.  write response.
  //bit 3.  wd control.
  //bit 2.  qos monitor.
  //bit 1:0.    not used.

#define DMC_MON_CTRL0                              0x0010
   //bit 31.   qos_mon_en.    write 1 to trigger the enable. polling this bit 0, means finished.  or use interrupt to check finish.
   //bit 30.   qos_mon interrupt clear.  clear the qos monitor result.  read 1 = qos mon finish interrupt.
   //bit 7:0    bw_mon_range_en.    enables 8 monitor channels.
#define DMC_MON_TIMER                              0x0011
 // timer for the monitor period.
#define DMC_MON_ALL_IDLE_CNT                       0x0012
  // at the test period,  the whole MMC all channel IDLE time. unit, dmc clock.
#define DMC_MON_ALL_BW                             0x0013
  // at the test period,  the whole MMC granted data cycles. units one data clock cycle = 16bytes.
#define DMC_MON_ALL16_BW                           0x0014
  // at the test period,  the whole MMC granted data cycles which goes to 16bits ddr. units one data clock cycle = 16byte.
#define DMC_MON0_CTRL1                             0x0018
//bit 31:16 not used.
//bit 15:0. mon0 R/W ack AXI subid enable.
#define DMC_MON1_CTRL1                             0x0019
//bit 31:16 not used.
//bit 15:0. mon1 R/W ack AXI subid enable.
#define DMC_MON2_CTRL1                             0x001a
//bit 31:16 not used.
//bit 15:0. mon2 R/W ack AXI subid enable.
#define DMC_MON3_CTRL1                             0x001b
//bit 31:16 not used.
//bit 15:0. mon3 R/W ack AXI subid enable.
#define DMC_MON4_CTRL1                             0x001c
//bit 31:16 not used.
//bit 15:0. mon4 R/W ack AXI subid enable.
#define DMC_MON5_CTRL1                             0x001d
//bit 31:16 not used.
//bit 15:0. mon5 R/W ack AXI subid enable.
#define DMC_MON6_CTRL1                             0x001e
//bit 31:16 not used.
//bit 15:0. mon6 R/W ack AXI subid enable.
#define DMC_MON7_CTRL1                             0x001f
//bit 31:16 not used.
//bit 15:0. mon7 R/W ack AXI subid enable.

//each monitor can check upto 3 master IDs.
#define DMC_MON0_STA                               0x0020
  //bit 31:20. not used.
  //bit 19:0  MON0 start address unit 4Kbyte.
#define DMC_MON0_EDA                               0x0021
  //bit 31:20. Not used.
  //bit 19:0  MON0 end address unit 4Kbyte.
#define DMC_MON0_CTRL                              0x0022
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define DMC_MON0_BW                                0x0023
  //monitor bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON1_STA                               0x0024
  //bit 31:20. not used.
  //bit 19:0  MON0 start address unit 4Kbyte.
#define DMC_MON1_EDA                               0x0025
  //bit 31:20. Not used.
  //bit 19:0  MON0 end address unit 4Kbyte.
#define DMC_MON1_CTRL                              0x0026
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define DMC_MON1_BW                                0x0027
  //monitor 1 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON2_STA                               0x0028
  //bit 31:20. not used.
  //bit 19:0  MON0 start address unit 4Kbyte.
#define DMC_MON2_EDA                               0x0029
  //bit 31:20. Not used.
  //bit 19:0  MON2 end address unit 4Kbyte.
#define DMC_MON2_CTRL                              0x002a
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define DMC_MON2_BW                                0x002b
  //monitor 2 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON3_STA                               0x002c
  //bit 31:20. not used.
  //bit 19:0  MON3 start address unit 4Kbyte.
#define DMC_MON3_EDA                               0x002d
  //bit 31:20. Not used.
  //bit 19:0  MON3 end address unit 4Kbyte.
#define DMC_MON3_CTRL                              0x002e
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define DMC_MON3_BW                                0x002f
  //monitor 3 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON4_STA                               0x0030
  //bit 31:20. not used.
  //bit 19:0  MON4 start address unit 4Kbyte.
#define DMC_MON4_EDA                               0x0031
  //bit 31:20. Not used.
  //bit 19:0  MON4 end address unit 4Kbyte.
#define DMC_MON4_CTRL                              0x0032
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define DMC_MON4_BW                                0x0033
  //monitor 4 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON5_STA                               0x0034
  //bit 31:20. not used.
  //bit 19:0  MON5 start address unit 4Kbyte.
#define DMC_MON5_EDA                               0x0035
  //bit 31:20. Not used.
  //bit 19:0  MON4 end address unit 4Kbyte.
#define DMC_MON5_CTRL                              0x0036
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define DMC_MON5_BW                                0x0037
  //monitor 5 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON6_STA                               0x0038
  //bit 31:20. not used.
  //bit 19:0  MON6 start address unit 4Kbyte.
#define DMC_MON6_EDA                               0x0039
  //bit 31:20. Not used.
  //bit 19:0  MON6 end address unit 4Kbyte.
#define DMC_MON6_CTRL                              0x003a
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define DMC_MON6_BW                                0x003b
  //monitor 6 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON7_STA                               0x003c
  //bit 31:20. not used.
  //bit 19:0  MON7 start address unit 4Kbyte.
#define DMC_MON7_EDA                               0x003d
  //bit 31:20. Not used.
  //bit 19:0  MON7 end address unit 4Kbyte.
#define DMC_MON7_CTRL                              0x003e
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define DMC_MON7_BW                                0x003f
  //monitor 7 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.

#define DMC_CMD_FILTER_CTRL0                       0x004a
  //23:16   urgent4 bank hold
  //15:8    rbuf urgent5 hold
  //7:0     rbuf urgent4 hold
#define DMC_CMD_FILTER_CTRL1                       0x0040
  //31:24   rbuf urgent3 hold
  //23:16   rbuf urgent2 hold
  //15:8    rbuf urgent1 hold
  //7:0     rbuf urgent0 hold
#define DMC_CMD_FILTER_CTRL2                       0x0041
  //31:24. keep the bank active if there's urgent level 3 read bank hit request.
  //23:16. keep the bank active if there's urgent level 2 read bank hit request.
  //15:8.  keep the bank active if there's urgent level 1 read bank hit request.
  //7:0.   keep the bank active if there's urgent level 0 read bank hit request.

#define DMC_CMD_FILTER_CTRL3                       0x0042
  //bit 31.    force wbuf empty.
  //bit 30:26  wbuf high level number
  //bit 25:21  wbuf mid  level number
  //bit 20:16  wbuf low level number
  //bit 14:10  rbuf high level number
  //bit 9:5    rbuf middle level number
  //bit 4:0    rbuf low level number

#define DMC_CMD_FILTER_CTRL4                       0x0043
  //bit 31:26.  rank write min number
  //bit 25:20.  rank read min number
  //bit 19:12   tAP auto precharge the bank not used if idle that long time.
  //bit 11:6    write to read accesses if there write hit request.
  //bit 5:0     read to write accesses if there write hit request.

#define DMC_CMD_FILTER_CTRL5                       0x0044
  //bit 31:24   Once ddr data bus switch to read, the maxmum read command number to give up the bus when there's write request pending for write buffer.
  //bit 23:16   Once ddr data bus switch to write, the maxmum write command number to give up the bus when there's read request pending too long.
  //bit 15:8.   Once ddr data bus switch to read, the minimum read command number to transfer back to write stage if there's still pending read request.
  //bit 7:0.    Once ddr data bus switch to write, the minimum write command number to transfer back to read stage if there's still pending write request.

#define DMC_CMD_FILTER_CTRL6                       0x0045
  //bit 31:24   write urgent 3 request pending hold num.
  //bit 23:16   write urgent 2 request pending hold num.
  //bit 15:8.   write urgent 1 request pending hold num.
  //bit 7:0.    write urgent 0 request pending hold num.

#define DMC_CMD_FILTER_CTRL7                       0x0046
  //bit 31:24.  aw_req_pending singal assertion after wbuf full.
  //bit 23:16   aw_req_pending singal hold how long if wbuf not full.
  //bit 15:8    write to read waiting cycles if there write hit request.
  //bit 7:0     read to write waiting cycles if there write hit request.

#define DMC_CMD_FILTER_CTRL8                       0x0047
  //bit 31:24   tITW_short
  //bit 23:16   tITW_long
  //bit 15:8    rank limit minmum to change to another rank if another rank has hit request.
  //bit 7:0     rank limit to change to another rank.


#define DMC_CMD_BUFFER_CTRL                        0x0048
  //bit 31:26  total write buffer number. default 32.
  //bit 25:20  total read buffer number. default 32.
  //bit 19:8   reserved.
  //bit 7:0    aw_pending_inc_num.  incease write ugent level 1 when write command waiting to in write buffer that long.

#define DMC_CMD_BUFFER_CTRL1                       0x0049
  //bit 31.    rbuf urgent 4 read hit request high priority enable.
  //bit 29:24  read buffer number in non-urgent request.
  //bit 23:16  read buffer bank miss watch dog threshold.
  //bit 15:12  read buffer urgent level 3 counter inc weight.
  //bit 11:8   read buffer urgent level 2 counter inc weight.
  //bit 7:4    read buffer urgent level 1 counter inc weight.
  //bit 3:0    read buffer urgent level 0 counter inc weight.

#define DMC_2ARB_CTRL                              0x004c
  //32:24. Waiting limit to use the highest urgent level in the pipelines.
  //23:12. Not used.
  //11:8.  cfg_req_keep_num.
  //7:0.   cfg_inc_ugt_limit. increase urgent level if the arbiter wait that long.

#define DMC_VERSION                                0x004f
   //read only 32'h01000028  for t6d

#define DMC_AXI0_CHAN_CTRL                         0x0080
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI0_HOLD_CTRL                         0x0081
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI0_CHAN_CTRL1                        0x0082
  //31:28.  FIQ  chan0 QOS setting.
  //27:24.  IRQ  chan0 QOS setting.
  //23:20.  chan0 write QOS with VPU request.
  //19:16.  chan0 write QOS with other request .
  //15:12.  chan0 write QOS with none other requests.
  //11:8.   chan0 read QOS with VPU request.
  //7:4.    chan0 read QOS with other request .
  //3:0.    chan0 read QOS with none other requests.
#define DMC_AXI0_CHAN_CTRL2                        0x0083
 //bit 31.    cfg_wrdata_mode enable (default enabled)
 //bit 30:4.  Not used.
 //bit 3.     CPU FIQ QOS ctrl_en.
 //bit 2.     CPU IRQ QOS ctrl_en.
 //bit 1.     CPU read channel auto QOS enable (based on other traffic).
 //bit 0.     CPU write channel auto QOS enable( based on other traffic).
#define DMC_AXI0_CHAN_STS                          0x0084
  // AXI0 Async interface status.
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.   not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI0_CHAN_STS1                         0x008f
  //7:4. CPU FIQ STS
  //3:0. CPU IRQ STS.

#define DMC_AXI1_CHAN_CTRL                         0x0085
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI1_HOLD_CTRL                         0x0086
  //bit 31:24 write hold num.   max outstanding request number.
  //bit 23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
  //bit 15:8 read hold num.   max outstanding request number.
  //bit 7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI1_CHAN_CTRL1                        0x0087
   //bit 31     cfg_wrdata_mode
   //bit 30:25. not used.
   //bit 24:16. when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block vpu itself and  CPU or other urgent request.
   //bit 15:12. Not used.
   //bit 11.   use side band write urgent control signal to control AWQOS.  1: enabe. 0: disable.
   //bit 10.   use side band read  urgent control signal to control ARQOS.  1: enabe. 0: disable.
   //bit 9.    use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 8.    use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 7:4.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 3:0.  the ARQOS value when side band read  urgent control signal = 1 while bit 18 enabled.
#define DMC_AXI1_CHAN_STS                          0x0088
  // AXI1 Async interface status
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.

#define DMC_AXI2_CHAN_CTRL                         0x008a
#define DMC_AXI2_HOLD_CTRL                         0x008b
#define DMC_AXI2_CHAN_CTRL1                        0x008c
#define DMC_AXI2_CHAN_STS                          0x008d

#define DMC_AXI3_CHAN_CTRL                         0x0090
#define DMC_AXI3_HOLD_CTRL                         0x0091
#define DMC_AXI3_CHAN_CTRL1                        0x0092
#define DMC_AXI3_CHAN_STS                          0x0093

#define DMC_AXI4_CHAN_CTRL                         0x0095
#define DMC_AXI4_HOLD_CTRL                         0x0096
#define DMC_AXI4_CHAN_CTRL1                        0x0097
#define DMC_AXI4_CHAN_STS                          0x0098

#define DMC_AXI5_CHAN_CTRL                         0x009a
  //bit 19:16   m5_AWQOS & m5_ARQOS
  //bit 3:0     canvas arbiter arbiter weight

#define DMC_AXI5_HOLD_CTRL                         0x009b
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI5_CHAN_STS                          0x009c
  //AXI chan4 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  not used.
  //7:0.  not used.

#define DMC_AXI6_CHAN_CTRL                         0x00a0
#define DMC_AXI6_HOLD_CTRL                         0x00a1
#define DMC_AXI6_CHAN_CTRL1                        0x00a2
#define DMC_AXI6_CHAN_STS                          0x00a3

#define DMC_AXI7_CHAN_CTRL                         0x00a5
#define DMC_AXI7_HOLD_CTRL                         0x00a6
#define DMC_AXI7_CHAN_CTRL1                        0x00a7
#define DMC_AXI7_CHAN_STS                          0x00a8

#define DMC_AXI8_CHAN_CTRL                         0x00aa
#define DMC_AXI8_HOLD_CTRL                         0x00ab
#define DMC_AXI8_CHAN_CTRL1                        0x00ac
#define DMC_AXI8_CHAN_STS                          0x00ad





#define DMC_CHAN_STS                               0x00cf
  // read only register.
  //bit 31:29   not used. always 1
  //bit 28      ddr0 read buf idle.  1 : idle 0: busy.
  //bit 27      not used. always 1.
  //bit 26      ddr0 write data buffer idle. 1 : idle 0: busy.
  //bit 25      not used. always 1.
  //bit 24      ddr0 wbuf idle.              1 : idle 0: busy.
  //bit 23:9    not used.   always 1.
  //bit 8       AXI channel8 idle.
  //bit 7       AXI channel7 idle.
  //bit 6       AXI channel6 idle.
  //bit 5       AXI channel5 idle.
  //bit 4       AXI channel4 idle.
  //bit 3       AXI channel3 idle.
  //bit 2       AXI channel2 idle.
  //bit 1       AXI channel1 idle.
  //bit 0       AXI channel0 idle.

#define DMC_ARPORT_ST0                             0x00d0
  //bit 31:0  ARADDR[31:0]
#define DMC_ARPORT_ST1                             0x00d1
  //bit 13:0  dmc ARID. 4 MSB = port number
#define DMC_AWPORT_ST0                             0x00d2
  //bit 31:0  AWADDR[31:0]
#define DMC_AWPORT_ST1                             0x00d3
  //bit 13:0  dmc AWID. 4 MSB = port number

#define DMC_MON_IRQ_STS                            0x00db
  //bit 31:1   Not used.
  //bit 0 :    QOS Monitor interrupt flag.  1: means there's QOS monitor interrup.  write 1 to clean this interrupt.





//DMC protection function domain register.
// one protection can chose upto 4 master IDs to monitors.
//for these 4 master IDs, you can chose either include them. or exclude them.
#define DMC_PROT0_STA                              0x00e0
  //31:20. not used.
  //19:0   protection 0 start address . unit 4Kbyte.
#define DMC_PROT0_EDA                              0x00e1
  //31:20. not used.
  //19:0   protection 0 end address. unit 4Kbyte.
#define DMC_PROT0_CTRL                             0x00e2
  //bit 27.   prot0_write_en.
  //bit 26.   prot0_read_en.
  //bit 8:0.  prot0 id enable.
#define DMC_PROT1_STA                              0x00e4
  //bit 31:20. not used.
  //bit 19:0   protection 1 start address . unit 4Kbyte.
#define DMC_PROT1_EDA                              0x00e5
  //bit 31:20. not used.
  //bit 19:0   protection 1 end address. unit 4Kbyte.
#define DMC_PROT1_CTRL                             0x00e6
  //bit 27.   prot1_write_en.
  //bit 26.   prot1_read_en.
  //bit 8:0.  prot1 id enable.
#define DMC_PROT_VIO_0                             0x00e8
  //protection write violation low 32bits address.
#define DMC_PROT_VIO_1                             0x00e9
  //bit 31:25. write prot catch count number.
  //bit 24:23. not used.
  //bit 22:9.  AWID.
  //bit 8.    protection 1 write violation.
  //bit 7.    protection 0 write violation.
  //bit 6:0   remapped security id.
#define DMC_PROT_VIO_2                             0x00ea
  //protection read violation low 32bits address. ARADDR[31:0].
#define DMC_PROT_VIO_3                             0x00eb
  //bit 31:23. not used.
  //bit 22:9.  ARID
  //bit 8.    protection 1 read violation.
  //bit 7.    protection 0 read violation.
  //bit 6:0   remapped security id.

#define DMC_PROT_IRQ_CTRL_STS                      0x00ec
  //bit 3.   clear AW prot catch count, write 1 to clean
  //bit 2.   protection IRQ enable.
  //bit 1.   read for write prot violation. write 1 to clean the write protection status and interrup.
  //bit 0.   read for read prot violation. write 1 to clean the read protection status and interrup.


//SIU register.
//there's 2 set of timing DDR timing parameter for 2 set of DDR freqency parameter.
//when change frequency, the hardware would automatically select one of these two set of timing parameter
//DMC_DRAM_* is for Frequency set 0.
//DMC_NFQ_* is for Freqency set 1.
#define DMC_DRAM_TMRD                              0x0100
   //bit 7:0.  tMRD. //MR command cycles, in DDR3/4.  in LPDDR4, it should be value of tMRW
#define DMC_DRAM_TRFC                              0x0101
   //bit 25:16 tRFCpb
   //bit 9:0   tRFCab
#define DMC_DRAM_TRP                               0x0102
   //bit 23:16.  tRP for precharge all banks.
   //bit 7:0.    tRP for precharge one bank.
#define DMC_DRAM_TRTW                              0x0103
   //bit 31:8:   Not used.
   //bit 7:0     DDR3/4 mode : tRTW.
   // For LPDDR4 .  The total read command -> write command = (RL + BL/2 - tWODTON) + TDQSCK_MAX + tWPRE +RD(tRPST).
   //                 tRTW = TDQSCK_max + tWPRE + tRD(tRPST)  + (delay margin)
#define DMC_DRAM_TCL                               0x0104
  //bit 7:0  tCL/tRL. read latency.
#define DMC_DRAM_TCWL                              0x0105
  //bit 7:0.  CWL:  write latency.
#define DMC_DRAM_TRAS                              0x0106
  //bit 7:0.  tRAS.  minimum active to precharge time for same bank.
#define DMC_DRAM_TRC                               0x0107
  //bit 7:0.  tRC.  minimum active to active time for same bank.
#define DMC_DRAM_TRCD                              0x0108
  //bit 7:0  tRCD  active to read/write timing for same bank.
#define DMC_DRAM_TRRD                              0x0109
  //bit 23:16.  tRRD_l  active bank A to active B in same band group for DDR4.
  //bit 7:0.    tRRD/tRRD_s   active bank A to active bank b time.
              //tRRD_s:   active bank A to active bank b in different bank grousp for DDR4.
#define DMC_DRAM_TFAW                              0x010a
  //bit 8:0   tFAW.  four active command windows
#define DMC_DRAM_TRTP                              0x010b
  //bit 7:0  tRTP. in LPDDR5 should be tBL + tRBTP
#define DMC_DRAM_TWR                               0x010c
  //bit 7:0 tWR.
#define DMC_DRAM_TWTR                              0x010d
  //bit 23:16 tWTR_l   For DDR4 WTR_l.  FOR DDR3/LPDDR4 same as tWTR_s.
  //bit 7:0 tWTR_s.
#define DMC_DRAM_TCCD                              0x010e
  //bit 21:16. tCCD/tCCD_l.
  //bit 5:0 tCCD/tCCD_s    read to read command time or write to write command time.
#define DMC_DRAM_TEXSR                             0x010f
  //bit 12:0. tEXSR.  EXIT SELF-REFRESH to read/write command.
#define DMC_DRAM_TXS                               0x0110
  //bit 10:0  tXS.  EXIT SELF_REFRESH to other command time
#define DMC_DRAM_TXP                               0x0111
  //bit 6:0. LPDDR4 tXP.  EXIT power down to other command time
             //LPDDR5 tCSL
#define DMC_DRAM_TXPDLL                            0x0112
  //bit 12:0.  tXPDLL,  EXIT power down to read/write command time(need to relock PLL).
#define DMC_DRAM_TZQCS                             0x0113
  //bit 7:0.  ZQCS command to other command time.
#define DMC_DRAM_TCKSRE                            0x0114
  //bit 7:0. enter self refresh to disable clock time.
#define DMC_DRAM_TCKSRX                            0x0115
  //bit 7:0. enable clock to exit self refresh time.
#define DMC_DRAM_TCKE                              0x0116
  //bit 7:0.  CKE high or low minimum time.
             //LPDDR5: tCSPD. power down to power up
#define DMC_DRAM_TMOD                              0x0117
  //bit 7:0  tMOD.  MRR/MRW to other command time. in LPDDR4, still use this register but it called tMRD.

#define DMC_DRAM_TDQS                              0x0118
  //bit 31:28 reserved
  //bit 27:24 tDQS_wr. the delay for write after read in different rank.
  //bit 23:20 reserved
  //bit 19:16 tDQS_rw. the delay for read after write in different rank.
  //bit 15:12 reserved
  //bit 11:8  tDQS_ww. the delay for write after write in different rank.
  //bit 7:4 reserved
  //bit 3:0 tDQS_rr. the delay for read after read in different rank.
#define DMC_DRAM_TRSTL                             0x0119
  //bit 6:0 t_tstl. not used.
#define DMC_DRAM_TZQLAT                            0x011a
  //bit 7:0 ZQ LATCH command to other comand timing in LPDDR4 mode.
#define DMC_DRAM_TMRR                              0x011b
  //bit 7:0 tMRR  not used in DMC.

#define DMC_DRAM_TCKESR                            0x011c
 //bit 9:0 tCKESR.   CKE low minimum pulse in self refresh mode.
#define DMC_DRAM_TDPD                              0x011d
 //bit 9:0 tdpd. not support.
#define DMC_DRAM_DFITCTRLDELAY                     0x011e
  //bit 5:0. DFI_t_ctrldelay
#define DMC_DRAM_DFITPHYWRDATA                     0x011f
  //bit 5:0.  dfi_t_phy_wrdata.
#define DMC_DRAM_DFITPHYWRLAT                      0x0120
  //bit 7:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATAEN                      0x0121
  //bit 7:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define DMC_DRAM_DFITPHYRDLAT                      0x0122
  //bit 7:0.  dfi_t_rdlat.
#define DMC_DRAM_DFITCTRLUPDMIN                    0x0123
  //bit 15:0.  CTRLUPD_MIN  minimum clock cycle to maintain CTRLUPD_REQ.
#define DMC_DRAM_DFITCTRLUPDMAX                    0x0124
  //bit 15:0   CTRLUPD_MAX.  maximum clock cycle to maintain CTRLUPD_REQ if no CTRLUPD_ACK response.
#define DMC_DRAM_DFITREFMSKI                       0x0126
  //not used.
#define DMC_DRAM_DFITCTRLUPDI                      0x0127
  //bit 31:0    frq0_dfitctrlupdi. not used.
#define DMC_DRAM_DFITDRAMCLK                       0x0128
//bit 17    dram clk1 enable.
//bit 16    dram clk0 enable.
//bit 15:8  DRAM CLK disable waiting time
//bit 7:0   DRAM CLK enable  enable timer

#define DMC_DRAM_DFITLPRESP                        0x012a
  //bit 4:0.  dfi_lp_ctrl_req response time. after dfi_lp_ctrl_req asserted, and after response time if there's still no dfi_lp_ack respone, then drop the dfi_lp_ctrl_req.

#define DMC_DRAM_TREFIH                            0x012b
  //bit 7:0   tREFI[23:16].dmc send auto refresh command period. unit is dmc clock cycles.

#define DMC_DRAM_TCKECK                            0x012c
 //bit 7:0. tCKECK  from CKE low to assert dfi_dram_clk_disable time. this time + dfi_t_ctrl_delay
            //in LPDDR5 tCSLCK


#define DMC_DRAM_TREFI                             0x012d
 //write this register will update the auto refresh related register to the auto refresh control logic.
 //bit 31:24:  tZQCI dmc send zqci period.  unit is how much auto refresh period.
 //bit 23:16   pvti  dmc send dfi_ctrlupd_req period.  unit is one auto refresh period.
 //bit 15:0.   tREFI[15:0].dmc send auto refresh command period. unit is dmc clock cycles
#define DMC_DRAM_TSR                               0x012e
  //bit 7:0 tSR.  self resfresh enter to exit time.
#define DMC_DRAM_TCCDMW                            0x012f
  //bit 7:0.  4*tCCD in LPDDR4 mask write.
#define DMC_DRAM_TESCKE                            0x0130
  //bit 7:0  tESCKE.  enter self refresh to power time for LPDDR4.
#define DMC_DRAM_TREFI_DDR3                        0x0131
  //9:0. use this register to reset refi_disable_cnt. the unit is t100ns.
  //use this to check in 8*tREFI time, the DMC should not sent more than 16 auto REFRESH command.
#define DMC_DRAM_TZQCAL                            0x0132
  //15:0. ZQCAL for LPDDR4.  tZQCAL4/8/16 for LP5.
#define DMC_DRAM_T10US                             0x0133
  //bit 15:0 10us clock cycle number used for LP2 mode.
#define DMC_DRAM_TMRRI                             0x0134
//bit 7:0   tMRRI for MRR
#define DMC_DRAM_TXS_FAST                          0x0135
 //bit 9:0 DDR4 mode XS_FAST exit self_refrest to zqcl/zqcs/mrs command.
#define DMC_DRAM_DFIODTCFG                         0x0136
  //bit 12.  rank1 ODT default. default value for ODT[1] pins if theres no read/write activity.
  //bit 11.  rank1 ODT write sel.  enable ODT[1] if there's write occur in rank1.
  //bit 10.  rank1 ODT write nsel. enable ODT[1] if theres's write occur in rank0.
  //bit 9.   rank1 odt read sel.   enable ODT[1] if there's read occur in rank1.
  //bit 8.   rank1 odt read nsel.  enable ODT[1] if there's read occure in rank0.
  //bit 4.   rank0 ODT default.    default value for ODT[0] pins if theres no read/write activity.
  //bit 3.   rank0 ODT write sel.  enable ODT[0] if there's write occur in rank0.
  //bit 2.   rank0 ODT write nsel. enable ODT[0] if theres's write occur in rank1.
  //bit 1.   rank0 odt read sel.   enable ODT[0] if there's read occur in rank0.
  //bit 0.   rank0 odt read nsel.  enable ODT[0] if there's read occure in rank1.
#define DMC_DRAM_DFIODTCFG1                        0x0137
  //bit 28:24  ODT length for BL8 read transfer.
  //bit 20:16. ODT length for BL8 write transfer.
  //bit 13:8.  ODT latency for reads.  suppose to be 0.
  //bit 5:0.   ODT latency for writes.  suppose to be 0.

#define DMC_DRAM_TWODTON                           0x0138
  //bit 7:0   DRAM write access ODT on time.
  //   in DDR3/4 should be same as WL.
  //   in LPDDR4 ODT enable  mode:  tODTLon + tODTon.min
  //   In LPDDR4 ODT disable mode:  tWL.

#define DMC_DRAM_PHYADDRON                         0x013a
  //bit 5:0 PHY_CTRL_ADDR_ON for new PHY. default : 12 unit: DfiClk
#define DMC_DRAM_PHYWRON                           0x013b
  //bit 6:0 PHY_CTRL_WR_ON.  = 20 + WL + (tDQSS+ tDQS2DQ + tWPST)/ddr_clk + BL/2
#define DMC_DRAM_PHYRDON                           0x013c
  //bit 6:0 PHY_CTRL_RD_ON.  = 20 + RL + (tDQSCK+ tRPST + tDQSQ)/ddr_clk + BL/2

#define DMC_DRAM_ZQCTRL                            0x013d
  //tZQCI bits in DMC_DRAM_TREFI  defined how many refresh period send ZQCS/ZQUPD/command.
  //this register defines in 0~tZQCI period, which refresh period count to send ZQCS/ZACAL/ZQUPD command
  //31:24.  in LPDDR4 case when to send ZQLAT comman to both RANKs of LPDDR4 SDRAM
  //23:16.  when to send PHY ZQ UPDATE command.
  //15:8.   when to send ZQCS/ZQCAL to rank1 DDR SDRAM.
  //7:0.    when to senc ZQCS/ZQCAL to rank0 DDR SDRAM.

#define DMC_DRAM_DFITPHYWRLATCSN                   0x013e
  //not used. bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATACSN                     0x013f
  //not used. bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.


//timing parameter for frequency set 1.
#define DMC_NFQ_TMRD                               0x0140
#define DMC_NFQ_TRFC                               0x0141
#define DMC_NFQ_TRP                                0x0142
#define DMC_NFQ_TRTW                               0x0143
#define DMC_NFQ_TCL                                0x0144
#define DMC_NFQ_TCWL                               0x0145
#define DMC_NFQ_TRAS                               0x0146
#define DMC_NFQ_TRC                                0x0147
#define DMC_NFQ_TRCD                               0x0148
#define DMC_NFQ_TRRD                               0x0149
#define DMC_NFQ_TFAW                               0x014a
#define DMC_NFQ_TRTP                               0x014b
#define DMC_NFQ_TWR                                0x014c
#define DMC_NFQ_TWTR                               0x014d
#define DMC_NFQ_TCCD                               0x014e
#define DMC_NFQ_TEXSR                              0x014f
#define DMC_NFQ_TXS                                0x0150
#define DMC_NFQ_TXP                                0x0151
#define DMC_NFQ_TXPDLL                             0x0152
#define DMC_NFQ_TZQCS                              0x0153
#define DMC_NFQ_TCKSRE                             0x0154
#define DMC_NFQ_TCKSRX                             0x0155
#define DMC_NFQ_TCKE                               0x0156
#define DMC_NFQ_TMOD                               0x0157
#define DMC_NFQ_TDQS                               0x0158
#define DMC_NFQ_TRSTL                              0x0159
#define DMC_NFQ_TZQLAT                             0x015a
#define DMC_NFQ_TMRR                               0x015b
#define DMC_NFQ_TCKESR                             0x015c
#define DMC_NFQ_TDPD                               0x015d
#define DMC_NFQ_DFITCTRLDELAY                      0x015e
#define DMC_NFQ_DFITPHYWRDATA                      0x015f
#define DMC_NFQ_DFITPHYWRLAT                       0x0160
#define DMC_NFQ_DFITRDDATAEN                       0x0161
#define DMC_NFQ_DFITPHYRDLAT                       0x0162
#define DMC_NFQ_DFITCTRLUPDMIN                     0x0163
#define DMC_NFQ_DFITCTRLUPDMAX                     0x0164
#define DMC_NFQ_DFITREFMSKI                        0x0166
#define DMC_NFQ_DFITCTRLUPDI                       0x0167
#define DMC_NFQ_DFITDRAMCLK                        0x0168
#define DMC_NFQ_DFITLPRESP                         0x016a
#define DMC_NFQ_TREFIH                             0x016b
#define DMC_NFQ_TCKECK                             0x016c
#define DMC_NFQ_TREFI                              0x016d
#define DMC_NFQ_TSR                                0x016e
#define DMC_NFQ_TCCDMW                             0x016f
#define DMC_NFQ_TESCKE                             0x0170
#define DMC_NFQ_TREFI_DDR3                         0x0171
#define DMC_NFQ_TZQCAL                             0x0172
#define DMC_NFQ_T10US                              0x0173
#define DMC_NFQ_TMRRI                              0x0174
#define DMC_NFQ_TXS_FAST                           0x0175
#define DMC_NFQ_DFIODTCFG                          0x0176
#define DMC_NFQ_DFIODTCFG1                         0x0177
#define DMC_NFQ_TWODTON                            0x0178
#define DMC_NFQ_PHYADDRON                          0x017a
#define DMC_NFQ_PHYWRON                            0x017b
#define DMC_NFQ_PHYRDON                            0x017c
#define DMC_NFQ_ZQCTRL                             0x017d
#define DMC_NFQ_DFITPHYWRLATCSN                    0x017e
#define DMC_NFQ_DFITRDDATACSN                      0x017f


#define DMC_DRAM_DFITPHYUPDTYPE0                   0x0180
 //bit 7:0. dfi_phyupd_ack hold time for dfi_phyupd_req type = 0.
#define DMC_DRAM_DFITPHYUPDTYPE1                   0x0181
 //bit 7:0. dfi_phyupd_ack hold time for dfi_phyupd_req type = 1.
#define DMC_DRAM_DFITPHYUPDTYPE2                   0x0182
 //bit 7:0. dfi_phyupd_ack hold time for dfi_phyupd_req type = 2.
#define DMC_DRAM_DFITPHYUPDTYPE3                   0x0183
 //bit 7:0. dfi_phyupd_ack hold time for dfi_phyupd_req type = 3.

#define DMC_DRAM_MCFG                              0x0186
 //bit 31:28  not used.
 //bit 27:24  rank1_d16_sel.  16bit mode, rank 1 byte selection.
 //bit 23:20  rank0_d16_sel.  16bit mode, rank 0 byte selection.
 //bit 19.   send PHY ZQ command  after siu self refresh exit. 1 : enable.  0 : disable.
 //bit 18.   send retrain command after siu self refresh exit. 1 : enable. 0 : disable.
 //bit 17.   in DDR3/4 mode, send ZQCL command after exit register triggered self refresh.
 //bit 16.   send refresh command after finish frequency change. 1 : enable. 0 : disable.
 //bit 15.   send refresh command after finish LPDDR4 retraining. 1 : enable. 0 : disable.
 //bit 14.   1: cke init low.  0 : cke init high.
 //bit 13    1: dbi write enable only for LPDDR4.
 //bit 12.   1: dbi read inversion.   0:  dbi read high inversion.
 //bit 11.   1: dbi read enable. 0:  dbi not enabled.
 //bit 10    1: enable staggered chip select for 2 ranks DRAM.
 //bit 9     1: enable send auto refresh command to DDR SDRAM when PCTL is in CFG/STOP state.
 //bit 8     send auto refr cmd before enter register triggered  self refresh
 //bit 7     send auto refr cmd after exit register triggered self refresh mode.
 //bit 6     disable dram clock after enter register triggered self refresh.
 //bit 5     send DFI_LP_REQ to PHY after enter register triggered elf refresh mode.
 //bit 4     send DRAM to power down mode after enter self refresh. ONLY for LPDDR4.
 //bit 3     send DFI_CTRLUPD_REQ after exit register triggered self refresh.
 //bit 2     send ZQCS command after exit register triggered self refresh.
 //bit 1     enable PHY triggered DFI_PHYUPD_REQ.
 //bit 0     2T mode. always 1 in DDR3/4 mode.

#define DMC_DRAM_ZQ_CTRL                           0x0187
 //bit 31:16. how long PHY will finish PHY ZQ calibration. so DMC can send update request.
 //bit 15:4 not used.
 //bit 3  enable PHY ZQ CAL in ASR mode.
 //bit 2  ZQ command must be send in different time.
 //bit 1  ZQ command can be send at same time.
 //bit 0  rank0 ZQ only

#define DMC_DRAM_MCFG1                             0x0188
 //bit 31:28 siu_t_mprr.
 //bit 26.  siu_srx_phymr_en
 //bit 25.  siu_lp4_r17_en
 //bit 23.  mrr_dbi_en. to enable dbi function for MR read.
 //bit 21;  enable separate dfi_lp_data_req. 1: enable. 0: dfi_lp_data_req same as dfi_lp_ctrl_req.
 //bit 20:16 dfi_lp_data_wakeup value.
 //bit 14.  enable SIU read data with DBI result.
 //bit 13.  LPDDR5 LINK_ECC read enable.
 //bit 12.  LPDDR5 LINK_ECC write enable.
 //bit 9.   LPDDR5 use WCK always on mode.
 //bit 8    LPDDR5 wck use WCK_FS command for fast 2 rank wck sync command.
 //bit 7:0.  LPDDR4 MRW DBI data mask pattern.  //default 8'b11111000;


#define DMC_DRAM_DFI_CTRL                          0x0189
  //bit 31 siu_dfi_lat err generation enable.  1: if dfi read latency violation, generate data error. 0 : disable.
  //bit 19: dfi_init_complete wait enable.  1: after dfi_init_complete, wait additional EXSR time for new command. 0: phy will handle all the timing    after dfi_init_complete DMC can do everything they want.
  //bit 18:  dfi_rddata_cs_n polarity.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 17:  dfi_wrdata_cs_n polarity.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.

#define DMC_DRAM_DFIINITCFG                        0x018a
  //bit 31.     dfi_init_complete status. read only.
  //bit 19:18.  Frequency set 1 dfi_freq_fsp value.
  //bit 17:16.  Frequency set 0 dfi_freq_fsp value.
  //bit 15:14.  Frequency set 1 dfi_freq_ratio value.
  //bit 12:8    Frequency set 1 dfi_freq value.
  //bit 7:6     Frequency set 0 dfi_freq_ratio value.
  //bit 5:1     Frequency set 0 dfi_freq value.
  //bit 0.      dfi_init_start value  can be use manually config dfi_init_start signal.

#define DMC_DRAM_APD_CTRL                          0x018c
 //bit 20:16  DFI_LP_WAKEUP value in APD DFI_LP_REQ mode
 //bit 12    1: exit power down slow mode(waiting PLL LOCK).  0 : fast mode.
 //bit 11    enable DFI_LP_REQ when enter Auto power down mode.
 //bit 10    disable DFI_clk_disable when enter auto power down mode.
 //bit 9:0    0  disable auto power down mode.
            //non zero value to enable auto power down when DMC is in idle state for this number of clock cycles.

#define DMC_DRAM_ASR_CTRL                          0x018d
  //DMC auto self-refresh function  with 2 major mode.
  // 1) LP2 mode.  DMC through DFI_INIT_START/DFI_INIT_COMPLETE interface to push DDR-PHY in low power state and shut down the DDR-PHY clock and switch the DMC clock to 24Mhz clock to save power as much as possible.
  //               The wakeup time will be much longer because the DDR-PHY deskew-PLL need to relock and the DDR-PHY need to be retraining.
  //               In LP2 mode,  all the DMC side retraining is not necessary, DDR-PHY would handle all the retraining.
  // 2). fast mode.   DMC put DDR-DRAM in self-refresh and power down mode. DMC put DDR-PHY in low power mode with DFI_LP_CTRL_REQ and DFI_LP_DATA_REQ. But the deskew-PLL still working.
  //                  When DMC wakes up,  DMC will check low long the self-refresh mode to decide if the DDR-PHY need to do retraining. So the wakeup time is smaller than the LP2 mode.
  //bit 31. enable RETRAIN PHY after auto selfrefresh exit. for AM_PHY only.
  //bit 30. in DDR3/4 mode, send ZQCL command after exit from auto self refresh mode.
  //bit 29. siu_asr_lpclk_en.
  //bit [28:24] DFI_LP_WAKEUP value in self refresh DFI_LP_REQ mode.
  //bit 23 : send REFRESH command after exit from auto self refersh mode(ASR).
  //bit 22 : send REFERSH command before enter to Auto self refresh mode(ASR).
  //bit 21 : send ZQCS command after exit from Auto self refresh mode(ASR).
  //bit 20 : send dfi_ctrl_upd after exit from ASR mode
  //bit 19 : send power down command when enter ASR mode. //for LPDDR4 only.
  //bit 18 : set the PHY enter LP2 mode after enter ASR mode. //not support for P1 LP5PHY
  //bit 17 : send DFI_LP_REQ  after enter ASR mode.
  //bit 16 : set DFI_CLK_DISABLE after enter ASR mode.
  //bit 15:0.   0 disable auto ASR mode.
             // Non-zero value enable ASR mode. when DMC is in idle state for this number of clock cycles, the DMC will enter ASR mode.

#define DMC_DRAM_PHYDPLL                           0x018f
//bit 13:8. The clock cycles to disable DDR-PHY Deskew PLL before
//          disable PHY-DFI_CLK in LP2 mode.
//bit 7:0.  The clock cycles to enable DDR-PHY Deskew PLL after
//          enable PHY-DFI_CLK in LP2 mode.

#define DMC_DRAM_REFR_CTRL                         0x0192
  //bit 28  enable send phy pvt request after PHY ZQ calibration request.
  //bit 27:24 not used.
  //bit 23  enable Per Bank refresh mode.
  //bit 22  dmc to control DFI_CTRLUPD_REQ  with zq generation together.
  //bit 21  dmc to control PHY ZQ generation enable.
  //bit 20  dmc to control zqlat(in LPDDR4 mode) generation enable.
  //bit 19  dmc to control zqcs1 generation enable.
  //bit 18  dmc to control zqcs0 generation enable.
  //bit 17:8 auto refresh request pending cnt if there's page hit request.
  //bit 7  not used.
  //bit 6  not used.
  //bit 5  enable dmc send ZQCS command .
  //bit 4. enable dmc send DFI_CTRUPD_REQ.
  //bit 3:1. how many refresh command send for one period. = this number + 1
  //bit 0.  enable dmc send auto refresh command.

#define DMC_DRAM_FREQ_CTRL                         0x0193
//bit 31 .  chan0 write 1 to change freqency   read 0: finished.
//bit 30.   chan0 waiting for software to send some manual command.  1 : waiting. 0 : not ready yet.
//bit 29:23.  not used.
//bit 22    siu_freq_refr_en, enter FREQ_AUTO_REFR after DFI freq init start complete
//bit 21     after Freqchange send PHY ZQ update.
//bit 20    send CTRLUPD_REQ to PHY after freq_change finished.
//bit 19:16. how many cycles to send PLL change req after init_complete signal to low.
//bit 15.   freq pre  config_en. Before freq enter stop state let DMC configure DDR SDRAM.
//bit 14.   freq post config_en. After  freq enter stop state let DMC configure DDR SDRAM.
//bit 13.   send zqcl after freq change in DDR3/4 mode.
//bit 12.   send zqcs after freq change. 1: enable. 0 not send.
//bit 11.   in AUTO MRW function: the data format.  1: use USR_CMD format.  0: MRW format.
//bit 10.   AUTO MRW function:  1 use hardware auto MRW function.  0: don't do auto MRW.
//bit 9.  1 : FREQ MRW done. let FREQ change machine continue.
//bit 8   FREQ WAIT. 1 when freq change finishes, state machine stop at self refresh state in case there's something need to handle.
              //     0 after freq change finishes  the state machine go back to access state.
//bit 7   when change PLL setting, disable dmc clock
//bit 6   when change PLL setting, disable PHY DfiClk and DfiCtlClk.
//bit 5   check vpu_sleep_en ==1 when do FREQ change.  if vpu_sleep_en == 0, just wait.
//bit 4   nxt frequency selection.  1 = freq1. 0 = freq0.
//bit 3:1.  not used.
//bit 0.   current frequency selection.

#define DMC_DRAM_SCFG                              0x0194
  // bit 2:0 only one bit can be high at same time.
  // bit 2  1 : to ask PCTL enter ACCESS STATE.  0 : deassert the request.
  // bit 1  1 : to ask PCTL enter SELF REFRESH STATE.  0 : deassert the request.
  // bit 0  1 : to ask PCTL enter STOP/CONFIG STATE .  0 : deassert the request.

#define DMC_DRAM_STAT                              0x0195
  //bit 31     rd latency error. 1: means after dfiphytrdlat cycles, the read data still not back.
  //bit 30.     dram_dfi_lp2_st.
  //bit 29.     dram_lpclk_st.
  //bit 28:24   dram_sr_state
  //bit 23:20   stop_st
  //bit 19:16  freq_st.
    //4'h0 : IDLE
    //4'h1 : FREQ_CHECK_VPU
    //4'h2 : FREQ_WAITING_STOP
    //4'h3 : FREQ_DRAM_CFG.  waiting DMC/software to send special MRW/MPC command to configure DDR SDRAM either before Freq change or after freq change.
    //4'h4 : FREQ_SELF_REFR_ST.
    //4'h5 : FREQ_SET_DFI_FREQ.
    //4'h6 : FREQ_DFI_INIT_START_HIGH.
    //4'h7 : FREQ_CHANGE PLL_ST.
    //4'h8 : FREQ_UPDATA REG.
    //4'h9 : FREQ_DFI_INIT_START_LOW.
    //4'ha : FREQ_WAITING_FINISH
    //4'hb : FREQ_ZQCS
    //4'hc : FREQ_ZQ_LATCH
    //4'hd : FREQ_PVT
  //bit 15:12  ACCESS STATUS 0 :  ACCESS is in normal working mode.
                          //1 :   ACCESS sending precharge command.
                          //2 :   ACCESS sending AUTO REFRESH command.
                          //3 :   ACCESS sending DIF_CTRLUPD_REQ command.
                          //4 :   ACCESS sending ZQCS command to DDR DRAM(ZQCAL for LPDDR4).
                          //5 :   ACCESS sending ZQLATCH command to  LPDDR4 only.

  //bit 11:8   APD STATUS:   0 :   APD_IDLE
                          //1 :    APD sending PRECHARGE command
                          //2 :    APD sending CKE low command
                          //3 :    APD sending DISABLE DRAM CLOCK command
                          //4 :    APD sending DFI_LP_CTRL_REQ
                          //5 :    APD in Auto Power down mode.
                          //6 :    APD deassert DFI_LP_CTRL_REQ
                          //7 :    APD sending enable DRAM CLOCK command
                          //8 :    APD sending out CKE high command.
  //bit 7:4: DRAM_STATUS:  0  :    DRAM IDLE
                         //1  :    DRAM_STOP/DRAM_CFG
                         //2  :    DRAM_ACCESS
                         //3  :    DRAM_SLEEP
                         //4  :    DRAM APD(AUTO POWER DOWN).
                         //5  :    IDLE -> STOP/CONFIG
                         //6  :    STOP -> SLEEP
                         //7  :    STOP -> ACCESS
                         //8  :    ACCESS -> SLEEP.
                         //9  :    ACCESS -> STOP
                         //A  :    ACCESS -> APD
                         //B  :    SLEEP -> STOP
                         //C  :    SLEEP -> ACCESS
                         //D  :    APD -> ACCESS
   //bit 3        reserved.
   //bit 2        1 : DRAM enter normal working state.
   //bit 1        1 : DRAM enter sleep state. self refresh state.
   //bit 0        1 : dram enter cfg state.

#define DMC_DRAM_STAT1                             0x0196
  //bit 12:8   sleep_st
  //bit  7:5   train_st
  //bit  4:0   dram_phy_st


#define DMC_PHY_RETRAINING_CTRL                    0x0197
  //bit 31 :  phy_retraining enable.
  //bit 30 :  check  vpu sleep_en.
  //bit 29 :  retrain_only 1: use full 28:24 as retrain dfi_freq value 0: use only 28:27 + original dfi_freq2:0 as the retrain dfi_freq.
  //bit 28:24 : retraining dfi_freq[4:3], the [2:0] bit still use the dfi_freq bits to keep the frequency.
  //bit 23:    retrain cke mode enable use for LPDDR4 mode. before send dfi_init_start request to DDR_PHY,
               //1: put LPDDR4 SDRAM into self_refresh + power down mode. 0: put LPDDR4 SDRAM in self-refresh  mode.
  //bit 22:16:  reserved
  //bit 15:0: retraining period unit : one refresh period.


#define DMC_LP2_TIMER                              0x019a
//bit 15:0.   timer setting to measure how long the chip is entered LP2 mode.
//this timer is 40bits counter with DMC PCLK.
//we use the high 16bits to compare this register. if the counter is large than this number,  that means  the PHY need addition 10us after wakeup the PHY and before exit self_refresh mode.

#define DMC_DRAM_COMPLETE_WAIT                     0x019b
 //read only how long to waiting for DFI_INIT_COMPLETE become high after DFI_INIT_START triggered.

#define DMC_OSC_CTRL                               0x019c
//bit 31  osc_en. for LPDDR4 enable MPC DQS2DQ OSC counter .
//bit 30:16.  siu_osc_run.  LPDDR4 DQS interval timer run time in n_clk unit.
//bit 15:0 osc counter value in tREFI time. how long to trigger one DQS2DQ retraining.

#define DMC_TEMP_CTRL                              0x019d
//bit 31  mr temp read control.
//bit 15:0 counter value in t100NS.

#define DMC_TEMP_CTRL1                             0x019e
//bit 31   mr auto read change irq, 2 channel clear (level)
//bit 30   mrr_diff_irq0
//bit 27   mrr1_diff
//bit 26   mrr0_diff
//bit 10   channel0 mr auto read data format: 1-serial,0-parallal
//bit 7:0  channel0 mr index.




#define DMC_DRAM_TPBR                              0x01a0
  //bit 23:16 tPBR2ACT
  //bit 9:0   tPBR2PBR
#define DMC_DRAM_TWCK_FS                           0x01a1
  //not used. timing for wck_fs sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_WR                           0x01a2
  //not used. timing for wck_wr sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_RD                           0x01a3
  //not used. timing for wck_rd sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_OFF                          0x01a4
  //not used. timing for wck_rd sync command
  //bit 31:24 not used.
  //bit 23:16 timing from write command to wck off timing.
             //  = WL + BURST + TWCKPOST + tWCK2DQI ?
  //bit 15:8  WCKOFF cmd to other command timing.
  //bit 7:0   timing from read command to wck off timing.
             //  = RL + BURST + TWCKPOST + tWCK2DQO ?
#define DMC_DRAM_TPPD                              0x01a5
  //bit 31:24 not used.
  //bit 7:0.  tPPD. precharge to precharge delay in LPDDR5.
#define DMC_DRAM_TCSH                              0x01a6
  //bit 7:0.  tCSH for LPDDR5
#define DMC_DRAM_TCMDPD                            0x01a7
  //bit 7:0.  tCMDPD for LPDDR5
#define DMC_DRAM_TOSCPD                            0x01a8
  //bit 15:0.  tOSCPD for LPDDR5 : tOSCPD + tOSC
#define DMC_DRAM_TWCK2DQ                           0x01a9
 //not used.
 //bit 23:16. tWCK2DQI max
 //bit 7:0.   tWCK2DQO max
#define DMC_DRAM_TRFM                              0x01aa
 //not used.
 //9:0. tRFMpb for lpddr5
#define DMC_DRAM_TCKMAX                            0x01ab
 //9:0  tclk(max).    100ns in LPDDR4.


#define DMC_NFQ_TPBR                               0x01b0
#define DMC_NFQ_TWCK_FS                            0x01b1
#define DMC_NFQ_TWCK_WR                            0x01b2
#define DMC_NFQ_TWCK_RD                            0x01b3
#define DMC_NFQ_TWCK_OFF                           0x01b4
#define DMC_NFQ_TPPD                               0x01b5
#define DMC_NFQ_TCSH                               0x01b6
#define DMC_NFQ_TCMDPD                             0x01b7
#define DMC_NFQ_TOSCPD                             0x01b8
#define DMC_NFQ_TWCK2DQ                            0x01b9
#define DMC_NFQ_TRFM                               0x01ba
#define DMC_NFQ_TCKMAX                             0x01bb



#define DMC_DRAM_DFI_SWAP_0                        0x01c0
#define DMC_DRAM_DFI_SWAP_1                        0x01c1
#define DMC_DRAM_DFI_SWAP_2                        0x01c2
#define DMC_DRAM_DFI_SWAP_3                        0x01c3
#define DMC_DRAM_DFI_SWAP_4                        0x01c4


#define DMC_DRAM_MRR0                              0x01c5
 //31:16 the 1st MR read result mask
 //15:0  the 1st MR read result for snoop
#define DMC_DRAM_MRR1                              0x01c6
 //31:16 the 2nd MR read result mask
 //15:0  the 2nd MR read result for snoop


#define DMC_DRAM_RAA_CTRL                          0x01cd
  //bit 31.  rfm command enable.

#define DMC_DRAM_RAA_CTRL1                         0x01ce
  //bit 29:20.   RAAMMT
  //bit 19:10.   RAADEC*RAAIMT  for RFM command
  //bit  9:0     RAAIMT for REF command.


#define DMC_DRAM_CMD                               0x01d0
 //bit 31. cmd done.  write 0 to clean.
 //bit 30. cmd r/w channel select. 1:chan1  0:chan0
 //bit 8 . dram command is for data 16 bits.
 //bit 7:6 2'b01: user command with data read.
         //2'b10: user command with data write.
         //2'b00: user command without data.
 //bit 5.  user defined command.
 //bit 4.  LPDDR4 MPC write data command( MPC WR FIFO). not support in LPDDR5.
 //bit 3.  LPDDR4 MPC read data command (MPC RD Calibration and RD FIFO). not support in LPDDR5
 //bit 2.  LPDDR4 MPC-1 command ( NOP,  Start DQS interval ....)
 //bit 1.  mrr comand.
 //bit 0.  mrw command.

#define DMC_DRAM_CMD_CODE                          0x01d1
  //bit 27:26. 128bits data cycles . 0: 1 clock cycles;  1: 2  clock cycles; 2: 3 clock cycles; 3:4 clock cycles.
        //LPDDR4 : 2 clock cycles;
        //LPDDR5 : 2 clock cycles for MRR command.  4 cycles for RFF command.

#define DMC_DRAM_CMD_TIME                          0x01d2
//bit 31:16  PRE  CMD timer. //delay how many cycle to start the command.
//bit 15:0   POST CMD timer  //delay how many cycle after the command execute.

#define DMC_DRAM_WSTRB0                            0x01d3
#define DMC_DRAM_WSTRB1                            0x01d4
#define DMC_DRAM_RDBI0                             0x01d5
  //MPC RD FIFO command DBI read back data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.
#define DMC_DRAM_RDBI1                             0x01d6
  //MPC RD FIFO command DBI read back data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.
#define DMC_DRAM_RSTS                              0x01d7
    //bit3 data cnt 3 for dfi phy read latency error
    //bit2 data cnt 2 for dfi phy read latency error
    //bit1 data cnt 1 for dfi phy read latency error
    //bit0 data cnt 0 for dfi phy read latency error

//WD0~16 and RD0~16 can be used as MRW command as Frequency change .
//WD0~16 is for Freq1 DRAM MR setting, it would send to DRAM right before FREQ0-> FREQ1
//RD0_16 is for Freq0 DRAM MR setting. it would send to DRAM right before FREQ1-> FREQ0.
//each register can be one MRW command. So total 16 MRW command can be sent to DRAM.
//The register formats:
//bit 31.   MRW/USER comand enable.  1: enabled command. 0 not enabled.
//bit 30.   last MRW/USER command.   if this bit =1, After send this command, the DRAM controller will contine frequency next stage.
//bit 29:26. USER COMMAND parameter: in DDR3/DDR4.  {act_n, ras_n, cas_n, we_n} value for user command
                                     //in LPDDR4.  bit 16: 1 4 cycles command.  0 2 cycles command.
//bit 25     MRW/USER command rank 1 select.  1: select.  0: not select.
//bit 24.    MRW/USER command rank 0 select.  1: select.  0: not select.
//bit 23:0.  USER command.
             //DDR3:    18:16 bank address. 15:0:  address.
             //DDR4:    20:19 bank group address.   18:16: bank address. 15:0 address.
             //LPDDR3:   9:0. rising edge address.  19:10.  falling edge address.
             //LPDDR4.   5:0, first edge address,  11:6 second edge address, 17:12: third edge address. 23:18, forth edge address.
           //MRW command format:
              //bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
              //bit 15:0   opcode.
#define DMC_DRAM_WD0                               0x01e0
#define DMC_DRAM_WD1                               0x01e1
#define DMC_DRAM_WD2                               0x01e2
#define DMC_DRAM_WD3                               0x01e3
#define DMC_DRAM_WD4                               0x01e4
#define DMC_DRAM_WD5                               0x01e5
#define DMC_DRAM_WD6                               0x01e6
#define DMC_DRAM_WD7                               0x01e7
#define DMC_DRAM_WD8                               0x01e8
#define DMC_DRAM_WD9                               0x01e9
#define DMC_DRAM_WD10                              0x01ea
#define DMC_DRAM_WD11                              0x01eb
#define DMC_DRAM_WD12                              0x01ec
#define DMC_DRAM_WD13                              0x01ed
#define DMC_DRAM_WD14                              0x01ee
#define DMC_DRAM_WD15                              0x01ef

#define DMC_DRAM_RD0                               0x01f0
#define DMC_DRAM_RD1                               0x01f1
#define DMC_DRAM_RD2                               0x01f2
#define DMC_DRAM_RD3                               0x01f3
#define DMC_DRAM_RD4                               0x01f4
#define DMC_DRAM_RD5                               0x01f5
#define DMC_DRAM_RD6                               0x01f6
#define DMC_DRAM_RD7                               0x01f7
#define DMC_DRAM_RD8                               0x01f8
#define DMC_DRAM_RD9                               0x01f9
#define DMC_DRAM_RD10                              0x01fa
#define DMC_DRAM_RD11                              0x01fb
#define DMC_DRAM_RD12                              0x01fc
#define DMC_DRAM_RD13                              0x01fd
#define DMC_DRAM_RD14                              0x01fe
#define DMC_DRAM_RD15                              0x01ff


//STICKY registers.
//those register is for software save some temporary value. and because it's in RAM. it won't lose if DMC get reseted.
#define DMC_STICKY_0                               0x0200
#define DMC_STICKY_1                               0x0201
#define DMC_STICKY_2                               0x0202
#define DMC_STICKY_3                               0x0203
#define DMC_STICKY_4                               0x0204
#define DMC_STICKY_5                               0x0205
#define DMC_STICKY_6                               0x0206
#define DMC_STICKY_7                               0x0207
#define DMC_STICKY_8                               0x0208
#define DMC_STICKY_9                               0x0209
#define DMC_STICKY_10                              0x020a
#define DMC_STICKY_11                              0x020b
#define DMC_STICKY_12                              0x020c
#define DMC_STICKY_13                              0x020d
#define DMC_STICKY_14                              0x020e
#define DMC_STICKY_15                              0x020f
#define DMC_STICKY_16                              0x0210
#define DMC_STICKY_17                              0x0211
#define DMC_STICKY_18                              0x0212
#define DMC_STICKY_19                              0x0213
#define DMC_STICKY_20                              0x0214
#define DMC_STICKY_21                              0x0215
#define DMC_STICKY_22                              0x0216
#define DMC_STICKY_23                              0x0217
#define DMC_STICKY_24                              0x0218
#define DMC_STICKY_25                              0x0219
#define DMC_STICKY_26                              0x021a
#define DMC_STICKY_27                              0x021b
#define DMC_STICKY_28                              0x021c
#define DMC_STICKY_29                              0x021d
#define DMC_STICKY_30                              0x021e
#define DMC_STICKY_31                              0x021f
#define DMC_STICKY_32                              0x0220
#define DMC_STICKY_33                              0x0221
#define DMC_STICKY_34                              0x0222
#define DMC_STICKY_35                              0x0223
#define DMC_STICKY_36                              0x0224
#define DMC_STICKY_37                              0x0225
#define DMC_STICKY_38                              0x0226
#define DMC_STICKY_39                              0x0227
#define DMC_STICKY_40                              0x0228
#define DMC_STICKY_41                              0x0229
#define DMC_STICKY_42                              0x022a
#define DMC_STICKY_43                              0x022b
#define DMC_STICKY_44                              0x022c
#define DMC_STICKY_45                              0x022d
#define DMC_STICKY_46                              0x022e
#define DMC_STICKY_47                              0x022f
#define DMC_STICKY_48                              0x0230
#define DMC_STICKY_49                              0x0231
#define DMC_STICKY_50                              0x0232
#define DMC_STICKY_51                              0x0233
#define DMC_STICKY_52                              0x0234
#define DMC_STICKY_53                              0x0235
#define DMC_STICKY_54                              0x0236
#define DMC_STICKY_55                              0x0237
#define DMC_STICKY_56                              0x0238
#define DMC_STICKY_57                              0x0239
#define DMC_STICKY_58                              0x023a
#define DMC_STICKY_59                              0x023b
#define DMC_STICKY_60                              0x023c
#define DMC_STICKY_61                              0x023d
#define DMC_STICKY_62                              0x023e
#define DMC_STICKY_63                              0x023f

#define DMC_PROT_STS0                              0x0280
#define DMC_PROT_STS1                              0x0281
#define DMC_PROT_STS127                            0x02ff


//*************************************************
//11'h300 ~ 11'h3ff for dmc_freq_clk apb register
//*************************************************


//DMC Security control registers.
//DMC use 15bits ARUSER/AWUSER bits to identify AXI input ports master ID and security requirement and the necessary subID for bandwidth monitor protection functions. .
//bit 7:0.   for upto 256 Master-ID.
//bit  14:8.  for each Master-ID, the master can use those bits to define particular security requirements or bandwidth and protection function special requirements.



//region0(RANGE0) related register.
#define DMC_SEC_RANGE0_STA                         0x0400
  //bit 31:20. not used.
  //bit 19:0.   region start address AXI address [31:12] unit 4Kbyte.
#define DMC_SEC_RANGE0_EDA                         0x0401
  //bit 31:20. not used.
  //bit 19:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE0_CTRL                        0x0402
  //bit 7:5.range0_security_level
  //bit 4.  range0_prot_en. range 0 protect monitor function control
  //bit 3.  range0_des_en. range 0 data scrambling enable
  //bit 2.  range0 lock.
  //bit 1.  range0 key select
  //bit 0.  range0 enable
#define DMC_SEC_RANGE0_RID_CTRL0                   0x0403
  //range_rd_sid_en[31:0];
#define DMC_SEC_RANGE0_RID_CTRL1                   0x0404
  //range_rd_sid_en[63:32];
#define DMC_SEC_RANGE0_WID_CTRL0                   0x0408
  //range_wr_sid_en[31:0];
#define DMC_SEC_RANGE0_WID_CTRL1                   0x0409
  //range_wr_sid_en[63:32];

//region1(RANGE1) related register.
#define DMC_SEC_RANGE1_STA                         0x0410
#define DMC_SEC_RANGE1_EDA                         0x0411
#define DMC_SEC_RANGE1_CTRL                        0x0412
#define DMC_SEC_RANGE1_RID_CTRL0                   0x0413
#define DMC_SEC_RANGE1_RID_CTRL1                   0x0414
#define DMC_SEC_RANGE1_WID_CTRL0                   0x0418
#define DMC_SEC_RANGE1_WID_CTRL1                   0x0419

//region2(RANGE2) related register.
#define DMC_SEC_RANGE2_STA                         0x0420
#define DMC_SEC_RANGE2_EDA                         0x0421
#define DMC_SEC_RANGE2_CTRL                        0x0422
#define DMC_SEC_RANGE2_RID_CTRL0                   0x0423
#define DMC_SEC_RANGE2_RID_CTRL1                   0x0424
#define DMC_SEC_RANGE2_WID_CTRL0                   0x0428
#define DMC_SEC_RANGE2_WID_CTRL1                   0x0429

//region3(RANGE3) related register.
#define DMC_SEC_RANGE3_STA                         0x0430
#define DMC_SEC_RANGE3_EDA                         0x0431
#define DMC_SEC_RANGE3_CTRL                        0x0432
#define DMC_SEC_RANGE3_RID_CTRL0                   0x0433
#define DMC_SEC_RANGE3_RID_CTRL1                   0x0434
#define DMC_SEC_RANGE3_WID_CTRL0                   0x0438
#define DMC_SEC_RANGE3_WID_CTRL1                   0x0439

//region4(RANGE4) related register.
#define DMC_SEC_RANGE4_STA                         0x0440
#define DMC_SEC_RANGE4_EDA                         0x0441
#define DMC_SEC_RANGE4_CTRL                        0x0442
#define DMC_SEC_RANGE4_RID_CTRL0                   0x0443
#define DMC_SEC_RANGE4_RID_CTRL1                   0x0444
#define DMC_SEC_RANGE4_WID_CTRL0                   0x0448
#define DMC_SEC_RANGE4_WID_CTRL1                   0x0449

//region5(RANGE5) related register.
#define DMC_SEC_RANGE5_STA                         0x0450
#define DMC_SEC_RANGE5_EDA                         0x0451
#define DMC_SEC_RANGE5_CTRL                        0x0452
#define DMC_SEC_RANGE5_RID_CTRL0                   0x0453
#define DMC_SEC_RANGE5_RID_CTRL1                   0x0454
#define DMC_SEC_RANGE5_WID_CTRL0                   0x0458
#define DMC_SEC_RANGE5_WID_CTRL1                   0x0459

//region6(RANGE6) related register.
#define DMC_SEC_RANGE6_STA                         0x0460
#define DMC_SEC_RANGE6_EDA                         0x0461
#define DMC_SEC_RANGE6_CTRL                        0x0462
#define DMC_SEC_RANGE6_RID_CTRL0                   0x0463
#define DMC_SEC_RANGE6_RID_CTRL1                   0x0464
#define DMC_SEC_RANGE6_WID_CTRL0                   0x0468
#define DMC_SEC_RANGE6_WID_CTRL1                   0x0469

//region7(RANGE7) related register.
#define DMC_SEC_RANGE7_STA                         0x0470
#define DMC_SEC_RANGE7_EDA                         0x0471
#define DMC_SEC_RANGE7_CTRL                        0x0472
#define DMC_SEC_RANGE7_RID_CTRL0                   0x0473
#define DMC_SEC_RANGE7_RID_CTRL1                   0x0474
#define DMC_SEC_RANGE7_WID_CTRL0                   0x0478
#define DMC_SEC_RANGE7_WID_CTRL1                   0x0479

//region8(RANGE8) related register.
#define DMC_SEC_RANGE8_STA                         0x0480
#define DMC_SEC_RANGE8_EDA                         0x0481
#define DMC_SEC_RANGE8_CTRL                        0x0482
#define DMC_SEC_RANGE8_RID_CTRL0                   0x0483
#define DMC_SEC_RANGE8_RID_CTRL1                   0x0484
#define DMC_SEC_RANGE8_WID_CTRL0                   0x0488
#define DMC_SEC_RANGE8_WID_CTRL1                   0x0489

//region9(RANGE9) related register.
#define DMC_SEC_RANGE9_STA                         0x0490
#define DMC_SEC_RANGE9_EDA                         0x0491
#define DMC_SEC_RANGE9_CTRL                        0x0492
#define DMC_SEC_RANGE9_RID_CTRL0                   0x0493
#define DMC_SEC_RANGE9_RID_CTRL1                   0x0494
#define DMC_SEC_RANGE9_WID_CTRL0                   0x0498
#define DMC_SEC_RANGE9_WID_CTRL1                   0x0499

//region10(RANGEA) related register.
#define DMC_SEC_RANGE10_STA                        0x04a0
#define DMC_SEC_RANGE10_EDA                        0x04a1
#define DMC_SEC_RANGE10_CTRL                       0x04a2
#define DMC_SEC_RANGE10_RID_CTRL0                  0x04a3
#define DMC_SEC_RANGE10_RID_CTRL1                  0x04a4
#define DMC_SEC_RANGE10_WID_CTRL0                  0x04a8
#define DMC_SEC_RANGE10_WID_CTRL1                  0x04a9

//region11(RANGEB) related register.
#define DMC_SEC_RANGE11_STA                        0x04b0
#define DMC_SEC_RANGE11_EDA                        0x04b1
#define DMC_SEC_RANGE11_CTRL                       0x04b2
#define DMC_SEC_RANGE11_RID_CTRL0                  0x04b3
#define DMC_SEC_RANGE11_RID_CTRL1                  0x04b4
#define DMC_SEC_RANGE11_WID_CTRL0                  0x04b8
#define DMC_SEC_RANGE11_WID_CTRL1                  0x04b9


//region12(RANGEC) related register.
#define DMC_SEC_RANGE12_STA                        0x04c0
#define DMC_SEC_RANGE12_EDA                        0x04c1
#define DMC_SEC_RANGE12_CTRL                       0x04c2
#define DMC_SEC_RANGE12_RID_CTRL0                  0x04c3
#define DMC_SEC_RANGE12_RID_CTRL1                  0x04c4
#define DMC_SEC_RANGE12_WID_CTRL0                  0x04c8
#define DMC_SEC_RANGE12_WID_CTRL1                  0x04c9


//region13(RANGED) related register.
#define DMC_SEC_RANGE13_STA                        0x04d0
#define DMC_SEC_RANGE13_EDA                        0x04d1
#define DMC_SEC_RANGE13_CTRL                       0x04d2
#define DMC_SEC_RANGE13_RID_CTRL0                  0x04d3
#define DMC_SEC_RANGE13_RID_CTRL1                  0x04d4
#define DMC_SEC_RANGE13_WID_CTRL0                  0x04d8
#define DMC_SEC_RANGE13_WID_CTRL1                  0x04d9


//region14(RANGEE) related register.
#define DMC_SEC_RANGE14_STA                        0x04e0
#define DMC_SEC_RANGE14_EDA                        0x04e1
#define DMC_SEC_RANGE14_CTRL                       0x04e2
#define DMC_SEC_RANGE14_RID_CTRL0                  0x04e3
#define DMC_SEC_RANGE14_RID_CTRL1                  0x04e4
#define DMC_SEC_RANGE14_WID_CTRL0                  0x04e8
#define DMC_SEC_RANGE14_WID_CTRL1                  0x04e9


//region15(RANGEF) related register.
#define DMC_SEC_RANGE15_STA                        0x04f0
#define DMC_SEC_RANGE15_EDA                        0x04f1
#define DMC_SEC_RANGE15_CTRL                       0x04f2
#define DMC_SEC_RANGE15_RID_CTRL0                  0x04f3
#define DMC_SEC_RANGE15_RID_CTRL1                  0x04f4
#define DMC_SEC_RANGE15_WID_CTRL0                  0x04f8
#define DMC_SEC_RANGE15_WID_CTRL1                  0x04f9




//DMC SECURE CHECK TABLE
#define DMC_TBL_KEY_SEL                            0x04bc
 //bit 31: : reserved
 //bit 7 :4 :sec_tbl_reg_offset. each 32 reg offset. real reg addr = 32*offset+11'h680, 16*32=512.
 //bit 3 : reserved
 //bit 2 : tbl_sec_vid_key_sel
 //bit 1 : tbl_nonsec_vid_key_sel
 //bit 0 : tbl_reg_lock

#define DMC_SEC_TBL0_CTRL                          0x04bd
 //bit 31 : Sec_tbl0_en,  sec_tbl0 is used
 //bit 30:29 : reserved
 //bit 28:26 : Sec_tbl0_blk_size,
               //3'h0:  4Kbyte, 3'h1: 8Kbyte. 3'h2: 16Kbyte. 3'h3: 32Kbyte.
			   //3'h4: 64Kbyte. 3'h5: 128Kbyte. 3'h6: 1Mbyte.  3'h7: 2Mbyte.
 //bit 25:13 : Sec_tbl0_eda, sec_tbl0 AXI end address.  Unit 2Mbyte.
 //bit 12:0 : Sec_tbl0_sta, sec_tbl0 AXI start address. Unit 2Mbyte.

#define DMC_SEC_TBL1_CTRL                          0x04be
 //bit 31 : Sec_tbl1_en,  sec_tbl1 is used
 //bit 30:29 : reserved
 //bit 28:26 : Sec_tbl1_blk_size,
               //3'h0:  4Kbyte, 3'h1: 8Kbyte. 3'h2: 16Kbyte. 3'h3: 32Kbyte.
			   //3'h4: 64Kbyte. 3'h5: 128Kbyte. 3'h6: 1Mbyte.  3'h7: 2Mbyte.
 //bit 25:13 : Sec_tbl1_eda, sec_tbl1 AXI end address.  Unit 2Mbyte.
 //bit 12:0 : Sec_tbl1_sta, sec_tbl1 AXI start address. Unit 2Mbyte.

#define DMC_SEC_TBL1_CTRL1                         0x04bf
 //bit 31:9 : reserved
 //bit 8:0 : Sec_tbl1_offset. the 512x32 SRAM address offset if the sec_tbl1 is enabled

#define DMC_SEC_TBL_SEC_WID_CTRL0                  0x04cc
 //128bits WRITE security master ID access enable control registers for secure-video data type.
 //bit 31:0 : tbl_sec_wid_ctrl[31:0]
#define DMC_SEC_TBL_SEC_WID_CTRL1                  0x04cd
 //bit 31:0 : tbl_sec_wid_ctrl[63:32]
#define DMC_SEC_TBL_SEC_WID_CTRL2                  0x04ce
 //bit 31:0 : tbl_sec_wid_ctrl[95:64]
#define DMC_SEC_TBL_SEC_WID_CTRL3                  0x04cf
 //bit 31:0 : tbl_sec_wid_ctrl[127:96]

#define DMC_SEC_TBL_NONSEC_WID_CTRL0               0x04dc
 //128bits WRITE security master ID access enable control registers for not secure-video data type.
 //bit 31:0 : tbl_nonsec_wid_ctrl[31:0]
#define DMC_SEC_TBL_NONSEC_WID_CTRL1               0x04dd
 //bit 31:0 : tbl_nonsec_wid_ctrl[63:32]
#define DMC_SEC_TBL_NONSEC_WID_CTRL2               0x04de
 //bit 31:0 : tbl_nonsec_wid_ctrl[95:64]
#define DMC_SEC_TBL_NONSEC_WID_CTRL3               0x04df
 //bit 31:0 : tbl_nonsec_wid_ctrl[127:96]

#define DMC_SEC_TBL_SEC_RID_CTRL0                  0x04ec
 //128 bits READ security master ID  access enable control registers for secure-video data type.
 //bit 31:0 : tbl_sec_rid_ctrl[31:0]
#define DMC_SEC_TBL_SEC_RID_CTRL1                  0x04ed
 //bit 31:0 : tbl_sec_rid_ctrl[63:32]
#define DMC_SEC_TBL_SEC_RID_CTRL2                  0x04ee
 //bit 31:0 : tbl_sec_rid_ctrl[95:64]
#define DMC_SEC_TBL_SEC_RID_CTRL3                  0x04ef
 //bit 31:0 : tbl_sec_rid_ctrl[127:96]

#define DMC_SEC_TBL_NONSEC_RID_CTRL0               0x04fc
 //128bits read security master ID access enable control registers for not secure-video data type.
 //bit 31:0 : tbl_nonsec_rid_ctrl[31:0]
#define DMC_SEC_TBL_NONSEC_RID_CTRL1               0x04fd
 //bit 31:0 : tbl_nonsec_rid_ctrl[63:32]
#define DMC_SEC_TBL_NONSEC_RID_CTRL2               0x04fe
 //bit 31:0 : tbl_nonsec_rid_ctrl[95:64]
#define DMC_SEC_TBL_NONSEC_RID_CTRL3               0x04ff
 //bit 31:0 : tbl_nonsec_rid_ctrl[127:96]



#define DMC_DES_PADDING                            0x0500
  //bit 31:0 | 0 | des_pading | 32bits address padding used for DES dkey generation.

#define DMC_DES_CTRL                               0x0501
 //bit 1 | 0 | GLOBAL_DES_EN |  1: Global DES enable. 0 : global DES disable.  default is 0.
 //bit 0 | 0 | DES_lock  |  one time lock bit. after write 1 to this bit, DMC_DES_CTRL,DMC_DES_PADDING  can't be write and read.

#define DMC_DES_CTRL1                              0x050a
 //bit 31 : range31_des_en policy : 1 range31_des_en = range31_local_des_en && GLOBAL_DES_EN. 0 : range31_des_en = range31_local_des_en ||  GLOBAL_DES_EN.
 //bit 30 : range30_des_en policy : 1 range30_des_en = range30_local_des_en && GLOBAL_DES_EN. 0 : range30_des_en = range30_local_des_en ||  GLOBAL_DES_EN.
 //bit 29 : range29_des_en policy : 1 range29_des_en = range29_local_des_en && GLOBAL_DES_EN. 0 : range29_des_en = range29_local_des_en ||  GLOBAL_DES_EN.
 //bit 28 : range28_des_en policy : 1 range28_des_en = range28_local_des_en && GLOBAL_DES_EN. 0 : range28_des_en = range28_local_des_en ||  GLOBAL_DES_EN.
 //bit 27 : range27_des_en policy : 1 range27_des_en = range27_local_des_en && GLOBAL_DES_EN. 0 : range27_des_en = range27_local_des_en ||  GLOBAL_DES_EN.
 //bit 26 : range26_des_en policy : 1 range26_des_en = range26_local_des_en && GLOBAL_DES_EN. 0 : range26_des_en = range26_local_des_en ||  GLOBAL_DES_EN.
 //bit 25 : range25_des_en policy : 1 range25_des_en = range25_local_des_en && GLOBAL_DES_EN. 0 : range25_des_en = range25_local_des_en ||  GLOBAL_DES_EN.
 //bit 24 : range24_des_en policy : 1 range24_des_en = range24_local_des_en && GLOBAL_DES_EN. 0 : range24_des_en = range24_local_des_en ||  GLOBAL_DES_EN.
 //bit 23 : range23_des_en policy : 1 range23_des_en = range23_local_des_en && GLOBAL_DES_EN. 0 : range23_des_en = range23_local_des_en ||  GLOBAL_DES_EN.
 //bit 22 : range22_des_en policy : 1 range22_des_en = range22_local_des_en && GLOBAL_DES_EN. 0 : range22_des_en = range22_local_des_en ||  GLOBAL_DES_EN.
 //bit 21 : range21_des_en policy : 1 range21_des_en = range21_local_des_en && GLOBAL_DES_EN. 0 : range21_des_en = range21_local_des_en ||  GLOBAL_DES_EN.
 //bit 20 : range20_des_en policy : 1 range20_des_en = range20_local_des_en && GLOBAL_DES_EN. 0 : range20_des_en = range20_local_des_en ||  GLOBAL_DES_EN.
 //bit 19 : range19_des_en policy : 1 range19_des_en = range19_local_des_en && GLOBAL_DES_EN. 0 : range19_des_en = range19_local_des_en ||  GLOBAL_DES_EN.
 //bit 18 : range18_des_en policy : 1 range18_des_en = range18_local_des_en && GLOBAL_DES_EN. 0 : range18_des_en = range18_local_des_en ||  GLOBAL_DES_EN.
 //bit 17 : range17_des_en policy : 1 range17_des_en = range17_local_des_en && GLOBAL_DES_EN. 0 : range17_des_en = range17_local_des_en ||  GLOBAL_DES_EN.
 //bit 16 : range16_des_en policy : 1 range16_des_en = range16_local_des_en && GLOBAL_DES_EN. 0 : range16_des_en = range16_local_des_en ||  GLOBAL_DES_EN.
 //bit 15 : range15_des_en policy : 1 range15_des_en = range15_local_des_en && GLOBAL_DES_EN. 0 : range15_des_en = range15_local_des_en ||  GLOBAL_DES_EN.
 //bit 14 : range14_des_en policy : 1 range14_des_en = range14_local_des_en && GLOBAL_DES_EN. 0 : range14_des_en = range14_local_des_en ||  GLOBAL_DES_EN.
 //bit 13 : range13_des_en policy : 1 range13_des_en = range13_local_des_en && GLOBAL_DES_EN. 0 : range13_des_en = range13_local_des_en ||  GLOBAL_DES_EN.
 //bit 12 : range12_des_en policy : 1 range12_des_en = range12_local_des_en && GLOBAL_DES_EN. 0 : range12_des_en = range12_local_des_en ||  GLOBAL_DES_EN.
 //bit 11 : range11_des_en policy : 1 range11_des_en = range11_local_des_en && GLOBAL_DES_EN. 0 : range11_des_en = range11_local_des_en ||  GLOBAL_DES_EN.
 //bit 10 : range10_des_en policy : 1 range11_des_en = range10_local_des_en && GLOBAL_DES_EN. 0 : range10_des_en = range10_local_des_en ||  GLOBAL_DES_EN.
 //bit  9 : range9_des_en policy  : 1  range9_des_en =  range9_local_des_en && GLOBAL_DES_EN. 0 :  range9_des_en =  range9_local_des_en ||  GLOBAL_DES_EN.
 //bit  8 : range8_des_en policy  : 1  range8_des_en =  range8_local_des_en && GLOBAL_DES_EN. 0 :  range8_des_en =  range8_local_des_en ||  GLOBAL_DES_EN.
 //bit  7 : range7_des_en policy  : 1  range7_des_en =  range7_local_des_en && GLOBAL_DES_EN. 0 :  range7_des_en =  range7_local_des_en ||  GLOBAL_DES_EN.
 //bit  6 : range6_des_en policy  : 1  range6_des_en =  range6_local_des_en && GLOBAL_DES_EN. 0 :  range6_des_en =  range6_local_des_en ||  GLOBAL_DES_EN.
 //bit  5 : range5_des_en policy  : 1  range5_des_en =  range5_local_des_en && GLOBAL_DES_EN. 0 :  range5_des_en =  range5_local_des_en ||  GLOBAL_DES_EN.
 //bit  4 : range4_des_en policy  : 1  range4_des_en =  range4_local_des_en && GLOBAL_DES_EN. 0 :  range4_des_en =  range4_local_des_en ||  GLOBAL_DES_EN.
 //bit  3 : range3_des_en policy  : 1  range3_des_en =  range3_local_des_en && GLOBAL_DES_EN. 0 :  range3_des_en =  range3_local_des_en ||  GLOBAL_DES_EN.
 //bit  2 : range2_des_en policy  : 1  range2_des_en =  range2_local_des_en && GLOBAL_DES_EN. 0 :  range2_des_en =  range2_local_des_en ||  GLOBAL_DES_EN.
 //bit  1 : range1_des_en policy  : 1  range1_des_en =  range1_local_des_en && GLOBAL_DES_EN. 0 :  range1_des_en =  range1_local_des_en ||  GLOBAL_DES_EN.
 //bit  0 : range0_des_en policy  : 1  range0_des_en =  range0_local_des_en && GLOBAL_DES_EN. 0 :  range0_des_en =  range0_local_des_en ||  GLOBAL_DES_EN.


#define DMC_DES_KEY0_REG0                          0x0502
#define DMC_DES_KEY0_REG1                          0x0503
#define DMC_DES_KEY0_REG2                          0x0504
#define DMC_DES_KEY0_REG3                          0x0505
#define DMC_DES_KEY1_REG0                          0x0506
#define DMC_DES_KEY1_REG1                          0x0507
#define DMC_DES_KEY1_REG2                          0x0508
#define DMC_DES_KEY1_REG3                          0x0509

//FROM SC2, the APB bus provided Master ID through PUSER.
//after ID_REMAP, this PUSE provided 8 master ID type.
//they are:
//  8'b0000_0001 : TEE
//  8'h0000_0010 : REE
//  8'h0000_0100 : JTAG
//  8'h0000_1000 : AOCPU
//  8'h0001_0000 : DSPA
//  8'h0010_0000 : DSPB
//  no others.

//FROM SC2, the APB bus provided Master ID through PUSER signals.
//there's total 8 master IDs could access DMC non-secure registers.
//we assign 1 control bit for each APB Master and each DMC non-secure register domains
//and we added one lock bits to lock this setting can't be modified any more.
#define DDR_APB_SEC_CTRL0                          0x0510
   // APB access  control for dmc REQUEST control register access control register.
   // default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL1                          0x0511
   // APB access control for DMC DRAM timing parameter and DFI interface registers.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL2                          0x0512
   // APB access control for DMC PLL clock frequency control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL3                          0x0513
   // APB access control for DMC sticky control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL4                          0x0514
   // APB access control for DMC test control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL5                          0x0515
   // APB access control for DMC clk reset control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL6                          0x0516
   // APB access control for DMC protection register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL7                          0x0517
   // APB access control for DMC normal register.
   //default : 0x0ff
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL8                          0x0518
   // APB access control for DDR PHY group 0 registers.
   //default : 0x005
   //bit 23:16. PHY PRODUCTION control register enable.
   //bit 10  PHY IMEM control 1: force PHY IMEM output 0. 0: normal working mode.
   //bit 9   PHY DMEM control 1: force PHY DMEM output 0. 0: normal working mode.
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.



//registers to check the security protection and watch point error information.
#define DMC_SEC_STATUS                             0x051a
 //bit 31~4. not used.
 //bit 3   1 : normal security register write violation.( APB bus WDATA not equal to the register value when APB write).  write 1 to clean this bit to 0.
 //bit 2   sec_alert.   1 DMC security register alert function triggered. can't clean. only reset DMC can clear this bit.
 //bit 1   write security violation.
 //bit 0.  read security violation.

#define DMC_VIO_ADDR0                              0x051b
  //ddr0 write secure violation address[31:0].
#define DMC_VIO_ADDR1                              0x051c
  //31:30  not used. always 0.
  //29     aw original sec check good
  //28     not used. always 0.
  //27     awtable0 selected
  //26     awtable1 selected
  //25     aw table violation
  //24     sec table hit good
  //23     ADDR VIOLATION
  //22:21  not used. always 0.
  //20:14  remapped id(AWID+AWUSER).
  //13:0   AWID.
#define DMC_VIO_ADDR2                              0x051d
  //ddr0 read secure violation address[31:0]
#define DMC_VIO_ADDR3                              0x051e
  //31:30  not used. always 0.
  //29     ar original sec check good
  //28     not used. always 0.
  //27     artable0 selected
  //26     artable1 selected
  //25     ar table violation
  //24     sec table hit good
  //23     ADDR VIOLATION
  //22:21  not used. always 0.
  //20:14  remapped id(ARID+ARUSER).
  //13:0   ARID.

//16Gbyte AXI address remap tp 4Gbyte DDR address.


#define DMC_AXI2DDR0                               0x0520
  //for AXI address 0x0_2000_0000 ~ 0x0_3fff_ffff
  //bit 31:8. not used.
  //bit 7:  pure 16bit DDR SDRAM
  //bit 6.  addr_top vio enable
  //bit 5. rank_sel.  1 : rank1.  0 : rank0.
  //bit 4  16bit in 32bit DDR SDRAM.
  //bti 3:0. temp addr[31:28]
#define DMC_AXI2DDR1                               0x0521
#define DMC_AXI2DDR2                               0x0522
#define DMC_AXI2DDR3                               0x0523
#define DMC_AXI2DDR4                               0x0524
#define DMC_AXI2DDR5                               0x0525
#define DMC_AXI2DDR6                               0x0526
#define DMC_AXI2DDR7                               0x0527
#define DMC_AXI2DDR8                               0x0528
#define DMC_AXI2DDR9                               0x0529
#define DMC_AXI2DDRA                               0x052a
#define DMC_AXI2DDRB                               0x052b
#define DMC_AXI2DDRC                               0x052c
#define DMC_AXI2DDRD                               0x052d
#define DMC_AXI2DDRE                               0x052e
#define DMC_AXI2DDRF                               0x052f



#define DMC_DDR_CTRL                               0x0540
  //bit 24:22   3'b000 : ddr3 mode.
              //3'b001 : ddr4 mode.
              //3'b011 : lpddr4 mode.
   //bit 21.   rank1 enable bit. if 1,  rank1 used the address map is as bit 5:3 defined.
   //bit 20    DDR4 BG1 enable bit.
   //bit 18:   ddrphy_16b, DDR PHY DDR SDRAM data bits width.  1: 16bits. 0 : 32 bits.
   //bit 16.   ddr_16b,   1: only use 16bits data in a 32bits DDR PHY data interface. 0 : normal data interface.
   //bit 11:9:  strip pos
   //bit 8: channel 1 enable,ALWAYS 0
  //bit 7:4 :  ddr1_size.  DDR rank1 size control.
     //4'b0000 : DDR rank 1 is 128Mbyte.
     //4'b0001 : DDR rank 1 is 256Mbyte.
     //4'b0010 : DDR rank 1 is 512Mbyte.
     //4'b0011 : DDR rank 1 is 1Gbyte.
     //4'b0100 : DDR rank 1 is 2Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 384Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.
  //bit 3:0  :  ddr0_size. DDR rank0 size control.
     //4'b0000 : DDR rank 0 is 128Mbyte.
     //4'b0001 : DDR rank 0 is 256Mbyte.
     //4'b0010 : DDR rank 0 is 512Mbyte.
     //4'b0011 : DDR rank 0 is 1Gbyte.
     //4'b0100 : DDR rank 0 is 2Gbyte.
     //4'b1000 : DDR rank 0 is 192Mbyte.
     //4'b1001 : DDR rank 0 is 384Mbyte.
     //4'b1010 : DDR rank 0 is 768Mbyte.
     //4'b1011 : DDR rank 0 is 1.5Gbyte.
     //4'b1100 : DDR rank 0 is 3Gbyte.
     //others :  reserved.

#define DMC_DDR_CTRL1                              0x0541
  //bit 8.  dmc_ba_hash_en,  1: enable bank[2:0] more disorder
  //bit 7.  dmc_fake_chan_en, in DDR3/DDR4 case, enable this feature to reuse some write read buffer for DFI1 channel in LPDDR4 mode.
  //bit 6.  strict security level control for DMA channel. 1: only sec level input == region sec level is allowed.  0:  sec_level input >= region sec level is allow to write.


#define DMC_RANK0_ADDRMAP_0                        0x0542
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.
#define DMC_RANK0_ADDRMAP_1                        0x0543
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.
#define DMC_RANK0_ADDRMAP_2                        0x0544
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.
#define DMC_RANK0_ADDRMAP_3                        0x0545
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.
#define DMC_RANK0_ADDRMAP_4                        0x0546
  //29:25 ra16
  //24:20 bg1
  //19:15 ba2.
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.
#define DMC_RANK1_ADDRMAP_0                        0x0548
#define DMC_RANK1_ADDRMAP_1                        0x0549
#define DMC_RANK1_ADDRMAP_2                        0x054a
#define DMC_RANK1_ADDRMAP_3                        0x054b
#define DMC_RANK1_ADDRMAP_4                        0x054c




//DMC TEST.

#define DMC_TEST_STA                               0x0650
  //test start address.  for non-sha mode,  the last 5 bits would be ignored. the test address at 32bytes boundary.
  //                     for sha mode,      address must be in 64 bytes boundary. that mean the last 6 bits must be 0.

#define DMC_TEST_EDA                               0x0651
  //test end address.  for non-sha mode,  the last 5 bits would be ignored. the test address at 32bytes boundary.
  //                   for sha mode,       address must be in 64 bytes boundary. that mean the last 6bits must be 1.
#define DMC_TEST_CTRL                              0x0652
   //bit 31.  enable test.
   //bit 30.  when enable test, enable the write to DDR function.
   //bit 29.  when enable test, enable the read from DDR function.
   //bit 28.  when enable test,  enable the sha calculation function  must be same as read enable but without write function.
   //bit 27.  enabe to compare data.  when do the read enable to enable the error comparison. suppose the read data should be same as the data in the write buffer.
   //bit 26.  0: save sha result to test_sha_message registers.  1 : don't save.
   //bit 25.  address generation type.  0: continuous increase the address in the range of test start address and test end address.
   //                                   1: test module would pick the random address from test start address  and test end address.
   //bit 24.  done type.      0 : use the DMC_TEST_NUM register as the counter of test numbers.
   //                             for write if the write command number == the DMC_TEST_NUM, the write is done.
   //                             for read if the read command number == the DMC TEST_num, the read id done. for one read command can be repeated repeat number times.
   //                         1 : finshed at end address.
   //bit 23.  wdata type.     1 : the first write is {WD3, WD2,WD1,WD0}, then the latter is the previous data plus a pattern.( { + WD7,  + WD6, + WD5, + WD4}).
   //                         0 : the WDATA is the data in write register.
   //bit 23.  1  compare the sha result with the test sha message registers. 0 : dont compare the result.
   //bit 22:20.   read repeat times.  for non-sha function, we can define multi times of the read. the test module would repeat the same adddress repeat times.
   //bit 19.     limit write.  0: no outstanding write request limitation.
   //                          1: limit the outstanding write commands to the number of bits [15:8]
   //bit 18.     limit read.   0. no outstanding read request limitation.
   //                          1. limit the read outstanding request to the number of bits[7:0].
   //bit 17:16.  sha mode for sha function enabled.  00 : not used.  01 : sha1. 2: sha2-256. 3: sha2_224. not used in GXL fixed to be  Sha 2.
   //bit 15:8.   write outstanding commands limit.
   //bit 7:0.    read  outstanding commands limit.

#define DMC_TEST_NUM                               0x0653
   // how many test command for the test if the DMC_TEST_CTRL bit 24 is 0.

#define DMC_TEST_WDG                               0x0654
  //31:16.  write response watch dog.
  //15:0.   read response  watch dog.

#define DMC_TEST_COMP_MASK                         0x0655
  //32bits for DMC TEST COMPARE bit enable.
  //1 : to MASK this bit.  0: compare this bit.

#define DMC_TEST_WSTRB0                            0x0656
  //MPC WR FIFO command DM bit write data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.

#define DMC_TEST_WSTRB1                            0x0657
  //MPC WR FIFO command DM bit write data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.


#define DMC_TEST_WD0                               0x0660
   // write data 0 for write command. also for read back data comparison.
#define DMC_TEST_WD1                               0x0661
   // write data 1 for write command. also for read back data comparison.
#define DMC_TEST_WD2                               0x0662
#define DMC_TEST_WD3                               0x0663
#define DMC_TEST_WD4                               0x0664
#define DMC_TEST_WD5                               0x0665
#define DMC_TEST_WD6                               0x0666
#define DMC_TEST_WD7                               0x0667
#define DMC_TEST_WD8                               0x0668
#define DMC_TEST_WD9                               0x0669
#define DMC_TEST_WD10                              0x066a
#define DMC_TEST_WD11                              0x066b
#define DMC_TEST_WD12                              0x066c
#define DMC_TEST_WD13                              0x066d
#define DMC_TEST_WD14                              0x066e
#define DMC_TEST_WD15                              0x066f
   // write data 15 for write command. also for read back data comparison.


#define DMC_TEST_RD0                               0x0630
   // the read back data 0.  if error happens, it would capture the first error data.
#define DMC_TEST_RD1                               0x0631
   // the read back data 1.  if error happens, it would capture the first error data.
#define DMC_TEST_RD2                               0x0632
   // the read back data 2.  if error happens, it would capture the first error data.
#define DMC_TEST_RD3                               0x0633
   // the read back data 3.  if error happens, it would capture the first error data.
#define DMC_TEST_RD4                               0x0634
   // the read back data 4.  if error happens, it would capture the first error data.
#define DMC_TEST_RD5                               0x0635
   // the read back data 5.  if error happens, it would capture the first error data.
#define DMC_TEST_RD6                               0x0636
   // the read back data 6.  if error happens, it would capture the first error data.
#define DMC_TEST_RD7                               0x0637
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD8                               0x0638
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD9                               0x0639
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD10                              0x063a
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD11                              0x063b
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD12                              0x063c
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD13                              0x063d
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD14                              0x063e
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD15                              0x063f
   // the read back data 7.  if error happens, it would capture the first error data.



#define DMC_TEST_ERR_ADDR                          0x0640
  //read only. it capture the first error address.
#define DMC_TEST_ERR_CNT                           0x0641
  //read only. how many data error happens in the whole test period.
#define DMC_TEST_STS                               0x0642
  //read only.
  //bit 31,   test done bit. write 1 to clean.
  //bit 30,   indicate address err
  //bit 29~7.  not used.
  //bit 6.    read data resp error(caused by security or rd latency).
  //bit 5.    test MRR/MPR rd latency error. write 1 clear
  //bit 4,    sha done.     write 1 to clean.
  //bit 3,    write done.   write 1 to clean.
  //bit 2,    read done.    write 1 to clean
  //bit 1,    write watchdog triggered.   write 1 to clean
  //bit 0,    read watchdog triggered.    write 1 to clean.

#define DMC_TEST_WRCMD_ADDR                        0x0643
  //read only. the current write cmd address.
#define DMC_TEST_RDCMD_ADDR                        0x0644
   //read only. the current read command address.
#define DMC_TEST_RDRSP_ADDR                        0x0645
  //read only. the failed read response address(for error data )




//##############################################
//secure_tbl read/write part reg
#define DMC_SEC_TBL_REG0                           0x0680
#define DMC_SEC_TBL_REG1                           0x0681
#define DMC_SEC_TBL_REG2                           0x0682
#define DMC_SEC_TBL_REG3                           0x0683
#define DMC_SEC_TBL_REG4                           0x0684
#define DMC_SEC_TBL_REG5                           0x0685
#define DMC_SEC_TBL_REG6                           0x0686
#define DMC_SEC_TBL_REG7                           0x0687
#define DMC_SEC_TBL_REG8                           0x0688
#define DMC_SEC_TBL_REG9                           0x0689
#define DMC_SEC_TBL_REG10                          0x068a
#define DMC_SEC_TBL_REG11                          0x068b
#define DMC_SEC_TBL_REG12                          0x068c
#define DMC_SEC_TBL_REG13                          0x068d
#define DMC_SEC_TBL_REG14                          0x068e
#define DMC_SEC_TBL_REG15                          0x068f
#define DMC_SEC_TBL_REG16                          0x0690
#define DMC_SEC_TBL_REG17                          0x0691
#define DMC_SEC_TBL_REG18                          0x0692
#define DMC_SEC_TBL_REG19                          0x0693
#define DMC_SEC_TBL_REG20                          0x0694
#define DMC_SEC_TBL_REG21                          0x0695
#define DMC_SEC_TBL_REG22                          0x0696
#define DMC_SEC_TBL_REG23                          0x0697
#define DMC_SEC_TBL_REG24                          0x0698
#define DMC_SEC_TBL_REG25                          0x0699
#define DMC_SEC_TBL_REG26                          0x069a
#define DMC_SEC_TBL_REG27                          0x069b
#define DMC_SEC_TBL_REG28                          0x069c
#define DMC_SEC_TBL_REG29                          0x069d
#define DMC_SEC_TBL_REG30                          0x069e
#define DMC_SEC_TBL_REG31                          0x069f

#define DMC_SEC_TBL_REG_CFG                        0x06a0
  //bit 31:12. not used.
  //bit 11:8.  each 32 reg offset. real reg addr = 32*offset+11'h680, 16*32=512.
  //bit 7:1.   not used.
  //bit 0.     apb reg point to read or write sec_tbl ram, 0:read ram; 1:write ram.

//
//
////region16(RANGE10) related register.
#define DMC_SEC_RANGE16_STA                        0x0700
//  //bit 31:20. not used.
//  //bit 19:0.   region start address AXI address [31:12] unit 4Kbyte.
#define DMC_SEC_RANGE16_EDA                        0x0701
//  //bit 31:20. not used.
//  //bit 19:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE16_CTRL                       0x0702
//  //bit 7:5.range0_security_level
//  //bit 4.  range0_prot_en. range 0 protect monitor function control
//  //bit 3.  range0_des_en. range 0 data scrambling enable
//  //bit 2.  range0 lock.
//  //bit 1.  range0 key select
//  //bit 0.  range0 enable
#define DMC_SEC_RANGE16_RID_CTRL0                  0x0703
//  //range_rd_sid_en[31:0];
#define DMC_SEC_RANGE16_RID_CTRL1                  0x0704
//  //range_rd_sid_en[63:32];
#define DMC_SEC_RANGE16_RID_CTRL2                  0x0705
//  //range_rd_sid_en[95:64];
#define DMC_SEC_RANGE16_RID_CTRL3                  0x0706
//  //range_rd_sid_en[127:96];
#define DMC_SEC_RANGE16_RID_CTRL4                  0x0707
//  //range_rd_sid_en[159:128];
#define DMC_SEC_RANGE16_WID_CTRL0                  0x0708
//  //range_wr_sid_en[31:0];
#define DMC_SEC_RANGE16_WID_CTRL1                  0x0709
//  //range_wr_sid_en[63:32];
#define DMC_SEC_RANGE16_WID_CTRL2                  0x070a
//  //range_wr_sid_en[95:64];
#define DMC_SEC_RANGE16_WID_CTRL3                  0x070b
//  //range_wr_sid_en[127:96];
#define DMC_SEC_RANGE16_WID_CTRL4                  0x070c
//  //range_wr_sid_en[159:128];
//
//
////region17(RANGE11) related register.
#define DMC_SEC_RANGE17_STA                        0x0710
#define DMC_SEC_RANGE17_EDA                        0x0711
#define DMC_SEC_RANGE17_CTRL                       0x0712
#define DMC_SEC_RANGE17_RID_CTRL0                  0x0713
#define DMC_SEC_RANGE17_RID_CTRL1                  0x0714
#define DMC_SEC_RANGE17_RID_CTRL2                  0x0715
#define DMC_SEC_RANGE17_RID_CTRL3                  0x0716
#define DMC_SEC_RANGE17_RID_CTRL4                  0x0717
#define DMC_SEC_RANGE17_WID_CTRL0                  0x0718
#define DMC_SEC_RANGE17_WID_CTRL1                  0x0719
#define DMC_SEC_RANGE17_WID_CTRL2                  0x071a
#define DMC_SEC_RANGE17_WID_CTRL3                  0x071b
#define DMC_SEC_RANGE17_WID_CTRL4                  0x071c
//
////region18(RANGE12) related register.
#define DMC_SEC_RANGE18_STA                        0x0720
#define DMC_SEC_RANGE18_EDA                        0x0721
#define DMC_SEC_RANGE18_CTRL                       0x0722
#define DMC_SEC_RANGE18_RID_CTRL0                  0x0723
#define DMC_SEC_RANGE18_RID_CTRL1                  0x0724
#define DMC_SEC_RANGE18_RID_CTRL2                  0x0725
#define DMC_SEC_RANGE18_RID_CTRL3                  0x0726
#define DMC_SEC_RANGE18_RID_CTRL4                  0x0727
#define DMC_SEC_RANGE18_WID_CTRL0                  0x0728
#define DMC_SEC_RANGE18_WID_CTRL1                  0x0729
#define DMC_SEC_RANGE18_WID_CTRL2                  0x072a
#define DMC_SEC_RANGE18_WID_CTRL3                  0x072b
#define DMC_SEC_RANGE18_WID_CTRL4                  0x072c
//
////region19(RANGE13) related register.
#define DMC_SEC_RANGE19_STA                        0x0730
#define DMC_SEC_RANGE19_EDA                        0x0731
#define DMC_SEC_RANGE19_CTRL                       0x0732
#define DMC_SEC_RANGE19_RID_CTRL0                  0x0733
#define DMC_SEC_RANGE19_RID_CTRL1                  0x0734
#define DMC_SEC_RANGE19_RID_CTRL2                  0x0735
#define DMC_SEC_RANGE19_RID_CTRL3                  0x0736
#define DMC_SEC_RANGE19_RID_CTRL4                  0x0737
#define DMC_SEC_RANGE19_WID_CTRL0                  0x0738
#define DMC_SEC_RANGE19_WID_CTRL1                  0x0739
#define DMC_SEC_RANGE19_WID_CTRL2                  0x073a
#define DMC_SEC_RANGE19_WID_CTRL3                  0x073b
#define DMC_SEC_RANGE19_WID_CTRL4                  0x073c
//
////region20(RANGE14) related register.
#define DMC_SEC_RANGE20_STA                        0x0740
#define DMC_SEC_RANGE20_EDA                        0x0741
#define DMC_SEC_RANGE20_CTRL                       0x0742
#define DMC_SEC_RANGE20_RID_CTRL0                  0x0743
#define DMC_SEC_RANGE20_RID_CTRL1                  0x0744
#define DMC_SEC_RANGE20_RID_CTRL2                  0x0745
#define DMC_SEC_RANGE20_RID_CTRL3                  0x0746
#define DMC_SEC_RANGE20_RID_CTRL4                  0x0747
#define DMC_SEC_RANGE20_WID_CTRL0                  0x0748
#define DMC_SEC_RANGE20_WID_CTRL1                  0x0749
#define DMC_SEC_RANGE20_WID_CTRL2                  0x074a
#define DMC_SEC_RANGE20_WID_CTRL3                  0x074b
#define DMC_SEC_RANGE20_WID_CTRL4                  0x074c
//
////region21(RANGE15) related register.
#define DMC_SEC_RANGE21_STA                        0x0750
#define DMC_SEC_RANGE21_EDA                        0x0751
#define DMC_SEC_RANGE21_CTRL                       0x0752
#define DMC_SEC_RANGE21_RID_CTRL0                  0x0753
#define DMC_SEC_RANGE21_RID_CTRL1                  0x0754
#define DMC_SEC_RANGE21_RID_CTRL2                  0x0755
#define DMC_SEC_RANGE21_RID_CTRL3                  0x0756
#define DMC_SEC_RANGE21_RID_CTRL4                  0x0757
#define DMC_SEC_RANGE21_WID_CTRL0                  0x0758
#define DMC_SEC_RANGE21_WID_CTRL1                  0x0759
#define DMC_SEC_RANGE21_WID_CTRL2                  0x075a
#define DMC_SEC_RANGE21_WID_CTRL3                  0x075b
#define DMC_SEC_RANGE21_WID_CTRL4                  0x075c
//
////region22(RANGE16) related register.
#define DMC_SEC_RANGE22_STA                        0x0760
#define DMC_SEC_RANGE22_EDA                        0x0761
#define DMC_SEC_RANGE22_CTRL                       0x0762
#define DMC_SEC_RANGE22_RID_CTRL0                  0x0763
#define DMC_SEC_RANGE22_RID_CTRL1                  0x0764
#define DMC_SEC_RANGE22_RID_CTRL2                  0x0765
#define DMC_SEC_RANGE22_RID_CTRL3                  0x0766
#define DMC_SEC_RANGE22_RID_CTRL4                  0x0767
#define DMC_SEC_RANGE22_WID_CTRL0                  0x0768
#define DMC_SEC_RANGE22_WID_CTRL1                  0x0769
#define DMC_SEC_RANGE22_WID_CTRL2                  0x076a
#define DMC_SEC_RANGE22_WID_CTRL3                  0x076b
#define DMC_SEC_RANGE22_WID_CTRL4                  0x076c
//
////region23(RANGE17) related register.
#define DMC_SEC_RANGE23_STA                        0x0770
#define DMC_SEC_RANGE23_EDA                        0x0771
#define DMC_SEC_RANGE23_CTRL                       0x0772
#define DMC_SEC_RANGE23_RID_CTRL0                  0x0773
#define DMC_SEC_RANGE23_RID_CTRL1                  0x0774
#define DMC_SEC_RANGE23_RID_CTRL2                  0x0775
#define DMC_SEC_RANGE23_RID_CTRL3                  0x0776
#define DMC_SEC_RANGE23_RID_CTRL4                  0x0777
#define DMC_SEC_RANGE23_WID_CTRL0                  0x0778
#define DMC_SEC_RANGE23_WID_CTRL1                  0x0779
#define DMC_SEC_RANGE23_WID_CTRL2                  0x077a
#define DMC_SEC_RANGE23_WID_CTRL3                  0x077b
#define DMC_SEC_RANGE23_WID_CTRL4                  0x077c
//
////region24(RANGE18) related register.
#define DMC_SEC_RANGE24_STA                        0x0780
#define DMC_SEC_RANGE24_EDA                        0x0781
#define DMC_SEC_RANGE24_CTRL                       0x0782
#define DMC_SEC_RANGE24_RID_CTRL0                  0x0783
#define DMC_SEC_RANGE24_RID_CTRL1                  0x0784
#define DMC_SEC_RANGE24_RID_CTRL2                  0x0785
#define DMC_SEC_RANGE24_RID_CTRL3                  0x0786
#define DMC_SEC_RANGE24_RID_CTRL4                  0x0787
#define DMC_SEC_RANGE24_WID_CTRL0                  0x0788
#define DMC_SEC_RANGE24_WID_CTRL1                  0x0789
#define DMC_SEC_RANGE24_WID_CTRL2                  0x078a
#define DMC_SEC_RANGE24_WID_CTRL3                  0x078b
#define DMC_SEC_RANGE24_WID_CTRL4                  0x078c
//
////region25(RANGE19) related register.
#define DMC_SEC_RANGE25_STA                        0x0790
#define DMC_SEC_RANGE25_EDA                        0x0791
#define DMC_SEC_RANGE25_CTRL                       0x0792
#define DMC_SEC_RANGE25_RID_CTRL0                  0x0793
#define DMC_SEC_RANGE25_RID_CTRL1                  0x0794
#define DMC_SEC_RANGE25_RID_CTRL2                  0x0795
#define DMC_SEC_RANGE25_RID_CTRL3                  0x0796
#define DMC_SEC_RANGE25_RID_CTRL4                  0x0797
#define DMC_SEC_RANGE25_WID_CTRL0                  0x0798
#define DMC_SEC_RANGE25_WID_CTRL1                  0x0799
#define DMC_SEC_RANGE25_WID_CTRL2                  0x079a
#define DMC_SEC_RANGE25_WID_CTRL3                  0x079b
#define DMC_SEC_RANGE25_WID_CTRL4                  0x079c
//
////region26(RANGE1a) related register.
#define DMC_SEC_RANGE26_STA                        0x07a0
#define DMC_SEC_RANGE26_EDA                        0x07a1
#define DMC_SEC_RANGE26_CTRL                       0x07a2
#define DMC_SEC_RANGE26_RID_CTRL0                  0x07a3
#define DMC_SEC_RANGE26_RID_CTRL1                  0x07a4
#define DMC_SEC_RANGE26_RID_CTRL2                  0x07a5
#define DMC_SEC_RANGE26_RID_CTRL3                  0x07a6
#define DMC_SEC_RANGE26_RID_CTRL4                  0x07a7
#define DMC_SEC_RANGE26_WID_CTRL0                  0x07a8
#define DMC_SEC_RANGE26_WID_CTRL1                  0x07a9
#define DMC_SEC_RANGE26_WID_CTRL2                  0x07aa
#define DMC_SEC_RANGE26_WID_CTRL3                  0x07ab
#define DMC_SEC_RANGE26_WID_CTRL4                  0x07ac
//
////region27(RANGE1b) related register.
#define DMC_SEC_RANGE27_STA                        0x07b0
#define DMC_SEC_RANGE27_EDA                        0x07b1
#define DMC_SEC_RANGE27_CTRL                       0x07b2
#define DMC_SEC_RANGE27_RID_CTRL0                  0x07b3
#define DMC_SEC_RANGE27_RID_CTRL1                  0x07b4
#define DMC_SEC_RANGE27_RID_CTRL2                  0x07b5
#define DMC_SEC_RANGE27_RID_CTRL3                  0x07b6
#define DMC_SEC_RANGE27_RID_CTRL4                  0x07b7
#define DMC_SEC_RANGE27_WID_CTRL0                  0x07b8
#define DMC_SEC_RANGE27_WID_CTRL1                  0x07b9
#define DMC_SEC_RANGE27_WID_CTRL2                  0x07ba
#define DMC_SEC_RANGE27_WID_CTRL3                  0x07bb
#define DMC_SEC_RANGE27_WID_CTRL4                  0x07bc
//
////region28(RANGE1c) related register.
#define DMC_SEC_RANGE28_STA                        0x07c0
#define DMC_SEC_RANGE28_EDA                        0x07c1
#define DMC_SEC_RANGE28_CTRL                       0x07c2
#define DMC_SEC_RANGE28_RID_CTRL0                  0x07c3
#define DMC_SEC_RANGE28_RID_CTRL1                  0x07c4
#define DMC_SEC_RANGE28_RID_CTRL2                  0x07c5
#define DMC_SEC_RANGE28_RID_CTRL3                  0x07c6
#define DMC_SEC_RANGE28_RID_CTRL4                  0x07c7
#define DMC_SEC_RANGE28_WID_CTRL0                  0x07c8
#define DMC_SEC_RANGE28_WID_CTRL1                  0x07c9
#define DMC_SEC_RANGE28_WID_CTRL2                  0x07ca
#define DMC_SEC_RANGE28_WID_CTRL3                  0x07cb
#define DMC_SEC_RANGE28_WID_CTRL4                  0x07cc
//
////region29(RANGE1d) related register.
#define DMC_SEC_RANGE29_STA                        0x07d0
#define DMC_SEC_RANGE29_EDA                        0x07d1
#define DMC_SEC_RANGE29_CTRL                       0x07d2
#define DMC_SEC_RANGE29_RID_CTRL0                  0x07d3
#define DMC_SEC_RANGE29_RID_CTRL1                  0x07d4
#define DMC_SEC_RANGE29_RID_CTRL2                  0x07d5
#define DMC_SEC_RANGE29_RID_CTRL3                  0x07d6
#define DMC_SEC_RANGE29_RID_CTRL4                  0x07d7
#define DMC_SEC_RANGE29_WID_CTRL0                  0x07d8
#define DMC_SEC_RANGE29_WID_CTRL1                  0x07d9
#define DMC_SEC_RANGE29_WID_CTRL2                  0x07da
#define DMC_SEC_RANGE29_WID_CTRL3                  0x07db
#define DMC_SEC_RANGE29_WID_CTRL4                  0x07dc
//
////region30(RANGE1e) related register.
#define DMC_SEC_RANGE30_STA                        0x07e0
#define DMC_SEC_RANGE30_EDA                        0x07e1
#define DMC_SEC_RANGE30_CTRL                       0x07e2
#define DMC_SEC_RANGE30_RID_CTRL0                  0x07e3
#define DMC_SEC_RANGE30_RID_CTRL1                  0x07e4
#define DMC_SEC_RANGE30_RID_CTRL2                  0x07e5
#define DMC_SEC_RANGE30_RID_CTRL3                  0x07e6
#define DMC_SEC_RANGE30_RID_CTRL4                  0x07e7
#define DMC_SEC_RANGE30_WID_CTRL0                  0x07e8
#define DMC_SEC_RANGE30_WID_CTRL1                  0x07e9
#define DMC_SEC_RANGE30_WID_CTRL2                  0x07ea
#define DMC_SEC_RANGE30_WID_CTRL3                  0x07eb
#define DMC_SEC_RANGE30_WID_CTRL4                  0x07ec
//
////region31(RANGE1f) related register.
#define DMC_SEC_RANGE31_STA                        0x07f0
#define DMC_SEC_RANGE31_EDA                        0x07f1
#define DMC_SEC_RANGE31_CTRL                       0x07f2
#define DMC_SEC_RANGE31_RID_CTRL0                  0x07f3
#define DMC_SEC_RANGE31_RID_CTRL1                  0x07f4
#define DMC_SEC_RANGE31_RID_CTRL2                  0x07f5
#define DMC_SEC_RANGE31_RID_CTRL3                  0x07f6
#define DMC_SEC_RANGE31_RID_CTRL4                  0x07f7
#define DMC_SEC_RANGE31_WID_CTRL0                  0x07f8
#define DMC_SEC_RANGE31_WID_CTRL1                  0x07f9
#define DMC_SEC_RANGE31_WID_CTRL2                  0x07fa
#define DMC_SEC_RANGE31_WID_CTRL3                  0x07fb
#define DMC_SEC_RANGE31_WID_CTRL4                  0x07fc
//
//






//
// Closing file:  ../dmc_v26/rtl/dmc_reg.vh
//

#endif // MMC_REG_DEFINE

