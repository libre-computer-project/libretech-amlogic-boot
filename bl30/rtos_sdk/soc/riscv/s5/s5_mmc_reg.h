// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_for_mmc_register_map_h.pl
//
// and was applied to the file
//
// Project name: s5
//
// Create time: Sun Apr 17 21:54:35 CST 2022 by chong.gu
//
// ../dmc/rtl/dmc_reg.vh
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef MMC_REG_DEFINE
#else
#define MMC_REG_DEFINE

#define MMC0_Wr(addr, data)                                                                      \
	(*((volatile uint32_t *)(uintptr_t)((addr << 2) + 0xfe036000)) = (data))
#define MMC0_Rd(addr) (*(volatile uint32_t *)(uintptr_t)((addr << 2) + 0xfe036000))
#define MMC1_Wr(addr, data)                                                                      \
	(*((volatile uint32_t *)(uintptr_t)((addr << 2) + 0xfe034000)) = (data))
#define MMC1_Rd(addr) (*(volatile uint32_t *)(uintptr_t)((addr << 2) + 0xfe034000))
#ifdef ONE_DDR_SIM
#define MMC2_Wr(addr, data)
#define MMC2_Rd(addr) 0
#define MMC3_Wr(addr, data)
#define MMC3_Rd(addr) 0
#else
#define MMC2_Wr(addr, data)                                                                      \
	(*((volatile uint32_t *)(uintptr_t)((addr << 2) + 0xfe032000)) = (data))
#define MMC2_Rd(addr) (*(volatile uint32_t *)(uintptr_t)((addr << 2) + 0xfe032000))
#define MMC3_Wr(addr, data)                                                                      \
	(*((volatile uint32_t *)(uintptr_t)((addr << 2) + 0xfe030000)) = (data))
#define MMC3_Rd(addr) (*(volatile uint32_t *)(uintptr_t)((addr << 2) + 0xfe030000))
#endif

#define USE_LPDDR4_4266
#define ddrphy0_apb_wr(addr, dat) (*((volatile uint32_t *)(addr + 0xfc000000)) = (dat))
#define ddrphy0_apb_rd(addr) (*(volatile uint32_t *)(addr + 0xfc000000))

#define ddrphy1_apb_wr(addr, dat) (*((volatile uint32_t *)(addr + 0xfb000000)) = (dat))
#define ddrphy1_apb_rd(addr) (*(volatile uint32_t *)(addr + 0xfb000000))

//
// Reading file:  ../dmc/rtl/dmc_reg.vh
//

// -----------------------------------------------
// REG_BASE:  DMC_FREQ_REG_BASE = 0xfe036000
// -----------------------------------------------
//        REGISTER_BASE_ADDR  32'hfe036000

#define DMC_REQ_CTRL 0x0000
// bit 7.   enable dmc request of axibus chan 7.  NIC4 include NNA debus, dsp, aocpu, audio, dmc,
// etc. bit 6.   enable dmc request of axibus chan 6.  NIC3 include ge2d, hevc,vdec, hcodec etc.
// bit 5.   enable dmc request of axibus chan 5.  reserved for dmc_test.
// bit 4.   enable dmc request of axibus chan 4.  hevc front Async interface.
// bit 3.   enable dmc request of axibus chan 3.  HDCP/HDMI   Async interface.
// bit 2.   enable dmc request of axibus chan 2.  pcie  async
// bit 1.   enable dmc request of axibus chan 1.  Mali .  async interface.
// bit 0.   enable dmc request of axibus chan 0.  CPU/A53   async interface.

// DMC CLK and RESET domain register. please check DMC_SEC_APB_CTRLx register for access details.
#define DMC_SOFT_RST 0x0001
// bit 31~8. reserved for future.
// bit 7:0. 8 software reset for 8 axi ports

#define DMC_SOFT_RST1 0x0002
// To reset the Async interface, you need to disable the interface both clock domain, then reset
// both n_clk and m_clk domain bit 31~0 not used.  all channels are synchronous interface.

#define DMC_SOFT_RST2 0x0003
// bit 31~11.  reserved for future.
// bit 10  DMC DFI cmd soft reset_n
// bit 9   DMC DFI MISC soft reset_n
// bit 8   DMC DFI data soft reset_n
// bit 7   DMC DFI dcu soft reset_n
// bit 6   DMC siu soft reset_n
// bit 5.  DMC test soft reset_n.  0 : reset. 1 : normal working mode.
// bit 4.  DMC low power control moudle soft reset_n.    0 : reset. 1 : normal working mode.
// bit 3.  DMC QOS monitor module soft reset_n.   0 : reset. 1 : normal working mode.
// bit 2.  DMC register modle soft reset_n.       0 : reset. 1 : normal working mode.
// bit 1.  not used.
// bit 0.  DMC command buffers and command generation modules soft reset.  0 = reset. 1:

#define DMC_RST_STS1 0x0004
// 31~24.  not used.
// 3~0.   Read only.  the DMC_SOFT_RST1 signal in n_clk domain. the purpose of this register is
// when one of the 2 clocks is too slow or too fast,  we can read this register to make sure
// another clock domain reset is done.
#define DMC_CLKG_CTRL0 0x0006
// bit 31:8  not used.
// bit 7:0.  enable the 8 axi interfaces  n_clk auto clock gating function. each 1 bit for one
// interface.
#define DMC_CLKG_CTRL1 0x0007
// bit 31:8. not used.
// bit 7:0.  force to disable the 16 axi interfaces n_clk. each 1 bit for one interface.

#define DMC_CLKG_CTRL2 0x0008
// bit 12  enalbe auto clock gating for awcmdfifo.
// bit 11  enalbe auto clock gating for arcmdfifo.
// bit 10  enable auto clock gating for dfi command generation
// bit 9   enable auto clock gating for dram cntroller
// bit 8   enable auto clock gating for dfi data path.
// bit 7.  enalbe auto clock gating for write rsp generation.
// bit 6.  enalbe auto clock gating for read rsp generation.
// bit 5.  enalbe auto clock gating for ddr0 command filter.
// bit 4.  enalbe auto clock gating for ddr0 write reorder buffer.
// bit 3.  enalbe auto clock gating for ddr0 write data buffer.
// bit 2.  enalbe auto clock gating for ddr0 read reorder buffer.
// bit 1:0.  not used.

#define DMC_CLKG_CTRL3 0x0009
// bit 12  force to disable the clock of awcmdfifo.
// bit 11  force to disable the clock of arcmdfifo.
// bit 10  force to disable the clock of dfi command generation
// bit 9   force to disable the clock of dram cntroller
// bit 8   force to disable the clock of dfi data path.
// bit 7. force to disalbe the clock of write rsp generation.
// bit 6. force to disalbe the clock of read rsp generation.
// bit 5.  force to disalbe the clock of  command filter.
// bit 4.  force to disalbe the clock of  write reorder buffer.
// bit 3.  force to disalbe the clock of write data buffer.
// bit 2.  force to disalbe the clock of read reorder buffer.
// bit 1:0. not used.

#define DMC_MON_CTRL0 0x0010
// bit 31.   qos_mon_en.    write 1 to trigger the enable. polling this bit 0, means finished.  or
// use interrupt to check finish. bit 30.   qos_mon interrupt clear.  clear the qos monitor result.
// read 1 = qos mon finish interrupt.
#define DMC_MON_TIMER 0x0011
// timer for the monitor period.
#define DMC_MON_ALL_IDLE_CNT 0x0012
// at the test period,  the whole MMC all channel IDLE time. unit, dmc clock.
#define DMC_MON_ALL_BW 0x0013
// at the test period,  the whole MMC granted data cycles. units one data clock cycle = 16bytes.
#define DMC_MON_ALL16_BW 0x0014
// at the test period,  the whole MMC granted data cycles which goes to 16bits ddr. units one data
// clock cycle = 16byte.
#define DMC_MON0_CTRL1 0x0018
// bit 31:15 not used.
// bit 14. mon0 id2 subid 2 enable.
// bit 13. mon0 id1 subid 1 enable.
// bit 12. mon0 id0 subid 0 enable.
// bit 11:8. mon0 subid 2 number.
// bit 7:4.  mon0 subid 1 number.
// bit 3:0.  mon0 subid 0 number.
#define DMC_MON1_CTRL1 0x0019
// bit 31:15 not used.
// bit 14. mon1 id2 subid 2 enable.
// bit 13. mon1 id1 subid 1 enable.
// bit 12. mon1 id0 subid 0 enable.
// bit 11:8. mon1 subid 2 number.
// bit 7:4.  mon1 subid 1 number.
// bit 3:0.  mon1 subid 0 number.
#define DMC_MON2_CTRL1 0x001a
// bit 31:15 not used.
// bit 14. mon2 id2 subid 2 enable.
// bit 13. mon2 id1 subid 1 enable.
// bit 12. mon2 id0 subid 0 enable.
// bit 11:8. mon2 subid 2 number.
// bit 7:4.  mon2 subid 1 number.
// bit 3:0.  mon2 subid 0 number.
#define DMC_MON3_CTRL1 0x001b
// bit 31:15 not used.
// bit 14. mon3 id2 subid 2 enable.
// bit 13. mon3 id1 subid 1 enable.
// bit 12. mon3 id0 subid 0 enable.
// bit 11:8. mon3 subid 2 number.
// bit 7:4.  mon3 subid 1 number.
// bit 3:0.  mon3 subid 0 number.
#define DMC_MON4_CTRL1 0x001c
// bit 31:15 not used.
// bit 14. mon4 id2 subid 2 enable.
// bit 13. mon4 id1 subid 1 enable.
// bit 12. mon4 id0 subid 0 enable.
// bit 11:8. mon4 subid 2 number.
// bit 7:4.  mon4 subid 1 number.
// bit 3:0.  mon4 subid 0 number.
#define DMC_MON5_CTRL1 0x001d
// bit 31:15 not used.
// bit 14. mon5 id2 subid 2 enable.
// bit 13. mon5 id1 subid 1 enable.
// bit 12. mon5 id0 subid 0 enable.
// bit 11:8. mon5 subid 2 number.
// bit 7:4.  mon5 subid 1 number.
// bit 3:0.  mon5 subid 0 number.
#define DMC_MON6_CTRL1 0x001e
// bit 31:15 not used.
// bit 14. mon6 id2 subid 2 enable.
// bit 13. mon6 id1 subid 1 enable.
// bit 12. mon6 id0 subid 0 enable.
// bit 11:8. mon6 subid 2 number.
// bit 7:4.  mon6 subid 1 number.
// bit 3:0.  mon6 subid 0 number.
#define DMC_MON7_CTRL1 0x001f
// bit 31:15 not used.
// bit 14. mon7 id2 subid 2 enable.
// bit 13. mon7 id1 subid 1 enable.
// bit 12. mon7 id0 subid 0 enable.
// bit 11:8. mon7 subid 2 number.
// bit 7:4.  mon7 subid 1 number.
// bit 3:0.  mon7 subid 0 number.

// each monitor can check upto 3 master IDs.
#define DMC_MON0_STA 0x0020
// bit 31:20. not used.
// bit 19:0  MON0 start address unit 4Kbyte.
#define DMC_MON0_EDA 0x0021
// bit 31:20. Not used.
// bit 19:0  MON0 end address unit 4Kbyte.
#define DMC_MON0_CTRL 0x0022
// bit 31  bandwidth monitor 0 enable.
// bit 30. check write bandwidth  1 : check. 0 not check.
// bit 29. check read bandwidth  1 : check. 0 : not check.
// bit 28:27. not used.
// bit 26. id_num2 enable.
// bit 25. id_num1 enable.
// bit 24. id_num0 enable.
// bit 23:16. master ID number 2.
// bit 15:8.  master ID number 1.
// bit 7:0.   master ID number 0.
#define DMC_MON0_BW 0x0023
// monitor bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON1_STA 0x0024
// bit 31:20. not used.
// bit 19:0  MON0 start address unit 4Kbyte.
#define DMC_MON1_EDA 0x0025
// bit 31:20. Not used.
// bit 19:0  MON0 end address unit 4Kbyte.
#define DMC_MON1_CTRL 0x0026
// bit 31  bandwidth monitor 0 enable.
// bit 30. check write bandwidth  1 : check. 0 not check.
// bit 29. check read bandwidth  1 : check. 0 : not check.
// bit 28:27. not used.
// bit 26. id_num2 enable.
// bit 25. id_num1 enable.
// bit 24. id_num0 enable.
// bit 23:16. master ID number 2.
// bit 15:8.  master ID number 1.
// bit 7:0.   master ID number 0.
#define DMC_MON1_BW 0x0027
// monitor 1 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON2_STA 0x0028
// bit 31:20. not used.
// bit 19:0  MON0 start address unit 4Kbyte.
#define DMC_MON2_EDA 0x0029
// bit 31:20. Not used.
// bit 19:0  MON2 end address unit 4Kbyte.
#define DMC_MON2_CTRL 0x002a
// bit 31  bandwidth monitor 2 enable.
// bit 30. check write bandwidth  1 : check. 0 not check.
// bit 29. check read bandwidth  1 : check. 0 : not check.
// bit 28:27. not used.
// bit 26. id_num2 enable.
// bit 25. id_num1 enable.
// bit 24. id_num0 enable.
// bit 23:16. master ID number 2.
// bit 15:8.  master ID number 1.
// bit 7:0.   master ID number 0.
#define DMC_MON2_BW 0x002b
// monitor 2 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON3_STA 0x002c
// bit 31:20. not used.
// bit 19:0  MON3 start address unit 4Kbyte.
#define DMC_MON3_EDA 0x002d
// bit 31:20. Not used.
// bit 19:0  MON3 end address unit 4Kbyte.
#define DMC_MON3_CTRL 0x002e
// bit 31  bandwidth monitor 3 enable.
// bit 30. check write bandwidth  1 : check. 0 not check.
// bit 29. check read bandwidth  1 : check. 0 : not check.
// bit 28:27. not used.
// bit 26. id_num2 enable.
// bit 25. id_num1 enable.
// bit 24. id_num0 enable.
// bit 23:16. master ID number 2.
// bit 15:8.  master ID number 1.
// bit 7:0.   master ID number 0.
#define DMC_MON3_BW 0x002f
// monitor 3 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON4_STA 0x0030
// bit 31:20. not used.
// bit 19:0  MON4 start address unit 4Kbyte.
#define DMC_MON4_EDA 0x0031
// bit 31:20. Not used.
// bit 19:0  MON4 end address unit 4Kbyte.
#define DMC_MON4_CTRL 0x0032
// bit 31  bandwidth monitor 4 enable.
// bit 30. check write bandwidth  1 : check. 0 not check.
// bit 29. check read bandwidth  1 : check. 0 : not check.
// bit 28:27. not used.
// bit 26. id_num2 enable.
// bit 25. id_num1 enable.
// bit 24. id_num0 enable.
// bit 23:16. master ID number 2.
// bit 15:8.  master ID number 1.
// bit 7:0.   master ID number 0.
#define DMC_MON4_BW 0x0033
// monitor 4 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON5_STA 0x0034
// bit 31:20. not used.
// bit 19:0  MON5 start address unit 4Kbyte.
#define DMC_MON5_EDA 0x0035
// bit 31:20. Not used.
// bit 19:0  MON4 end address unit 4Kbyte.
#define DMC_MON5_CTRL 0x0036
// bit 31  bandwidth monitor 5 enable.
// bit 30. check write bandwidth  1 : check. 0 not check.
// bit 29. check read bandwidth  1 : check. 0 : not check.
// bit 28:27. not used.
// bit 26. id_num2 enable.
// bit 25. id_num1 enable.
// bit 24. id_num0 enable.
// bit 23:16. master ID number 2.
// bit 15:8.  master ID number 1.
// bit 7:0.   master ID number 0.
#define DMC_MON5_BW 0x0037
// monitor 5 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON6_STA 0x0038
// bit 31:20. not used.
// bit 19:0  MON6 start address unit 4Kbyte.
#define DMC_MON6_EDA 0x0039
// bit 31:20. Not used.
// bit 19:0  MON6 end address unit 4Kbyte.
#define DMC_MON6_CTRL 0x003a
// bit 31  bandwidth monitor 6 enable.
// bit 30. check write bandwidth  1 : check. 0 not check.
// bit 29. check read bandwidth  1 : check. 0 : not check.
// bit 28:27. not used.
// bit 26. id_num2 enable.
// bit 25. id_num1 enable.
// bit 24. id_num0 enable.
// bit 23:16. master ID number 2.
// bit 15:8.  master ID number 1.
// bit 7:0.   master ID number 0.
#define DMC_MON6_BW 0x003b
// monitor 6 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define DMC_MON7_STA 0x003c
// bit 31:20. not used.
// bit 19:0  MON7 start address unit 4Kbyte.
#define DMC_MON7_EDA 0x003d
// bit 31:20. Not used.
// bit 19:0  MON7 end address unit 4Kbyte.
#define DMC_MON7_CTRL 0x003e
// bit 31  bandwidth monitor 7 enable.
// bit 30. check write bandwidth  1 : check. 0 not check.
// bit 29. check read bandwidth  1 : check. 0 : not check.
// bit 28:27. not used.
// bit 26. id_num2 enable.
// bit 25. id_num1 enable.
// bit 24. id_num0 enable.
// bit 23:16. master ID number 2.
// bit 15:8.  master ID number 1.
// bit 7:0.   master ID number 0.
#define DMC_MON7_BW 0x003f
// monitor 7 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.

#define DMC_CMD_FILTER_CTRL0 0x004a
#define DMC_CMD_FILTER_CTRL1 0x0040
#define DMC_CMD_FILTER_CTRL2 0x0041
// 31:24. keep the bank active if there's urgent level 3 read bank hit request.
// 23:16. keep the bank active if there's urgent level 2 read bank hit request.
// 15:8.  keep the bank active if there's urgent level 1 read bank hit request.
// 7:0.   keep the bank active if there's urgent level 0 read bank hit request.

#define DMC_CMD_FILTER_CTRL3 0x0042
// bit 31.    force wbuf empty.
// bit 30:26  wbuf high level number
// bit 25:21  wbuf mid  level number
// bit 20:16  wbuf low level number
// bit 14:10  rbuf high level number
// bit 9:5    rbuf middle level number
// bit 4:0    rbuf low level number

#define DMC_CMD_FILTER_CTRL4 0x0043
// bit 29:25.  tITW.long
// bit 24:20.  tITW. short
// bit 19:12   tAP auto precharge the bank not used if idle that long time.
// bit 11:6    write to read accesses if there write hit request.
// bit 5:0     read to write accesses if there write hit request.

#define DMC_CMD_FILTER_CTRL5 0x0044
// bit 31:24   Once ddr data bus switch to read, the maxmum read command number to give up the bus
// when there's write request pending for write buffer. bit 23:16   Once ddr data bus switch to
// write, the maxmum write command number to give up the bus when there's read request pending too
// long. bit 15:8.   Once ddr data bus switch to read, the minimum read command number to transfer
// back to write stage if there's still pending read request. bit 7:0.    Once ddr data bus switch
// to write, the minimum write command number to transfer back to read stage if there's still
// pending write request.

#define DMC_CMD_FILTER_CTRL6 0x0045
// bit 31:24   write urgent 3 request pending hold num.
// bit 23:16   write urgent 2 request pending hold num.
// bit 15:8.   write urgent 1 request pending hold num.
// bit 7:0.    write urgent 0 request pending hold num.

#define DMC_CMD_FILTER_CTRL7 0x0046
// bit 31:24.  aw_req_pedning signal assertion after wbuf full.
// bit 23:16   aw_req_pending signal hold how long if wbuf not full.
// bit 15:8    write to read waiting cycles if there write hit request.
// bit 7:0     read to write waiting cycles if there write hit request.

#define DMC_CMD_FILTER_CTRL8 0x0047
// bit 31:8    reserved.
// bit 7:0     rank limit to change to another rank.

#define DMC_CMD_BUFFER_CTRL 0x0048
// bit 31:26  total write buffer number. default 32.
// bit 25:20  total read buffer number. default 32.
// bit 19:8    reserved.
// bit 7:0    aw_pending_inc_num.  incease write ugent level 1 when write command waiting to in
// write buffer that long.

#define DMC_CMD_BUFFER_CTRL1 0x0049
// bit 29:24  read buffer number in non-urgent request.
// bit 23:16  read buffer bank miss watch dog threshold.
// bit 15:12  read buffer urgent level 3 counter inc weight.
// bit 11:8   read buffer urgent level 2 counter inc weight.
// bit 7:4    read buffer urgent level 1 counter inc weight.
// bit 3:0    read buffer urgent level 0 counter inc weight.

#define DMC_2ARB_CTRL 0x004c
// 32:24. Waiting limit to use the highest urgent level in the pipelines.
// 23:0.  Not used.

#define DMC_VERSION 0x004f
// read only 32'h01000015  for s5

#define DMC_AXI0_CHAN_CTRL 0x0080
// bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
// bit 19:16.   QOS value if this port is define use register value.
// bit 15       force this ports QOS to use this register bit 19:16.
// bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
// bit 3:0      arbiter weight
#define DMC_AXI0_HOLD_CTRL 0x0081
// 31:24 write hold num.   max outstanding request number.
// 23:16  write hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
// 15:8 read hold num.   max outstanding request number.
// 7:0  read hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI0_CHAN_CTRL1 0x0082
// 31:28.  FIQ  chan0 QOS setting.
// 27:24.  IRQ  chan0 QOS settign.
// 23:23.  chan0 write QOS with VPU request.
// 19:16.  chan0 write QOS with other request .
// 15:12.  chan0 write QOS with none other requests.
// 11:8.   chan0 read QOS with VPU request.
// 7:4.    chan0 read QOS with other request .
// 3:0.    chan0 read QOS with none other requests.

#define DMC_AXI0_CHAN_CTRL2 0x0083
// bit 31:9.  Not used.
// bit 8.     enable to configure QOS with transaction is not split to 2 DDR ADDRESS region.
// bit 7:4.   QOS value if this transaction is only to this DMC.
// bit 3.     CPU FIQ QOS ctrl_en.
// bit 2.     CPU IRQ QOS ctrl_en.
// bit 1.     CPU read channel auto QOS enable (based on other traffic).
// bit 0.     CPU write chanel auto QOS enable( based on other traffic).

#define DMC_AXI1_CHAN_CTRL 0x0084
// bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
// bit 19:16.   QOS value if this port is define use register value.
// bit 15       force this ports QOS to use this register bit 19:16.
// bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
// bit 3:0      canvas arbiter weight

#define DMC_AXI1_HOLD_CTRL 0x0085
// bit 31:24 write hold num.   max outstanding request number.
// bit 23:16  write hold release num. if the outstanding request == hold num, then hold this
// request unless the outstanding request number bellow the hold release number, then continue to
// request. bit 15:8 read hold num.   max outstanding request number. bit 7:0  read hold release
// num. if the outstanding request == hold num, then hold this request unless the outstanding
// request number bellow the hold release number, then continue to request.
#define DMC_AXI1_CHAN_CTRL1 0x0086

#define DMC_AXI2_CHAN_CTRL 0x0088
// bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
// bit 19:16.   QOS value if this port is define use register value.
// bit 15       force this ports QOS to use this register bit 19:16.
// bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
// bit 3:0      arbiter weight

#define DMC_AXI2_HOLD_CTRL 0x0089
// 31:24 write hold num.   max outstanding request number.
// 23:16  write hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
// 15:8 read hold num.   max outstanding request number.
// 7:0  read hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI2_CHAN_CTRL1 0x008a
// bit 31:29. not used.
// bit 28:20. when write/read side band signal used to block other request. configure which master
// we can block. each bit for  one master. Note. don't block vpu itself and  CPU or other urgent
// request. bit 19. use side band write urgent control signal to control AWQOS.  1: enabe. 0:
// disable. bit 18. use side band read  urgent control signal to control ARQOS.  1: enabe. 0:
// disable. bit 17. use side band write urgent control signal to block other master request.  1:
// enable. 0 disable. bit 16. use side band read urgent control signal to block other master
// request.  1: enable. 0 disable. bit 15:12.  the AWQOS value when side band write urgent control
// signal = 1 while bit 19 enabled. bit 11:8.   the ARQOS value when side band read  urgent control
// signal = 1 while bit 18 enabled. bit 7:0.    Not used.

#define DMC_AXI3_CHAN_CTRL 0x008c
// bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
// bit 19:16.   QOS value if this port is define use register value.
// bit 15       force this ports QOS to use this register bit 19:16.
// bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
// bit 3:0      arbiter weight
#define DMC_AXI3_HOLD_CTRL 0x008d
// 31:24 write hold num.   max outstanding request number.
// 23:16  write hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
// 15:8 read hold num.   max outstanding request number.
// 7:0  read hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI3_CHAN_CTRL1 0x008e

#define DMC_AXI4_CHAN_CTRL 0x0090
// bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
// bit 19:16.   QOS value if this port is define use register value.
// bit 15       force this ports QOS to use this register bit 19:16.
// bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
// bit 3:0      arbiter weight
#define DMC_AXI4_HOLD_CTRL 0x0091
// 31:24 write hold num.   max outstanding request number.
// 23:16  write hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
// 15:8 read hold num.   max outstanding request number.
// 7:0  read hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI4_CHAN_CTRL1 0x0092

#define DMC_AXI5_CHAN_CTRL 0x0094
// not used.
#define DMC_AXI5_HOLD_CTRL 0x0095
// 31:24 write hold num.   max outstanding request number.
// 23:16  write hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
// 15:8 read hold num.   max outstanding request number.
// 7:0  read hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI6_CHAN_CTRL 0x0098
// bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
// bit 19:16.   QOS value if this port is define use register value.
// bit 15       force this ports QOS to use this register bit 19:16.
// bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
// bit 3:0      arbiter weight
#define DMC_AXI6_HOLD_CTRL 0x0099
// 31:24 write hold num.   max outstanding request number.
// 23:16  write hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
// 15:8 read hold num.   max outstanding request number.
// 7:0  read hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI6_CHAN_CTRL1 0x009a

#define DMC_AXI7_CHAN_CTRL 0x009c
// bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
// bit 19:16.   QOS value if this port is define use register value.
// bit 15       force this ports QOS to use this register bit 19:16.
// bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
// bit 3:0      arbiter weight
#define DMC_AXI7_HOLD_CTRL 0x009d
// 31:24 write hold num.   max outstanding request number.
// 23:16  write hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
// 15:8 read hold num.   max outstanding request number.
// 7:0  read hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI7_CHAN_CTRL1 0x009e

#define DMC_AXI0_CHAN_STS 0x00a0
// AXI0 Async interface status.
// 31:24.  read command pending transaction number.
// 23:16.  write command pending transaction number.
// 15:8.   not used.
// 7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI1_CHAN_STS 0x00a1
// Mali virtual channel status.
// 31:24. read command pending transaction number.
// 23:16. write command pending transaction number.
// 15:8.  write data fifo counter.
// 7:0.   mali master side wddata valid for AWVALID counter.
#define DMC_AXI2_CHAN_STS 0x00a2
// AXI chan2 status.
// 31:24. read command pending transaction number.
// 23:16. write command pending transaction number.
// 15:8.  AWVALID without WDATA transaction number..
// 7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI3_CHAN_STS 0x00a3
// AXI chan3 status.
// 31:24. read command pending transaction number.
// 23:16. write command pending transaction number.
// 15:8.  AWVALID without WDATA transaction number..
// 7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI4_CHAN_STS 0x00a4
// AXI chan4 status.
// 31:24. read command pending transaction number.
// 23:16. write command pending transaction number.
// 15:8.  AWVALID without WDATA transaction number..
// 7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI5_CHAN_STS 0x00a5
// AXI chan4 status.
// 31:24. read command pending transaction number.
// 23:16. write command pending transaction number.
// 15:8.  write address without read data counter.
// 7:0.  not used.
#define DMC_AXI6_CHAN_STS 0x00a6
// AXI channel 6 status.
// 31:24. read command pending transaction number.
// 23:16. write command pending transaction number.
// 15:8.  AWVALID without WDATA transaction number..
// 7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI7_CHAN_STS 0x00a7
// AXI channel 7 status.
// 31:24. read command pending transaction number.
// 23:16. write command pending transaction number.
// 15:8.  AWVALID without WDATA transaction number..
// 7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.

#define DMC_AXI8_CHAN_STS 0x00a8
// AXI channel 7 status.
// 31:24. read command pending transaction number.
// 23:16. write command pending transaction number.
// 15:8.  AWVALID without WDATA transaction number..
// 7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.

#define DMC_AXI8_CHAN_CTRL 0x00aa
// bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
// bit 19:16.   QOS value if this port is define use register value.
// bit 15       force this ports QOS to use this register bit 19:16.
// bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
// bit 3:0      arbiter weight
#define DMC_AXI8_HOLD_CTRL 0x00ab
// 31:24 write hold num.   max outstanding request number.
// 23:16  write hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
// 15:8 read hold num.   max outstanding request number.
// 7:0  read hold release num. if the outstanding request == hold num, then hold this request
// unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI8_CHAN_CTRL1 0x00ac

#define DMC_AXI0_CHAN_STS1 0x00b0
// 9:5. CPU FIQ STS
// 4:0. CPU IRQ STS.

#define DMC_CHAN_STS 0x00bc
// AXI0  is first CPU and Mali conbined channel from CCI-400 directly.  The first 2Gbyte address
// will go through this channel. AXI10  is the second CPU, Mali channel combined with NNA  from
// NIC-400.  The upper 2Gbyte address will go through this channel.
// read only register.
// the second mali and NNA channel IDLE.
// the second CPU channel IDLE.
// the first mali channel IDLE.
// the first CPU channel IDLE.
// bit 31:27   not used. always 1
// bit 26      ddr0 write data buffer idle. 1 : idle 0: busy.
// bit 25      always 1.
// bit 24      ddr0 wbuf idle.              1 : idle 0: busy.
// bit 16:8    not used.   always 1.
// bit 7       AXI channel7 idle.
// bit 6       AXI channel6 idle.
// bit 5       AXI channel5 idle.
// bit 4       AXI channel4 idle.
// bit 3       AXI channel3 idle.
// bit 2       AXI channel2 idle.
// bit 1       always 1.
// bit 0       AXI channel0 idle.

#define DMC_MON_IRQ_STS 0x00db
// bit 31:1   Not used.
// bit 0 :    QOS Monitor interrupt flag.  1: means there's QOS monitor interrupt.  write 1 to
// clean this interrupt.

// DMC protection function domain register.
// one protection can chose upto 4 master IDs to monitors.
// for these 4 master IDs, you can chose either include them. or exclude them.
#define DMC_PROT0_STA 0x00e0
// 31:20. not used.
// 19:0   protection 0 start address . unit 4Kbyte.
#define DMC_PROT0_EDA 0x00e1
// 31:20. not used.
// 19:0   protection 0 end address. unit 4Kbyte.
#define DMC_PROT0_CTRL 0x00e2
// bit 27.  protection 0 write monitor enable.
// bit 26.  protection 0 read monitor enable.
// bit 8.   montior policy:  1 include the ids.  0: exclude the IDS.
// bit 3.   ID3 enable.
// bit 2.   ID2 enable.
// bit 1.   ID1 enable.
// bit 0.   ID0 enable.
#define DMC_PROT0_CTRL1 0x00e3
// bit 31:24.   ID3 id number.
// bit 23:16.   ID2 id number.
// bit 15:8     ID1 id number.
// bit 7:0.     ID0 id number.
#define DMC_PROT1_STA 0x00e4
// bit 31:20. not used.
// bit 19:0   protection 1 start address . unit 4Kbyte.
#define DMC_PROT1_EDA 0x00e5
// bit 31:20. not used.
// bit 19:0   protection 1 end address. unit 4Kbyte.
#define DMC_PROT1_CTRL 0x00e6
// bit 27.  protection 1 write monitor enable.
// bit 26.  protection 1 read monitor enable.
// bit 8.   montior policy:  1 include the ids.  0: exclude the IDS.
// bit 3.   ID3 enable.
// bit 2.   ID2 enable.
// bit 1.   ID1 enable.
// bit 0.   ID0 enable.
#define DMC_PROT1_CTRL1 0x00e7
// bit 31:24.   ID3 id number.
// bit 23:16.   ID2 id number.
// bit 15:8     ID1 id number.
// bit 7:0.     ID0 id number.

#define DMC_PROT_VIO_0 0x00e8
// protection write violation low 32bits address.
#define DMC_PROT_VIO_1 0x00e9
// bit 18.     protection 1 violation.
// bit 17.     protection 0 violation.
// bit 16:15.  AWADDR[33:32].
// bit 14:0    AWUSER  please refer  AXI bus AWUSER bits define.
#define DMC_PROT_VIO_2 0x00ea
// protection read violation low 32bits address. ARADDR[31:0].
#define DMC_PROT_VIO_3 0x00eb
// bit 18.     protection 1 violation.
// bit 17.     protection 0 violation.
// bit 16:15.  ARADDR[33:32].
// bit 14:0    ARUSER  please refer  AXI bus AWUSER bits define.

#define DMC_PROT_IRQ_CTRL_STS 0x00ec
// bit 2.   protection IRQ enable.
// bit 1.   read for write prot violation. write 1 to clean the write protection status and
// interrupt. bit 0.   read for read prot violation. write 1 to clean the read protection status and
// interrupt.

#define DMC_PROT0_CTRL2 0x00ed
// bit 19.  prot0 SubID3 en for prot0 id3.
// bit 18.  prot0 SubID2 en for prot0 id2.
// bit 17.  prot0 SubID1 en for prot0 id1.
// bit 16.  prot0 SubID0 en for prot0 id0.
// bit 15:12.prot0 subid3 id number.
// bit 11:8. prot0 subid2 id number.
// bit 7:4.  prot0 subid1 id number.
// bit 3:0.  prot0 subid0 id number.
#define DMC_PROT1_CTRL2 0x00ee
// bit 19.   prot1 SubID3 en for prot0 id3.
// bit 18.   prot1 SubID2 en for prot0 id2.
// bit 17.   prot1 SubID1 en for prot0 id1.
// bit 16.   prot1 SubID0 en for prot0 id0.
// bit 15:12.prot1 subid3 id number.
// bit 11:8. prot1 subid2 id number.
// bit 7:4.  prot1 subid1 id number.
// bit 3:0.  prot1 subid0 id number.

// SIU register.
// there's 2 set of timing DDR timing parameter for 2 set of DDR freqency parameter.
// when change frequency, the hardware would automatically select one of these two set of timing
// parameter DMC_DRAM_* is for Frequency set 0. DMC_NFQ_* is for Freqency set 1.
#define DMC_DRAM_TMRD 0x0100
// bit 4:0.  tMRD. //MR command cycles, in DDR3/4.  in LPDDR4, it should be value of tMRW
#define DMC_DRAM_TRFC 0x0101
// bit 25:16 tRFCpb
// bit 9:0   tRFCab
#define DMC_DRAM_TRP 0x0102
// bit 21:16.  tRP for precharge all banks.
// bit 5:0.    tRP for precharge one bank.
#define DMC_DRAM_TRTW 0x0103
// bit 31:6:   Not used.
// bit 5:0     DDR3/4 mode : tRTW.
// For LPDDR4 .  The total read command -> write command = (RL + BL/2 - tWODTON) + TDQSCK_MAX +
// tWPRE +RD(tRPST).
//                 tRTW = TDQSCK_max + tWPRE + tRD(tRPST)  + (delay margin)
#define DMC_DRAM_TCL 0x0104
// bit 5:0  tCL/tRL. read latency.
#define DMC_DRAM_TCWL 0x0105
// bit 5:0.  CWL:  write latency.
#define DMC_DRAM_TRAS 0x0106
// bit 7:0.  tRAS.  minimum active to precharge time for same bank.
#define DMC_DRAM_TRC 0x0107
// bit 7:0.  tRC.  minimum active to active time for same bank.
#define DMC_DRAM_TRCD 0x0108
// bit 7:0  tRCD  active to read/write timing for same bank.
#define DMC_DRAM_TRRD 0x0109
// bit 21:16.  tRRD_l  active bank A to active B in same band group for DDR4.
// bit 5:0.    tRRD/tRRD_s   active bank A to active bank b time.
// tRRD_s:   active bank A to active bank b in different bank grousp for DDR4.
#define DMC_DRAM_TFAW 0x010a
// bit 8:0   tFAW.  four active command windows
#define DMC_DRAM_TRTP 0x010b
// bit 5:0  tRTP. in LPDDR5 should be tBL + tRBTP
#define DMC_DRAM_TWR 0x010c
// bit 5:0 tWR.
#define DMC_DRAM_TWTR 0x010d
// bit 21:16 tWTR_l   For DDR4 WTR_l.  FOR DDR3/LPDDR4 same as tWTR_s.
// bit 5:0 tWTR_s.
#define DMC_DRAM_TCCD 0x010e
// bit 19:16. tCCD/tCCD_l.
// bit 3:0 tCCD/tCCD_s    read to read command time or write to write command time.
#define DMC_DRAM_TEXSR 0x010f
// bit 12:0. tEXSR.  EXIT SELF-REFRESH to read/write command.
#define DMC_DRAM_TXS 0x0110
// bit 9:0  tXS.  EXIT SELF_REFRESH to other command time
#define DMC_DRAM_TXP 0x0111
// bit 6:0. LPDDR4 tXP.  EXIT power down to other command time
// LPDDR5 tCSL
#define DMC_DRAM_TXPDLL 0x0112
// bit 12:0.  tXPDLL,  EXIT power down to read/write command time(need to relock PLL).
#define DMC_DRAM_TZQCS 0x0113
// bit 11:0.  ZQCS command to other command time.
#define DMC_DRAM_TCKSRE 0x0114
// bit 4:0. enter self refresh to disable clock time.
#define DMC_DRAM_TCKSRX 0x0115
// bit 4:0. enable clock to exit self refresh time.
#define DMC_DRAM_TCKE 0x0116
// bit 4:0.  CKE high or low minimum time.
// LPDDR5: tCSPD. power down to power up
#define DMC_DRAM_TMOD 0x0117
// bit 4:0  tMOD.  MRR/MRW to other command time. in LPDDR4, still use this register but it called
// tMRD.

#define DMC_DRAM_TDQS 0x0118
// bit 31:28 reserved
// bit 27:24 tDQS. the delay for write after read in different rank.
// bit 23:20 reserved
// bit 19:16 tDQS. the delay for read after write in different rank.
// bit 15:12 reserved
// bit 11:8  tDQS. the delay for write after write in different rank.
// bit 7:4 reserved
// bit 3:0 tDQS. the delay for read after read in different rank.
#define DMC_DRAM_TRSTL 0x0119
// not used.
#define DMC_DRAM_TZQLAT 0x011a
// bit 5:0 ZQ LATCH command to other command timing in LPDDR4 mode.
#define DMC_DRAM_TMRR 0x011b
// bit 7:0 tMRR  not used in DMC.

#define DMC_DRAM_TCKESR 0x011c
// bit 9:0 tCKESR.   CKE low minimum pulse in self refresh mode.
#define DMC_DRAM_TDPD 0x011d
// not support.
#define DMC_DRAM_DFITCTRLDELAY 0x011e
// bit 3:0. DFI_t_ctrldealy
#define DMC_DRAM_DFITPHYWRDATA 0x011f
// bit 5:0.  dfi_t_phy_wrdata.
#define DMC_DRAM_DFITPHYWRLAT 0x0120
// bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATAEN 0x0121
// bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define DMC_DRAM_DFITPHYRDLAT 0x0122
// bit 5:0.  dfi_t_rdlat.
#define DMC_DRAM_DFITCTRLUPDMIN 0x0123
// bit 7:0.  CTRLUPD_MIN  minimux clock cycle to maintain CTRLUPD_REQ.
#define DMC_DRAM_DFITCTRLUPDMAX 0x0124
// bit 7:0   CTRLUPD_MAX.  maxmum clock cycle to maintain CTRLUPD_REQ if no CTRLUPD_ACK response.
#define DMC_DRAM_DFITREFMSKI 0x0126
// not used.
#define DMC_DRAM_DFITCTRLUPDI 0x0127
// not used.
#define DMC_DRAM_DFITDRAMCLK 0x0128
// bit 17    dram clk1 enable.
// bit 16    dram clk0 enable.
// bit 15:8  DRAM CLK disable waiting time
// bit 7:0   DRAM CLK enable  enable timer

#define DMC_DRAM_DFITLPRESP 0x012a
// bit 4:0.  dfi_lp_ctrl_req response time. after dfi_lp_ctrl_req asserted, and after response
// time if there's still no dfi_lp_ack respone, then drop the dfi_lp_ctrl_req.

#define DMC_DRAM_TCKECK 0x012c
// bit 4:0. tCKECK  from CKE low to assert dfi_dram_clk_disable time. this time + dfi_t_ctrl_delay
// in LPDDR5 tCSLCK

#define DMC_DRAM_TREFI 0x012d
// write this register will update the auto refresh related register to the auto refresh control
// logic. bit 31:24:  tZQCI dmc send zqci period.  unit is how much auto refresh period. bit 23:16
// pvti  dmc send dfi_ctrlupd_req period.  unit is one auto refresh period. bit 15:8.   tREFI.dmc
// send auto refresh command period. unit is 100ns. bit 7:0.    t100ns period. unit is dmc clock
// cycles
#define DMC_DRAM_TSR 0x012e
// bit 5:0 tSR.  self resfresh enter to exit time.
#define DMC_DRAM_TCCDMW 0x012f
// bit 5:0.  4*tCCD in LPDDR4 mask write.
#define DMC_DRAM_TESCKE 0x0130
// bit 5:0  tESCKE.  enter self refresh to power time for LPDDR4.
#define DMC_DRAM_TREFI_DDR3 0x0131
// 9:0. use this register to reset refi_disable_cnt. the unit is t100ns.
// use this to check in 8*tREFI time, the DMC should not sent more than 16 auto REFRESH command.
#define DMC_DRAM_TZQCAL 0x0132
// 15:0. ZQCAL for LPDDR4.  tZQCAL4/8/16 for LP5.
#define DMC_DRAM_T10US 0x0133
// 10us clock cycle number used for LP2 mode.
#define DMC_DRAM_TMRRI 0x0134
// bit 7:0   tMRRI for MRR
#define DMC_DRAM_TXS_FAST 0x0135
// bit 9:0 DDR4 mode XS_FAST exit self_refrest to zqcl/zqcs/mrs command.
#define DMC_DRAM_DFIODTCFG 0x0136
// bit 12.  rank1 ODT default. default vulue for ODT[1] pins if theres no read/write activity.
// bit 11.  rank1 ODT write sel.  enable ODT[1] if there's write occur in rank1.
// bit 10.  rank1 ODT write nsel. enable ODT[1] if theres's write occur in rank0.
// bit 9.   rank1 odt read sel.   enable ODT[1] if there's read occur in rank1.
// bit 8.   rank1 odt read nsel.  enable ODT[1] if there's read occurred in rank0.
// bit 4.   rank0 ODT default.    default vulue for ODT[0] pins if theres no read/write activity.
// bit 3.   rank0 ODT write sel.  enable ODT[0] if there's write occur in rank0.
// bit 2.   rank0 ODT write nsel. enable ODT[0] if theres's write occur in rank1.
// bit 1.   rank0 odt read sel.   enable ODT[0] if there's read occur in rank0.
// bit 0.   rank0 odt read nsel.  enable ODT[0] if there's read occurred in rank1.
#define DMC_DRAM_DFIODTCFG1 0x0137
// bit 27:24  ODT length for BL8 read transfer.
// bit 19:16. ODT length for BL8 write transfer.
// bit 12:8.  ODT latency for reads.  suppose to be 0.
// bit 4:0.   ODT latency for writes.  suppose to be 0.

#define DMC_DRAM_TWODTON 0x0138
// bit 5:0   DRAM write access ODT on time.
//   in DDR3/4 should be same as WL.
//   in LPDDR4 ODT enable  mode:  tODTLon + tODTon.min
//   In LPDDR4 ODT disable mode:  tWL.

#define DMC_DRAM_PHYADDRON 0x013a
// bit 5:0 PHY_CTRL_ADDR_ON for new PHY. default : 12 unit: DfiClk
#define DMC_DRAM_PHYWRON 0x013b
// bit 6:0 PHY_CTRL_ADDR_ON for new PHY. unit: ddr clk
// PHY_CTRL_WR_ON.  = 20 + WL + (tDQSS+ tDQS2DQ + tWPST)/ddr_clk + BL/2
#define DMC_DRAM_PHYRDON 0x013c
// PHY_CTRL_RD_ON.  = 20 + RL + (tDQSCK+ tRPST + tDQSQ)/ddr_clk + BL/2

#define DMC_DRAM_ZQCTRL 0x013d
// tZQCI bits in DMC_DRAM_TREFI  defined how many refresh period send ZQCS/ZQUPD/command.
// this register defines in 0~tZQCI period, which refresh period count to send partical
// ZQCS/ZACAL/ZQUPD command 31:24.  in LPDDR4 case when to send ZQLAT comman to both RANKs of
// LPDDR4 SDRAM 23:16.  when to send PHY ZQ UPDATE command. 15:8.   when to send ZQCS/ZQCAL to
// rank1 DDR SDRAM. 7:0.    when to senc ZQCS/ZQCAL to rank0 DDR SDRAM.

#define DMC_DRAM_DFITPHYWRLATCSN 0x013e
// bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATACSN 0x013f
// bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define DMC_DRAM_TPBR 0x01a0
// bit 23:16 tPBR2ACT
// bit 7:0   tPBR2PBR
#define DMC_DRAM_TWCK_FS 0x01a1
// timing for wck_fs sync command
// bit 31:24 tWCKOFF
// bit 23:16 tWCKPRE_TOGGLE
// bit 15:8  tWCKPRE_STATIC
// bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_WR 0x01a2
// timing for wck_wr sync command
// bit 31:24 tWCKOFF
// bit 23:16 tWCKPRE_TOGGLE
// bit 15:8  tWCKPRE_STATIC
// bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_RD 0x01a3
// timing for wck_rd sync command
// bit 31:24 tWCKOFF
// bit 23:16 tWCKPRE_TOGGLE
// bit 15:8  tWCKPRE_STATIC
// bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_OFF 0x01a4
// timing for wck_rd sync command
// bit 31:24 not used.
// bit 23:16 timing from write command to wck off timing.
//  = WL + BURST + TWCKPOST + tWCK2DQI ?
// bit 15:8  WCKOFF cmd to other command timing.
// bit 7:0   timing from read command to wck off timing.
//  = RL + BURST + TWCKPOST + tWCK2DQO ?
#define DMC_DRAM_TPPD 0x01a5
// bit 31:24 not used.
// bit 7:0.  tPPD. precharge to precharge delay in LPDDR5.
#define DMC_DRAM_TCSH 0x01a6
// bit 7:0.  tCSH for LPDDR5
#define DMC_DRAM_TCMDPD 0x01a7
// bit 7:0.  tCMDPD for LPDDR5
#define DMC_DRAM_TOSCPD 0x01a8
// bit 7:0.  tOSCPD for LPDDR5 : tOSCPD + tOSC
#define DMC_DRAM_TWCK2DQ 0x01a9
// bit 23:16. tWCK2DQI max
// bit 7:0.   tWCK2DQO max
#define DMC_DRAM_TRFM 0x01aa
// 9:0. tRFMpb for lpddr5
#define DMC_DRAM_TCKMAX 0x01ab
// 7:0  tclk(max).    100ns in LPDDR4.

// timing parameter for frequency set 1.
#define DMC_NFQ_TMRD 0x0140
#define DMC_NFQ_TRFC 0x0141
#define DMC_NFQ_TRP 0x0142
#define DMC_NFQ_TRTW 0x0143
#define DMC_NFQ_TCL 0x0144
#define DMC_NFQ_TCWL 0x0145
#define DMC_NFQ_TRAS 0x0146
#define DMC_NFQ_TRC 0x0147
#define DMC_NFQ_TRCD 0x0148
#define DMC_NFQ_TRRD 0x0149
#define DMC_NFQ_TFAW 0x014a
#define DMC_NFQ_TRTP 0x014b
#define DMC_NFQ_TWR 0x014c
#define DMC_NFQ_TWTR 0x014d
#define DMC_NFQ_TCCD 0x014e
#define DMC_NFQ_TEXSR 0x014f
#define DMC_NFQ_TXS 0x0150
#define DMC_NFQ_TXP 0x0151
#define DMC_NFQ_TXPDLL 0x0152
#define DMC_NFQ_TZQCS 0x0153
#define DMC_NFQ_TCKSRE 0x0154
#define DMC_NFQ_TCKSRX 0x0155
#define DMC_NFQ_TCKE 0x0156
#define DMC_NFQ_TMOD 0x0157
#define DMC_NFQ_TDQS 0x0158
#define DMC_NFQ_TRSTL 0x0159
#define DMC_NFQ_TZQLAT 0x015a
#define DMC_NFQ_TMRR 0x015b
#define DMC_NFQ_TCKESR 0x015c
#define DMC_NFQ_TDPD 0x015d
#define DMC_NFQ_DFITCTRLDELAY 0x015e
#define DMC_NFQ_DFITPHYWRDATA 0x015f
#define DMC_NFQ_DFITPHYWRLAT 0x0160
#define DMC_NFQ_DFITRDDATAEN 0x0161
#define DMC_NFQ_DFITPHYRDLAT 0x0162
#define DMC_NFQ_DFITCTRLUPDMIN 0x0163
#define DMC_NFQ_DFITCTRLUPDMAX 0x0164
#define DMC_NFQ_DFITREFMSKI 0x0166
#define DMC_NFQ_DFITCTRLUPDI 0x0167
#define DMC_NFQ_DFITDRAMCLK 0x0168
#define DMC_NFQ_DFITLPRESP 0x016a
#define DMC_NFQ_TCKECK 0x016c
#define DMC_NFQ_TREFI 0x016d
#define DMC_NFQ_TSR 0x016e
#define DMC_NFQ_TCCDMW 0x016f
#define DMC_NFQ_TESCKE 0x0170
#define DMC_NFQ_TREFI_DDR3 0x0171
#define DMC_NFQ_TZQCAL 0x0172
#define DMC_NFQ_T10US 0x0173
#define DMC_NFQ_TMRRI 0x0174
#define DMC_NFQ_TXS_FAST 0x0175
#define DMC_NFQ_DFIODTCFG 0x0176
#define DMC_NFQ_DFIODTCFG1 0x0177
#define DMC_NFQ_TWODTON 0x0178
#define DMC_NFQ_PHYADDRON 0x017a
#define DMC_NFQ_PHYWRON 0x017b
#define DMC_NFQ_PHYRDON 0x017c
#define DMC_NFQ_ZQCTRL 0x017d
#define DMC_NFQ_DFITPHYWRLATCSN 0x017e
#define DMC_NFQ_DFITRDDATACSN 0x017f

#define DMC_NFQ_TPBR 0x01b0
#define DMC_NFQ_TWCK_FS 0x01b1
#define DMC_NFQ_TWCK_WR 0x01b2
#define DMC_NFQ_TWCK_RD 0x01b3
#define DMC_NFQ_TWCK_OFF 0x01b4
#define DMC_NFQ_TPPD 0x01b5
#define DMC_NFQ_TCSH 0x01b6
#define DMC_NFQ_TCMDPD 0x01b7
#define DMC_NFQ_TOSCPD 0x01b8
#define DMC_NFQ_TWCK2DQ 0x01b9
#define DMC_NFQ_TRFM 0x01ba
#define DMC_NFQ_TCKMAX 0x01bb

#define DMC_DRAM_DFITPHYUPDTYPE0 0x0180
// dfi_phyupd_ack hold time for dfi_phyupd_req type = 0.
#define DMC_DRAM_DFITPHYUPDTYPE1 0x0181
// dfi_phyupd_ack hold time for dfi_phyupd_req type = 1.
#define DMC_DRAM_DFITPHYUPDTYPE2 0x0182
// dfi_phyupd_ack hold time for dfi_phyupd_req type = 2.
#define DMC_DRAM_DFITPHYUPDTYPE3 0x0183
// dfi_phyupd_ack hold time for dfi_phyupd_req type = 3.

#define DMC_DRAM_MCFG 0x0186
// bit 31:27  not used.
// bit 29.    freq_change request from dmc_clk_feq. 1 : enable. 0 use local dmc freq_change
// request. bit 28.    in LPDDR4 mode, retraining request from dmc_clk_freq.  1: enable.  0: use
// local dmc retraining request. bit 27.    use auto_refr request from dmc_clk_freq. 1: enabled. 0
// use local dmc auto refresh request. bit 26:24  rank1_d16_sel.  16bit mode, rank 1 byte
// selection. bit 23     not used. bit 22:20. rank0_d16_sel. 16bit mode, rank 0 byte selection.
// bit 19.   send PHY ZQ command  after siu self refresh exit. 1 : enable.  0 : disable.
// bit 18.   send retrain command after siu self refresh exit. 1 : enable. 0 : disable.
// bit 17.   in DDR3/4 mode, send ZQCL command after exit register triggered self refresh.
// bit 16.   send refresh command after finish frequency change. 1 : enable. 0 : disable.
// bit 15.   send refresh command after finish LPDDR4 retraining. 1 : enable. 0 : disable.
// bit 14.   1: cke init low.  0 : cke init high.
// bit 13    1: dbi write enable only for LPDDR4.
// bit 12.   1: dbi read inversion.   0:  dbi read high inversion.
// bit 11.   1: dbi read enable. 0:  dbi not enabled.
// bit 10    1: enable staggered chip select for 2 ranks DRAM.
// bit 9     1: enable send auto refresh command to DDR SDRAM when PCTL is in CFG/STOP state.
// bit 8     send auto refr cmd before enter register triggered  self refresh
// bit 7     send auto refr cmd after exit register triggered self refresh mode.
// bit 6     disable dram clock after enter register triggered self refresh.
// bit 5     send DFI_LP_REQ to PHY after enter register triggered elf refresh mode.
// bit 4     send DRAM to power down mode after enter self refresh. ONLY for LPDDR4.
// bit 3     send DFI_CTRLUPD_REQ after exit register triggered self refresh.
// bit 2     send ZQCS command after exit register triggered self refresh.
// bit 1     enable PHY triggered DFI_PHYUPD_REQ.
// bit 0     2T mode. always 1 in DDR3/4 mode.

#define DMC_DRAM_ZQ_CTRL 0x0187
// bit 31:16. how long PHY will finish PHY ZQ calibration. so DMC can send update request.
// bit 15:4 not used.
// bit 3  enable PHY ZQ CAL in ASR mode.
// bit 2  ZQ command must be send in different time.
// bit 1  ZQ command can be send at same time.
// bit 0  rank0 ZQ only

#define DMC_DRAM_MCFG1 0x0188
// bit 22.  mrr_dbi_en. to enable dbi function for MR read.
// bit 21;  enable separate dfi_lp_data_req. 1: enable. 0: dfi_lp_data_req same as
// dfi_lp_ctrl_req. bit 20:16 dfi_lp_data_wakeup value. bit 14.  enable SIU read data with DBI
// result. bit 13.  LPDDR5 LINK_ECC read enable. bit 12.  LPDDR5 LINK_ECC write enable. bit 9.
// LPDDR5 use WCK always on mode. bit 8    LPDDR5 wck use WCK_FS command for fast 2 rank wck sync
// command. bit 7:0.  LPDDR4 MRW DBI data mask pattern.  //default 8'b11111000;

#define DMC_DRAM_DFI_CTRL 0x0189
// bit 31 siu_dfi_lat err generation enable.  1: if dfi read latency violation, generate data
// error. 0 : disable. bit 19: dfi_init_complete wait enable.  1: after dfi_init_complete, wait
// additional EXSR time for new command. 0: phy will handle all the timing    after
// dfi_init_complete DMC can do everything they want. bit 18:  dfi_rddata_cs_n polariy.  0:  rank0
// select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10. bit 17:
// dfi_wrdata_cs_n polariy.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select =
// 2'b01, rank1_select = 2'b10. bit 16:  force PHY ctrl_on  if = 1, phy_ctrl_on signal will keep
// on. bit 15 siu_dfi1_lp_en bit 14 siu_dfi_lp_ack_and bit 13 siu_dfi_lp_ack_or bit 12
// siu_dfi1_init_start_en bit 11 siu_dfi_init_com_and bit 10 siu_dfi_init_com_or bit  9
// siu_dfi1_freq_en bit  8 siu_dfi1_dram_clk_dis_en bit  7 siu_dfi_phyupd_type_sel bit  6
// siu_dfi1_phyupd_ack_en bit  5 siu_dfi_phyupd_req_and bit  4 siu_dfi_phyupd_req_or bit  3
// siu_dfi_ctrlupd_ack_and bit  2 siu_dfi_ctrlupd_ack_or bit  1 siu_dfi1_ctrlupd_req_en bit  0
// siu_dfi1_cmd_en

#define DMC_DRAM_DFIINITCFG 0x018a
// bit 31.     dfi_init_complete status. read only.
// bit 19:18.  Frequency set 1 dfi_freq_fsp value.
// bit 17:16.  Frequency set 0 dfi_freq_fsp value.
// bit 15:14.  Frequency set 1 dfi_freq_ratio value.
// bit 12:8    Frequency set 1 dfi_freq value.
// bit 7:6     Frequency set 0 dfi_freq_ratio value.
// bit 5:1     Frequency set 0 dfi_freq value.
// bit 0.      dfi_init_start value  can be use manually config dfi_init_start signal.

#define DMC_DRAM_APD_CTRL 0x018c
// bit 19:16  DFI_LP_WAKEUP value in APD DFI_LP_REQ mode
// bit 12    1: exit power down slow mode(waiting PLL LOCK).  0 : fast mode.
// bit 11    enable DFI_LP_REQ when enter Auto power down mode.
// bit 10    disable DFI_clk_disable when enter auto power down mode.
// bit 9:0    0  disable auto power down mode.
// non zero value to enable auto power down when DMC is in idle state for this number of clock
// cycles.

#define DMC_DRAM_ASR_CTRL 0x018d
// bit 31. enable RETRAIN PHY after auto selfrefresh exit. for AM_PHY only.
// bit 30. in DDR3/4 mode, send ZQCL command after exit from auto self refresh mode.
// bit 29. enable PHY clock in LP2 mode.  1: enable. 0 : disable.
// bit [28:24] DFI_LP_WAKEUP value in self refresh DFI_LP_REQ mode.
// bit 23 : send REFRESH command after exit from auto self refersh mode(ASR).
// bit 22 : send REFERSH command before enter to Auto self refresh mode(ASR).
// bit 21 : send ZQCS command after exit from Auto self refresh mode(ASR).
// bit 20 : send dfi_ctrl_upd after exit from ASR mode
// bit 19 : send power down command when enter ASR mode. //for LPDDR4 only.
// bit 18 : set the PHY enter LP2 mode after enter ASR mode. //not support for P1 LP5PHY
// bit 17 : send DFI_LP_REQ  after enter ASR mode.
// bit 16 : set DFI_CLK_DISABLE after enter ASR mode.
// bit 15:0.   0 disable auto ASR mode.
// Non-zero valule enable ASR mode. when DMC is in idle state for this number of clock cycles, the
// DMC will enter ASR mode.

#define DMC_DRAM_REFR_CTRL 0x0192
// bit 28  enable send phy pvt request after PHY ZQ calibration request.
// bit 27:24 refresh postpone number threshold.
// bit 23  enable Per Bank refresh mode.
// bit 22  dmc to control DFI_CTRLUPD_REQ  with zq generation together.
// bit 21  dmc to control PHY ZQ generation enable.
// bit 20  dmc to control zqlat(in LPDDR4 mode) generation enable.
// bit 19  dmc to control zqcs1 generation enable.
// bit 18  dmc to control zqcs0 generation enable.
// bit 17:8 auto refresh request pending cnt if there's page hit request.
// bit 7  not used.
// bit 6  Disabled auto refresh command if over 16 auto refresh command sent in 2 TREFI_DDR3
// period bit 5  enable dmc send ZQCS command . bit 4. enable dmc send DFI_CTRUPD_REQ. bit 3:1. how
// many refresh command send for one period. = this number + 1 bit 0.  enable dmc send auto refresh
// command.

#define DMC_DRAM_FREQ_CTRL 0x0193
// bit 31 .  write 1 to change freqency   read 0: finished.
// bit 30.   waiting for software to send some manual command.  1 : waiting. 0 : not ready yet.
// bit 29:22.  not used.
// bit 21     after Freqchange send PHY ZQ update.
// bit 20    send CTRLUPD_REQ to PHY after freq_change finished.
// bit 19:16. how many cycles to send PLL change req after init_complete signal to low.
// bit 15.   freq pre  config_en. Before freq enter stop state let DMC configure DDR SDRAM.
// bit 14.   freq post config_en. After  freq enter stop state let DMC configure DDR SDRAM.
// bit 13.   send zqcl after freq change in DDR3/4 mode.
// bit 12.   send zqcs after freq change. 1: enable. 0 not send.
// bit 11.   in AUTO MRW funcntion: the data format.  1: use USR_CMD format.  0: MRW format.
// bit 10.   AUTO MRW function:  1 use hardware auto MRW function.  0: don't do auto MRW.
// bit 9.  1 : FREQ MRW done. let FREQ change machine continue.
// bit 8   FREQ WAIT. 1 when freq change finishes, state machine stop at self refresh state in
// case there's something need to handle.
//     0 after freq change finishes  the state machine go back to access state.
// bit 7   when change PLL setting, disable dmc clock
// bit 6   when change PLL setting, disable PHY DfiClk and DfiCtlClk.
// bit 5   check vpu_sleep_en ==1 when do FREQ change.  if vpu_sleep_en == 0, just wait.
// bit 4   nxt frequency selection.  1 = freq1. 0 = freq0.
// bit 3:1.  not used.
// bit 0.   current frequency selection.

#define DMC_DRAM_SCFG 0x0194
// bit 2:0 only one bit can be high at same time.
// bit 2  1 : to ask PCTL enter ACCESS STATE.  0 : deassert the request.
// bit 1  1 : to ask PCTL enter SELF REFRESH STATE.  0 : deassert the request.
// bit 0  1 : to ask PCTL enter STOP/CONFIG STATE .  0 : deassert the request.

#define DMC_DRAM_STAT 0x0195
// bit 31     rd latency error. 1: means after dfiphytrdlat cycles, the read data still not back.
// bit 30.     not used.
// bit 29:24   dram_sr_state
// bit 23:20   stop_st
// bit 19:16  freq_st.
// 4'h0 : IDLE
// 4'h1 : FREQ_CHECK_VPU
// 4'h2 : FREQ_WAITING_STOP
// 4'h3 : FREQ_DRAM_CFG.  waiting DMC/software to send special MRW/MPC command to configure DDR
// SDRAM either before Freq change or after freq change. 4'h4 : FREQ_SELF_REFR_ST. 4'h5 :
// FREQ_SET_DFI_FREQ. 4'h6 : FREQ_DFI_INIT_START_HIGH. 4'h7 : FREQ_CHANGE PLL_ST. 4'h8 :
// FREQ_UPDATA REG. 4'h9 : FREQ_DFI_INIT_START_LOW. 4'ha : FREQ_WAITING_FINISH 4'hb : FREQ_ZQCS
// 4'hc : FREQ_ZQ_LATCH
// 4'hd : FREQ_PVT
// bit 15:12  ACCESS STATUS 0 :  ACCESS is in normal working mode.
// 1 :   ACCESS sending precharege command.
// 2 :   ACCESS sending AUTO REFESH command.
// 3 :   ACCESS sending DIF_CTRLUPD_REQ command.
// 4 :   ACCESS sending ZQCS command to DDR DRAM(ZQCAL for LPDDR4).
// 5 :   ACCESS sending ZQLATCH command to  LPDDR4 only.

// bit 11:8   APD STATUS:   0 :   APD_IDLE
// 1 :    APD sending PRECHARGE command
// 2 :    APD sending CKE low command
// 3 :    APD sending DISABLE DRAM CLOCK command
// 4 :    APD sending DFI_LP_CTRL_REQ
// 5 :    APD in Auto Power down mode.
// 6 :    APD deassert DFI_LP_CTRL_REQ
// 7 :    APD sending enable DRAM CLOCK command
// 8 :    APD sending out CKE high command.
// bit 7:4: DRAM_STATUS:  0  :    DRAM IDLE
// 1  :    DRAM_STOP/DRAM_CFG
// 2  :    DRAM_ACCESS
// 3  :    DRAM_SLEEP
// 4  :    DRAM APD(AUTO POWER DOWN).
// 5  :    IDLE -> STOP/CONFIG
// 6  :    STOP -> SLEEP
// 7  :    STOP -> ACCESS
// 8  :    ACCESS -> SLEEP.
// 9  :    ACCESS -> STOP
// A  :    ACCESS -> APD
// B  :    SLEEP -> STOP
// C  :    SLEEP -> ACCESS
// D  :    APD -> ACCESS
// bit 3        reserved.
// bit 2        1 : DRAM enter normal working state.
// bit 1        1 : DRAM enter sleep state. self refresh state.
// bit 0        1 : dram enter cfg state.

#define DMC_DRAM_STAT1 0x0196
// bit 12:8   sleep_st
// bit  7:5   train_st
// bit  4:0   dram_phy_st

#define DMC_PHY_RETRAINING_CTRL 0x0197
// bit 31 :  phy_retraining enable.
// bit 30 :  check  vpu sleep_en.
// bit 29 :  retrain_only 1: use full 28:24 as retrain dfi_freq value 0: use only 28:27 + origh
// dfi_freq2:0 as the retrain dfi_freq. bit 28:24 : retraining dfi_freq[4:3], the [2:0] bit still
// use the dfi_freq bits to keep the frequency. bit 23:    retrain cke mode enable use for LPDDR4
// mode. before send dfi_init_start request to DDR_PHY, 1: put LPDDR4 SDRAM into self_refresh +
// power down mode. 0: put LPDDR4 SDRAM in self-refresh  mode. bit 15:0: retraining period unit :
// one refresh period.

#define DMC_DFI_ERR_STAT 0x0198
// LPDDR4 PHY DFI error information.
// bit 31:20. not used.
// bit 9.    ddr0_dfi_error
// bit 8:5   ddr0_dfi_error_info.
// bit 4.    ddr1_dfi_error.
// bit 3:0.  ddr1_dfi_error_info.

#define DMC_LP2_TIMER 0x019a
// bit 15:0.   timer setting to measure how long the chip is entered LP2 mode.
// this timer is 40bits counter with DMC PCLK.
// we use the high 16bits to compare this register. if the counter is large than this number, that
// means  the PHY need addition 10us after wakeup the PHY and before exit self_refresh mode.

#define DMC_DRAM_COMPLETE_WAIT 0x019b
// read only how long to waiting for DFI_INIT_COMPLETE become high after DFI_INIT_START triggered.

#define DMC_OSC_CTRL 0x019c
// bit 31  osc_en. for LPDDR4 enable MPC DQS2DQ OSC counter .
// bit 30:16.  siu_osc_run.  LPDDR4 DQS interval timer run time in n_clk unit.
// bit 15:0 osc counter value in tREFI time. how long to trigger one DQS2DQ retraing.

#define DMC_TEMP_CTRL 0x019d
// bit 31  mr temp read control.
// bit 23:0 counter value in t100NS.

#define DMC_TEMP_CTRL1 0x019e
// bit 7:0  mr index.

#define DMC_DRAM_DFI_SWAP_0 0x01c0
#define DMC_DRAM_DFI_SWAP_1 0x01c1
#define DMC_DRAM_DFI_SWAP_2 0x01c2
#define DMC_DRAM_DFI_SWAP_3 0x01c3
#define DMC_DRAM_DFI_SWAP_4 0x01c4

#define DMC_DRAM_CMD 0x01d0
// bit 31. cmd done.  write 0 to clean.
// bit 30. data done. write 0 to clean.
// bit 8 . dram command is for data 16 bits.
// bit 7:6 2'b01: user command with data read.
// 2'b10: user command with data write.
// 2'b00: user command without data.
// bit 5.  user defined command.
// bit 4.  LPDDR4 MPC write data command( MPC WR FIFO). not support in LPDDR5.
// bit 3.  LPDDR4 MPC read data command (MPC RD Calibration and RD FIFO). not support in LPDDR5
// bit 2.  LPDDR4 MPC-1 command ( NOP,  Start DQS interval ....)
// bit 1.  mrr command.
// bit 0.  mrw command.

#define DMC_DRAM_CMD_CODE 0x01d1
// bit 31:28  user command case: DDR4: = {act_n, ras_n, cas_n, we_n}. LP4 case. bit 28 =1 used for
// 2 cycle command. bit 28 = 0: used for 1 cycle command. bit 27:26. 128bits data cycles . 0: 1
// clock cycles;  1: 2  clock cycles; 2: 3 clock cycles; 3:4 clock cycles.
//           LPDDR4 : 2 clock cycles;
//           LPDDR5 : 2 clock cycles for MRR command.  4 cycles for RFF command.
// bit 25     MRW/MRR/MPC command rank 1 select.  1: select.  0: not select.
// bit 24.    MRW/MRR/MPC command rank 0 select.  1: select.  0: not select.
// bit 23:16  MR addr.
// bit 15:0   opcode.

#define DMC_DRAM_CMD_TIME 0x01d2
// bit 31:16  PRE  CMD timer. //delay how many cycle to start the command.
// bit 15:0   POST CMD timer  //delay how many cycle after the command execute.

#define DMC_DRAM_WSTRB0 0x01d3
#define DMC_DRAM_WSTRB1 0x01d4
#define DMC_DRAM_RDBI0 0x01d5
// MPC RD FIFO command DBI read back data
// bit 31:16  the second cycle.
// bit 15:0   the first cycle.
#define DMC_DRAM_RDBI1 0x01d6
// MPC RD FIFO command DBI read back data
// bit 31:16. the Forth cycle.
// bit 15:0.  the third cycle.

// WD0~16 and RD0~16 can be used as MRW command as Frequency change .
// WD0~16 is for Freq1 DRAM MR setting, it would send to DRAM right before FREQ0-> FREQ1
// RD0_16 is for Freq0 DRAM MR setting. it would send to DRAM right before FREQ1-> FREQ0.
// each register can be one MRW command. So total 16 MRW command can be sent to DRAM.
// The register formats:
// bit 31.   MRW/USER command enable.  1: enabled command. 0 not enabled.
// bit 30.   last MRW/USER command.   if this bit =1, After send this command, the DRAM controller
// will contine frequency next stage. bit 29:26. USER COMMAND parameter: in DDR3/DDR4.  {act_n,
// ras_n, cas_n, we_n} value for user command in LPDDR4.  bit 16: 1 4 cycles command.  0 2 cycles
// command. bit 25     MRW/USER command rank 1 select.  1: select.  0: not select. bit 24. MRW/USER
// command rank 0 select.  1: select.  0: not select. bit 23:0.  USER command. DDR3:    18:16 bank
// address. 15:0:  address. DDR4:    20:19 bank group address.   18:16: bank address. 15:0 address.
// LPDDR3:   9:0. rising edge address.  19:10.  falling edge address.
// LPDDR4.   5:0, first edge address,  11:6 second edge address, 17:12: third edge address. 23:18,
// forth edge address. MRW command format: bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0]. 20:19
// BG[1:0]. bit 15:0   opcode.
#define DMC_DRAM_WD0 0x01e0
#define DMC_DRAM_WD1 0x01e1
#define DMC_DRAM_WD2 0x01e2
#define DMC_DRAM_WD3 0x01e3
#define DMC_DRAM_WD4 0x01e4
#define DMC_DRAM_WD5 0x01e5
#define DMC_DRAM_WD6 0x01e6
#define DMC_DRAM_WD7 0x01e7
#define DMC_DRAM_WD8 0x01e8
#define DMC_DRAM_WD9 0x01e9
#define DMC_DRAM_WD10 0x01ea
#define DMC_DRAM_WD11 0x01eb
#define DMC_DRAM_WD12 0x01ec
#define DMC_DRAM_WD13 0x01ed
#define DMC_DRAM_WD14 0x01ee
#define DMC_DRAM_WD15 0x01ef

#define DMC_DRAM_RD0 0x01f0
#define DMC_DRAM_RD1 0x01f1
#define DMC_DRAM_RD2 0x01f2
#define DMC_DRAM_RD3 0x01f3
#define DMC_DRAM_RD4 0x01f4
#define DMC_DRAM_RD5 0x01f5
#define DMC_DRAM_RD6 0x01f6
#define DMC_DRAM_RD7 0x01f7
#define DMC_DRAM_RD8 0x01f8
#define DMC_DRAM_RD9 0x01f9
#define DMC_DRAM_RD10 0x01fa
#define DMC_DRAM_RD11 0x01fb
#define DMC_DRAM_RD12 0x01fc
#define DMC_DRAM_RD13 0x01fd
#define DMC_DRAM_RD14 0x01fe
#define DMC_DRAM_RD15 0x01ff

#define DMC_DRAM_MRR0 0x0280
// 7:0  the 1st MR read result for snoop
#define DMC_DRAM_MRR1 0x0281
// 7:0  the 2nd MR read result for snoop
#define DMC_DRAM_MRR2 0x0282
// 7:0  the 3rd MR read result for snoop
#define DMC_DRAM_MRR3 0x0283
// 7:0  the 4th MR read result for snoop
#define DMC_DRAM_MRR4 0x0284
// 7:0  the 5th MR read result for snoop
#define DMC_DRAM_MRR5 0x0285
// 7:0  the 6th MR read result for snoop
#define DMC_DRAM_MRR6 0x0286
// 7:0  the 7th MR read result for snoop
#define DMC_DRAM_MRR7 0x0287
// 7:0  the 8th MR read result for snoop
#define DMC_DRAM_MRR8 0x0288
// 7:0  the 1st MR read result for rfc rate
#define DMC_DRAM_MRR9 0x0289
// 7:0  the 2nd MR read result for rfc rate

// STICKY registers.
// those register is for software save some tempary value. and because it's in RAM. it won't lose
// if DMC get reseted.
#define DMC_STICKY_0 0x0200
#define DMC_STICKY_1 0x0201
#define DMC_STICKY_2 0x0202
#define DMC_STICKY_3 0x0203
#define DMC_STICKY_4 0x0204
#define DMC_STICKY_5 0x0205
#define DMC_STICKY_6 0x0206
#define DMC_STICKY_7 0x0207
#define DMC_STICKY_8 0x0208
#define DMC_STICKY_9 0x0209
#define DMC_STICKY_10 0x020a
#define DMC_STICKY_11 0x020b
#define DMC_STICKY_12 0x020c
#define DMC_STICKY_13 0x020d
#define DMC_STICKY_14 0x020e
#define DMC_STICKY_15 0x020f
#define DMC_STICKY_16 0x0210
#define DMC_STICKY_17 0x0211
#define DMC_STICKY_18 0x0212
#define DMC_STICKY_19 0x0213
#define DMC_STICKY_20 0x0214
#define DMC_STICKY_21 0x0215
#define DMC_STICKY_22 0x0216
#define DMC_STICKY_23 0x0217
#define DMC_STICKY_24 0x0218
#define DMC_STICKY_25 0x0219
#define DMC_STICKY_26 0x021a
#define DMC_STICKY_27 0x021b
#define DMC_STICKY_28 0x021c
#define DMC_STICKY_29 0x021d
#define DMC_STICKY_30 0x021e
#define DMC_STICKY_31 0x021f
#define DMC_STICKY_32 0x0220
#define DMC_STICKY_33 0x0221
#define DMC_STICKY_34 0x0222
#define DMC_STICKY_35 0x0223
#define DMC_STICKY_36 0x0224
#define DMC_STICKY_37 0x0225
#define DMC_STICKY_38 0x0226
#define DMC_STICKY_39 0x0227
#define DMC_STICKY_40 0x0228
#define DMC_STICKY_41 0x0229
#define DMC_STICKY_42 0x022a
#define DMC_STICKY_43 0x022b
#define DMC_STICKY_44 0x022c
#define DMC_STICKY_45 0x022d
#define DMC_STICKY_46 0x022e
#define DMC_STICKY_47 0x022f
#define DMC_STICKY_48 0x0230
#define DMC_STICKY_49 0x0231
#define DMC_STICKY_50 0x0232
#define DMC_STICKY_51 0x0233
#define DMC_STICKY_52 0x0234
#define DMC_STICKY_53 0x0235
#define DMC_STICKY_54 0x0236
#define DMC_STICKY_55 0x0237
#define DMC_STICKY_56 0x0238
#define DMC_STICKY_57 0x0239
#define DMC_STICKY_58 0x023a
#define DMC_STICKY_59 0x023b
#define DMC_STICKY_60 0x023c
#define DMC_STICKY_61 0x023d
#define DMC_STICKY_62 0x023e
#define DMC_STICKY_63 0x023f

// DMC TEST.
// DMC test use AXI 16Gbyte address. So user should guarrante
#define DMC_TEST_STA 0x0350
// 31:0   TEST start address low 32bits. low 6 bits should be 0.
#define DMC_TEST_STA_HI 0x0351
// 1:0  TEST start address higher 2 bits.
#define DMC_TEST_EDA 0x0352
// test end address.  low 32bits. low 6bits should be 0.
#define DMC_TEST_EDA_HI 0x0353
// test end address higher 2 bits.

#define DMC_TEST_CTRL 0x0354
// bit 31.  enable test.
// bit 30.  when enable test, enable the write to DDR function.
// bit 29.  when enable test, enable the read from DDR function.
// bit 27.  enabe to compare data.  when do the read enable to enable the error comparaion.
// suppose the read data should be same as the data in the write buffer. bit 26.  max_err_stop
// enable.  1: stop the test if err_cnt over max_err configure. 0: disable. bit 24.  done type. 0 :
// use the DMC_TEST_NUM register as the counter of test numbers.
//                             for write if the write command number == the DMC_TEST_NUM, the
//                             write is done. for read if the read command number == the DMC
//                             TEST_num,
//                         1 : finshed at end address.
// bit 22:20.   not used.
// bit 19.     limit write.  0: no outstanding write request limitation.
//                          1: limit the outstanding write commands to the number of bits [15:8]
// bit 18.     limit read.   0. no outstanding read request limitation.
//                          1. limit the read outstanding request to the number of bits[7:0].
// bit 15:8.   write outstanding commands limit.
// bit 7:0.    read  outstanding commands limit.

#define DMC_TEST_NUM 0x0355
// how many test command for the test if the DMC_TEST_CTRL bit 24 is 0.

#define DMC_TEST_WDG 0x0356
// 31:16.  write response watch dog.
// 15:0.   read response  watch dog.

#define DMC_TEST_MAX_ERR 0x0357
// 31:0  max err counter. if error cnt over this number, stop the test.

#define DMC_TEST_COMP_MASK 0x0358
// 32bits for DMC TEST COMPARE bit enable.
// 1 : to MASK this bit.  0: compare this bit.

#define DMC_TEST_WRDATA_ADDR 0x0359
// bit 31:7  Not used.
// bit 6:0.  WRDATA pattern APB configure address. total 128 32bits wrdata pattern.
#define DMC_TEST_WRDATA_VALUE 0x035a
// bit 31:0.   first config DMC_TEST_WRDATA_ADDR, then write this register to configure the WRDATA
// pattern.
// write this register would trigger WRDATA_ADDR + 1.
#define DMC_TEST_RDEXP_ADDR 0x035b
// bit 31:7  Not used.
// bit 6:0.  read expect data pattern APB configure address. total 128 32bits read expected data
// pattern.
#define DMC_TEST_RDEXP_VALUE 0x035c
// bit 31:0.   first config DMC_TEST_RDEXP_ADDR, then write this register to configure the READ
// EXP data pattern. write this register would trigger RDEXP_ADDR + 1.

// dmc_test  wdata_type = 1  first write data = {WD3, WD2, WD1, WD0}.
// the following wrdata[31:0]   = previous write data[31:0]    +  WDINC0.
// the following wrdata[63:32]  = previous write data[63:32]   +  WDINC1.
// the following wrdata[95:64]  = previous write data[95:64]   +  WDINC2.
// the following wrdata[127:96] = previous write data[127:96]  +  WDINC3.
#define DMC_TEST_WD0 0x0360
#define DMC_TEST_WD1 0x0361
#define DMC_TEST_WD2 0x0362
#define DMC_TEST_WD3 0x0363

#define DMC_TEST_WDINC0 0x0364
#define DMC_TEST_WDINC1 0x0365
#define DMC_TEST_WDINC2 0x0366
#define DMC_TEST_WDINC3 0x0367

#define DMC_TEST_ERR_ADDR 0x0340
// read only. it capature the first error address.
#define DMC_TEST_ERR_ADDR_HI 0x0341
// read only. it capature the first error address higher 2 bits.

#define DMC_TEST_ERR_CNT 0x0342
// read only. how many data error happens in the whole test period.
#define DMC_TEST_ERR_DATA0 0x0343
// the first error data low 32bit.
#define DMC_TEST_ERR_DATA1 0x0344
// the first error data bit [63:32]
#define DMC_TEST_ERR_DATA2 0x0345
// the first error data bit [95:64]
#define DMC_TEST_ERR_DATA3 0x0346
// the first error data bit [127:96]

#define DMC_TEST_STS 0x0347
// read only.
// bit 31,   test done bit. write 1 to clean.
// bit 30,   indicate address err
// bit 29~7.  not used.
// bit 6.    read data resp error(caused by security or rd latency).
// bit 4.   max error counter violation.
// bit 3,    write done.   write 1 to clean.
// bit 2,    read done.    write 1 to clean
// bit 1,    write watchdog triggered.   write 1 to clean
// bit 0,    read watchdog triggered.    write 1 to clean.

#define DMC_TEST_WRCMD_ADDR 0x0348
// read only. the current write cmd address.
#define DMC_TEST_WRCMD_ADDR_HI 0x0349
// read only. the current write cmd address high 2 bit..

#define DMC_TEST_RDCMD_ADDR 0x034a
// read only. the current read command address.
#define DMC_TEST_RDCMD_ADDR_HI 0x034b
// read only. the current read_cmd cmd address high 2 bit..

#define DMC_TEST_RDRSP_ADDR 0x034c
// read only. rdrsp address.
#define DMC_TEST_RDRSP_ADDR_HI 0x034d
// read only. the rd resp address high 2 bit..

#define DMC_TEST_RD0 0x0330
// the read back data 0.  if error happens, it would capture the first error data.
#define DMC_TEST_RD1 0x0331
// the read back data 1.  if error happens, it would capture the first error data.
#define DMC_TEST_RD2 0x0332
// the read back data 2.  if error happens, it would capture the first error data.
#define DMC_TEST_RD3 0x0333
// the read back data 3.  if error happens, it would capture the first error data.
#define DMC_TEST_RD4 0x0334
// the read back data 4.  if error happens, it would capture the first error data.
#define DMC_TEST_RD5 0x0335
// the read back data 5.  if error happens, it would capture the first error data.
#define DMC_TEST_RD6 0x0336
// the read back data 6.  if error happens, it would capture the first error data.
#define DMC_TEST_RD7 0x0337
// the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD8 0x0338
// the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD9 0x0339
// the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD10 0x033a
// the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD11 0x033b
// the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD12 0x033c
// the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD13 0x033d
// the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD14 0x033e
// the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD15 0x033f
// the read back data 7.  if error happens, it would capture the first error data.

// DMC Security control registers.
// DMC use 15bits ARUSER/AWUSER bits to identify AXI input ports master ID and secruity
// requirement and the necessory subID for bandwidth monitor protection functions. . bit 7:0.   for
// upto 256 Master-ID. bit  14:8.  for each Master-ID, the master can use those bits to define
// particular secrity requirments or bandwidth and protection function special requirements.

// region0(RANGE0) related register.
#define DMC_SEC_RANGE0_STA 0x0400
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE0_EDA 0x0401
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE0_CTRL 0x0402
#define DMC_SEC_RANGE0_RID_CTRL0 0x0403
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE0_RID_CTRL1 0x0404
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE0_RID_CTRL2 0x0405
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE0_RID_CTRL3 0x0406
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE0_WID_CTRL0 0x0408
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE0_WID_CTRL1 0x0409
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE0_WID_CTRL2 0x040a
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE0_WID_CTRL3 0x040b
// range_rd_sid_en[127:96];

// region0(RANGE1) related register.
#define DMC_SEC_RANGE1_STA 0x0410
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE1_EDA 0x0411
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE1_CTRL 0x0412

#define DMC_SEC_RANGE1_RID_CTRL0 0x0413
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE1_RID_CTRL1 0x0414
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE1_RID_CTRL2 0x0415
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE1_RID_CTRL3 0x0416
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE1_WID_CTRL0 0x0418
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE1_WID_CTRL1 0x0419
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE1_WID_CTRL2 0x041a
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE1_WID_CTRL3 0x041b
// range_rd_sid_en[127:96];

// region2(RANGE2) related register.
#define DMC_SEC_RANGE2_STA 0x0420
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE2_EDA 0x0421
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE2_CTRL 0x0422

#define DMC_SEC_RANGE2_RID_CTRL0 0x0423
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE2_RID_CTRL1 0x0424
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE2_RID_CTRL2 0x0425
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE2_RID_CTRL3 0x0426
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE2_WID_CTRL0 0x0428
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE2_WID_CTRL1 0x0429
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE2_WID_CTRL2 0x042a
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE2_WID_CTRL3 0x042b
// range_rd_sid_en[127:96];

// region3(RANGE3) related register.
#define DMC_SEC_RANGE3_STA 0x0430
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE3_EDA 0x0431
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE3_CTRL 0x0432

#define DMC_SEC_RANGE3_RID_CTRL0 0x0433
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE3_RID_CTRL1 0x0434
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE3_RID_CTRL2 0x0435
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE3_RID_CTRL3 0x0436
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE3_WID_CTRL0 0x0438
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE3_WID_CTRL1 0x0439
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE3_WID_CTRL2 0x043a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE3_WID_CTRL3 0x043b
// range_wr_sid_en[127:96];

// region4(RANGE4) related register.
#define DMC_SEC_RANGE4_STA 0x0440
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE4_EDA 0x0441
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE4_CTRL 0x0442

#define DMC_SEC_RANGE4_RID_CTRL0 0x0443
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE4_RID_CTRL1 0x0444
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE4_RID_CTRL2 0x0445
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE4_RID_CTRL3 0x0446
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE4_WID_CTRL0 0x0448
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE4_WID_CTRL1 0x0449
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE4_WID_CTRL2 0x044a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE4_WID_CTRL3 0x044b
// range_wr_sid_en[127:96];

// region5(RANGE5) related register.
#define DMC_SEC_RANGE5_STA 0x0450
// bit 31:22. not used.
// bit 21:0.  region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE5_EDA 0x0451
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE5_CTRL 0x0452

#define DMC_SEC_RANGE5_RID_CTRL0 0x0453
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE5_RID_CTRL1 0x0454
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE5_RID_CTRL2 0x0455
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE5_RID_CTRL3 0x0456
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE5_WID_CTRL0 0x0458
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE5_WID_CTRL1 0x0459
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE5_WID_CTRL2 0x045a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE5_WID_CTRL3 0x045b
// range_wr_sid_en[127:96];

// region6(RANGE6) related register.
#define DMC_SEC_RANGE6_STA 0x0460
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE6_EDA 0x0461
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE6_CTRL 0x0462

#define DMC_SEC_RANGE6_RID_CTRL0 0x0463
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE6_RID_CTRL1 0x0464
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE6_RID_CTRL2 0x0465
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE6_RID_CTRL3 0x0466
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE6_WID_CTRL0 0x0468
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE6_WID_CTRL1 0x0469
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE6_WID_CTRL2 0x046a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE6_WID_CTRL3 0x046b
// range_wr_sid_en[127:96];

// region7(RANGE7) related register.
#define DMC_SEC_RANGE7_STA 0x0470
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE7_EDA 0x0471
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE7_CTRL 0x0472

#define DMC_SEC_RANGE7_RID_CTRL0 0x0473
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE7_RID_CTRL1 0x0474
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE7_RID_CTRL2 0x0475
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE7_RID_CTRL3 0x0476
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE7_WID_CTRL0 0x0478
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE7_WID_CTRL1 0x0479
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE7_WID_CTRL2 0x047a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE7_WID_CTRL3 0x047b
// range_wr_sid_en[127:96];

// region8(RANGE8) related register.
#define DMC_SEC_RANGE8_STA 0x0480
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE8_EDA 0x0481
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE8_CTRL 0x0482
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.

#define DMC_SEC_RANGE8_RID_CTRL0 0x0483
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE8_RID_CTRL1 0x0484
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE8_RID_CTRL2 0x0485
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE8_RID_CTRL3 0x0486
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE8_WID_CTRL0 0x0488
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE8_WID_CTRL1 0x0489
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE8_WID_CTRL2 0x048a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE8_WID_CTRL3 0x048b
// range_wr_sid_en[127:96];

// region9(RANGE9) related register.
#define DMC_SEC_RANGE9_STA 0x0490
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE9_EDA 0x0491
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE9_CTRL 0x0492
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE9_RID_CTRL0 0x0493
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE9_RID_CTRL1 0x0494
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE9_RID_CTRL2 0x0495
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE9_RID_CTRL3 0x0496
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE9_WID_CTRL0 0x0498
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE9_WID_CTRL1 0x0499
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE9_WID_CTRL2 0x049a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE9_WID_CTRL3 0x049b
// range_wr_sid_en[127:96];

// region10(RANGE10) related register.
#define DMC_SEC_RANGE10_STA 0x04a0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE10_EDA 0x04a1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE10_CTRL 0x04a2
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE10_RID_CTRL0 0x04a3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE10_RID_CTRL1 0x04a4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE10_RID_CTRL2 0x04a5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE10_RID_CTRL3 0x04a6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE10_WID_CTRL0 0x04a8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE10_WID_CTRL1 0x04a9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE10_WID_CTRL2 0x04aa
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE10_WID_CTRL3 0x04ab
// range_wr_sid_en[127:96];

// region9(RANGE11) related register.
#define DMC_SEC_RANGE11_STA 0x04b0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE11_EDA 0x04b1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE11_CTRL 0x04b2
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE11_RID_CTRL0 0x04b3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE11_RID_CTRL1 0x04b4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE11_RID_CTRL2 0x04b5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE11_RID_CTRL3 0x04b6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE11_WID_CTRL0 0x04b8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE11_WID_CTRL1 0x04b9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE11_WID_CTRL2 0x04ba
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE11_WID_CTRL3 0x04bb
// range_wr_sid_en[127:96];

// region12(RANGE12) related register.
#define DMC_SEC_RANGE12_STA 0x04c0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE12_EDA 0x04c1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE12_CTRL 0x04c2
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE12_RID_CTRL0 0x04c3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE12_RID_CTRL1 0x04c4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE12_RID_CTRL2 0x04c5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE12_RID_CTRL3 0x04c6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE12_WID_CTRL0 0x04c8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE12_WID_CTRL1 0x04c9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE12_WID_CTRL2 0x04ca
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE12_WID_CTRL3 0x04cb
// range_wr_sid_en[127:96];

// region13(RANGE13) related register.
#define DMC_SEC_RANGE13_STA 0x04d0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE13_EDA 0x04d1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.

#define DMC_SEC_RANGE13_CTRL 0x04d2
// bit 31:8. not used.
// bit 7:6.  region secruity level. used for DMA/DEMUX
// bit 4     prot_en,  enable this region can be used for proection monitor. 1: enable. 0 disable.
// bit 3   not used.
// bit 2   range_lock,     lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1   range_key_sel,  range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0   range_en,       range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE13_RID_CTRL0 0x04d3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE13_RID_CTRL1 0x04d4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE13_RID_CTRL2 0x04d5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE13_RID_CTRL3 0x04d6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE13_WID_CTRL0 0x04d8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE13_WID_CTRL1 0x04d9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE13_WID_CTRL2 0x04da
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE13_WID_CTRL3 0x04db
// range_wr_sid_en[127:96];

// region14(RANGE14) related register.
#define DMC_SEC_RANGE14_STA 0x04e0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE14_EDA 0x04e1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE14_CTRL 0x04e2
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE14_RID_CTRL0 0x04e3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE14_RID_CTRL1 0x04e4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE14_RID_CTRL2 0x04e5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE14_RID_CTRL3 0x04e6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE14_WID_CTRL0 0x04e8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE14_WID_CTRL1 0x04e9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE14_WID_CTRL2 0x04ea
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE14_WID_CTRL3 0x04eb
// range_wr_sid_en[127:96];

// region15(RANGE15) related register.
#define DMC_SEC_RANGE15_STA 0x04f0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE15_EDA 0x04f1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE15_CTRL 0x04f2
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | not used. region15 is always enable.
#define DMC_SEC_RANGE15_RID_CTRL0 0x04f3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE15_RID_CTRL1 0x04f4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE15_RID_CTRL2 0x04f5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE15_RID_CTRL3 0x04f6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE15_WID_CTRL0 0x04f8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE15_WID_CTRL1 0x04f9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE15_WID_CTRL2 0x04fa
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE15_WID_CTRL3 0x04fb
// range_wr_sid_en[127:96];

#define DMC_SEC_RANGE16_STA 0x0600
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE16_EDA 0x0601
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE16_CTRL 0x0602
#define DMC_SEC_RANGE16_RID_CTRL0 0x0603
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE16_RID_CTRL1 0x0604
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE16_RID_CTRL2 0x0605
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE16_RID_CTRL3 0x0606
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE16_WID_CTRL0 0x0608
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE16_WID_CTRL1 0x0609
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE16_WID_CTRL2 0x060a
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE16_WID_CTRL3 0x060b
// range_rd_sid_en[127:96];

// region0(RANGE1) related register.
#define DMC_SEC_RANGE17_STA 0x0610
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE17_EDA 0x0611
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE17_CTRL 0x0612

#define DMC_SEC_RANGE17_RID_CTRL0 0x0613
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE17_RID_CTRL1 0x0614
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE17_RID_CTRL2 0x0615
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE17_RID_CTRL3 0x0616
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE17_WID_CTRL0 0x0618
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE17_WID_CTRL1 0x0619
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE17_WID_CTRL2 0x061a
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE17_WID_CTRL3 0x061b
// range_rd_sid_en[127:96];

// region2(RANGE2) related register.
#define DMC_SEC_RANGE18_STA 0x0620
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE18_EDA 0x0621
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE18_CTRL 0x0622

#define DMC_SEC_RANGE18_RID_CTRL0 0x0623
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE18_RID_CTRL1 0x0624
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE18_RID_CTRL2 0x0625
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE18_RID_CTRL3 0x0626
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE18_WID_CTRL0 0x0628
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE18_WID_CTRL1 0x0629
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE18_WID_CTRL2 0x062a
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE18_WID_CTRL3 0x062b
// range_rd_sid_en[127:96];

// region3(RANGE3) related register.
#define DMC_SEC_RANGE19_STA 0x0630
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE19_EDA 0x0631
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE19_CTRL 0x0632

#define DMC_SEC_RANGE19_RID_CTRL0 0x0633
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE19_RID_CTRL1 0x0634
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE19_RID_CTRL2 0x0635
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE19_RID_CTRL3 0x0636
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE19_WID_CTRL0 0x0638
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE19_WID_CTRL1 0x0639
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE19_WID_CTRL2 0x063a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE19_WID_CTRL3 0x063b
// range_wr_sid_en[127:96];

// region4(RANGE4) related register.
#define DMC_SEC_RANGE20_STA 0x0640
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE20_EDA 0x0641
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE20_CTRL 0x0642

#define DMC_SEC_RANGE20_RID_CTRL0 0x0643
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE20_RID_CTRL1 0x0644
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE20_RID_CTRL2 0x0645
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE20_RID_CTRL3 0x0646
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE20_WID_CTRL0 0x0648
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE20_WID_CTRL1 0x0649
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE20_WID_CTRL2 0x064a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE20_WID_CTRL3 0x064b
// range_wr_sid_en[127:96];

// region5(RANGE5) related register.
#define DMC_SEC_RANGE21_STA 0x0650
// bit 31:22. not used.
// bit 21:0.  region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE21_EDA 0x0651
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE21_CTRL 0x0652

#define DMC_SEC_RANGE21_RID_CTRL0 0x0653
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE21_RID_CTRL1 0x0654
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE21_RID_CTRL2 0x0655
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE21_RID_CTRL3 0x0656
// range_rd_sid_en[127:96];

#define DMC_SEC_RANGE21_WID_CTRL0 0x0658
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE21_WID_CTRL1 0x0659
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE21_WID_CTRL2 0x065a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE21_WID_CTRL3 0x065b
// range_wr_sid_en[127:96];

// region6(RANGE6) related register.
#define DMC_SEC_RANGE22_STA 0x0660
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE22_EDA 0x0661
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE22_CTRL 0x0662

#define DMC_SEC_RANGE22_RID_CTRL0 0x0663
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE22_RID_CTRL1 0x0664
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE22_RID_CTRL2 0x0665
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE22_RID_CTRL3 0x0666
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE22_WID_CTRL0 0x0668
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE22_WID_CTRL1 0x0669
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE22_WID_CTRL2 0x066a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE22_WID_CTRL3 0x066b
// range_wr_sid_en[127:96];

// region7(RANGE7) related register.
#define DMC_SEC_RANGE23_STA 0x0670
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE23_EDA 0x0671
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE23_CTRL 0x0672

#define DMC_SEC_RANGE23_RID_CTRL0 0x0673
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE23_RID_CTRL1 0x0674
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE23_RID_CTRL2 0x0675
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE23_RID_CTRL3 0x0676
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE23_WID_CTRL0 0x0678
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE23_WID_CTRL1 0x0679
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE23_WID_CTRL2 0x067a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE23_WID_CTRL3 0x067b
// range_wr_sid_en[127:96];

// region8(RANGE8) related register.
#define DMC_SEC_RANGE24_STA 0x0680
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE24_EDA 0x0681
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE24_CTRL 0x0682
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.

#define DMC_SEC_RANGE24_RID_CTRL0 0x0683
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE24_RID_CTRL1 0x0684
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE24_RID_CTRL2 0x0685
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE24_RID_CTRL3 0x0686
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE24_WID_CTRL0 0x0688
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE24_WID_CTRL1 0x0689
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE24_WID_CTRL2 0x068a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE24_WID_CTRL3 0x068b
// range_wr_sid_en[127:96];

// region9(RANGE9) related register.
#define DMC_SEC_RANGE25_STA 0x0690
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE25_EDA 0x0691
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE25_CTRL 0x0692
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE25_RID_CTRL0 0x0693
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE25_RID_CTRL1 0x0694
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE25_RID_CTRL2 0x0695
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE25_RID_CTRL3 0x0696
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE25_WID_CTRL0 0x0698
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE25_WID_CTRL1 0x0699
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE25_WID_CTRL2 0x069a
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE25_WID_CTRL3 0x069b
// range_wr_sid_en[127:96];

// region10(RANGE10) related register.
#define DMC_SEC_RANGE26_STA 0x06a0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE26_EDA 0x06a1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE26_CTRL 0x06a2
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE26_RID_CTRL0 0x06a3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE26_RID_CTRL1 0x06a4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE26_RID_CTRL2 0x06a5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE26_RID_CTRL3 0x06a6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE26_WID_CTRL0 0x06a8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE26_WID_CTRL1 0x06a9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE26_WID_CTRL2 0x06aa
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE26_WID_CTRL3 0x06ab
// range_wr_sid_en[127:96];

// region9(RANGE11) related register.
#define DMC_SEC_RANGE27_STA 0x06b0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE27_EDA 0x06b1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE27_CTRL 0x06b2
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE27_RID_CTRL0 0x06b3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE27_RID_CTRL1 0x06b4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE27_RID_CTRL2 0x06b5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE27_RID_CTRL3 0x06b6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE27_WID_CTRL0 0x06b8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE27_WID_CTRL1 0x06b9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE27_WID_CTRL2 0x06ba
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE27_WID_CTRL3 0x06bb
// range_wr_sid_en[127:96];

// region12(RANGE12) related register.
#define DMC_SEC_RANGE28_STA 0x06c0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE28_EDA 0x06c1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE28_CTRL 0x06c2
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE28_RID_CTRL0 0x06c3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE28_RID_CTRL1 0x06c4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE28_RID_CTRL2 0x06c5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE28_RID_CTRL3 0x06c6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE28_WID_CTRL0 0x06c8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE28_WID_CTRL1 0x06c9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE28_WID_CTRL2 0x06ca
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE28_WID_CTRL3 0x06cb
// range_wr_sid_en[127:96];

// region13(RANGE13) related register.
#define DMC_SEC_RANGE29_STA 0x06d0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE29_EDA 0x06d1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.

#define DMC_SEC_RANGE29_CTRL 0x06d2
// bit 31:8. not used.
// bit 7:6.  region secruity level. used for DMA/DEMUX
// bit 4     prot_en,  enable this region can be used for proection monitor. 1: enable. 0 disable.
// bit 3   not used.
// bit 2   range_lock,     lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1   range_key_sel,  range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0   range_en,       range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE29_RID_CTRL0 0x06d3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE29_RID_CTRL1 0x06d4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE29_RID_CTRL2 0x06d5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE29_RID_CTRL3 0x06d6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE29_WID_CTRL0 0x06d8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE29_WID_CTRL1 0x06d9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE29_WID_CTRL2 0x06da
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE29_WID_CTRL3 0x06db
// range_wr_sid_en[127:96];

// region14(RANGE14) related register.
#define DMC_SEC_RANGE30_STA 0x06e0
// bit 31:22. not used.
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
#define DMC_SEC_RANGE30_EDA 0x06e1
// bit 31:22. not used.
// bit 21:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define DMC_SEC_RANGE30_CTRL 0x06e2
// bit 21:0.   region start address AXI address [33:12] unit 4Kbyte.
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | range_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE30_RID_CTRL0 0x06e3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE30_RID_CTRL1 0x06e4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE30_RID_CTRL2 0x06e5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE30_RID_CTRL3 0x06e6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE30_WID_CTRL0 0x06e8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE30_WID_CTRL1 0x06e9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE30_WID_CTRL2 0x06ea
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE30_WID_CTRL3 0x06eb
// range_wr_sid_en[127:96];

// region15(RANGE15) related register.
#define DMC_SEC_RANGE31_CTRL 0x06f2
// bit 2  | 0 | range_lock  |  lock this range related registers. include *_STA, *_EDA, *_CTRL,
// *_RID_CTRL*, *WID_CTRL*. bit 1  | 0 | range_key_sel | range 0 data describle key selection.  1 :
// key1. 0 : key0. bit 0  | 0 | not used. region15 is always enable.

#define DMC_SEC_RANGE31_RID_CTRL0 0x06f3
// range_rd_sid_en[31:0];
#define DMC_SEC_RANGE31_RID_CTRL1 0x06f4
// range_rd_sid_en[63:32];
#define DMC_SEC_RANGE31_RID_CTRL2 0x06f5
// range_rd_sid_en[95:64];
#define DMC_SEC_RANGE31_RID_CTRL3 0x06f6
// range_rd_sid_en[127:96];
#define DMC_SEC_RANGE31_WID_CTRL0 0x06f8
// range_wr_sid_en[31:0];
#define DMC_SEC_RANGE31_WID_CTRL1 0x06f9
// range_wr_sid_en[63:32];
#define DMC_SEC_RANGE31_WID_CTRL2 0x06fa
// range_wr_sid_en[95:64];
#define DMC_SEC_RANGE31_WID_CTRL3 0x06fb
// range_wr_sid_en[127:96];

#define DMC_DES_PADDING 0x0500
// bit 31:0 | 0 | des_pading | 32bits address padding used for DES dkey generation.

#define DMC_DES_CTRL 0x0501
// bit 1 | 0 | GLOBAL_DES_EN |  1: Global DES enable. 0 : global DES disable.  default is 0.
// bit 0 | 0 | DES_lock  |  one time lock bit. after write 1 to this bit,
// DMC_DES_CTRL,DMC_DES_PADDING  can't be write and read.

#define DMC_DES_CTRL1 0x050a
// bit 31 : range31_des_en policy : 1 range31_des_en = range31_local_des_en && GLOBAL_DES_EN. 0 :
// range31_des_en = range31_local_des_en ||  GLOBAL_DES_EN. bit 30 : range30_des_en policy : 1
// range30_des_en = range30_local_des_en && GLOBAL_DES_EN. 0 : range30_des_en =
// range30_local_des_en ||  GLOBAL_DES_EN. bit 29 : range29_des_en policy : 1 range29_des_en =
// range29_local_des_en && GLOBAL_DES_EN. 0 : range29_des_en = range29_local_des_en ||
// GLOBAL_DES_EN. bit 28 : range28_des_en policy : 1 range28_des_en = range28_local_des_en &&
// GLOBAL_DES_EN. 0 : range28_des_en = range28_local_des_en ||  GLOBAL_DES_EN. bit 27 :
// range27_des_en policy : 1 range27_des_en = range27_local_des_en && GLOBAL_DES_EN. 0 :
// range27_des_en = range27_local_des_en ||  GLOBAL_DES_EN. bit 26 : range26_des_en policy : 1
// range26_des_en = range26_local_des_en && GLOBAL_DES_EN. 0 : range26_des_en =
// range26_local_des_en ||  GLOBAL_DES_EN. bit 25 : range25_des_en policy : 1 range25_des_en =
// range25_local_des_en && GLOBAL_DES_EN. 0 : range25_des_en = range25_local_des_en ||
// GLOBAL_DES_EN. bit 24 : range24_des_en policy : 1 range24_des_en = range24_local_des_en &&
// GLOBAL_DES_EN. 0 : range24_des_en = range24_local_des_en ||  GLOBAL_DES_EN. bit 23 :
// range23_des_en policy : 1 range23_des_en = range23_local_des_en && GLOBAL_DES_EN. 0 :
// range23_des_en = range23_local_des_en ||  GLOBAL_DES_EN. bit 22 : range22_des_en policy : 1
// range22_des_en = range22_local_des_en && GLOBAL_DES_EN. 0 : range22_des_en =
// range22_local_des_en ||  GLOBAL_DES_EN. bit 21 : range21_des_en policy : 1 range21_des_en =
// range21_local_des_en && GLOBAL_DES_EN. 0 : range21_des_en = range21_local_des_en ||
// GLOBAL_DES_EN. bit 20 : range20_des_en policy : 1 range20_des_en = range20_local_des_en &&
// GLOBAL_DES_EN. 0 : range20_des_en = range20_local_des_en ||  GLOBAL_DES_EN. bit 19 :
// range19_des_en policy : 1 range19_des_en = range19_local_des_en && GLOBAL_DES_EN. 0 :
// range19_des_en = range19_local_des_en ||  GLOBAL_DES_EN. bit 18 : range18_des_en policy : 1
// range18_des_en = range18_local_des_en && GLOBAL_DES_EN. 0 : range18_des_en =
// range18_local_des_en ||  GLOBAL_DES_EN. bit 17 : range17_des_en policy : 1 range17_des_en =
// range17_local_des_en && GLOBAL_DES_EN. 0 : range17_des_en = range17_local_des_en ||
// GLOBAL_DES_EN. bit 16 : range16_des_en policy : 1 range16_des_en = range16_local_des_en &&
// GLOBAL_DES_EN. 0 : range16_des_en = range16_local_des_en ||  GLOBAL_DES_EN. bit 15 :
// range15_des_en policy : 1 range15_des_en = range15_local_des_en && GLOBAL_DES_EN. 0 :
// range15_des_en = range15_local_des_en ||  GLOBAL_DES_EN. bit 14 : range14_des_en policy : 1
// range14_des_en = range14_local_des_en && GLOBAL_DES_EN. 0 : range14_des_en =
// range14_local_des_en ||  GLOBAL_DES_EN. bit 13 : range13_des_en policy : 1 range13_des_en =
// range13_local_des_en && GLOBAL_DES_EN. 0 : range13_des_en = range13_local_des_en ||
// GLOBAL_DES_EN. bit 12 : range12_des_en policy : 1 range12_des_en = range12_local_des_en &&
// GLOBAL_DES_EN. 0 : range12_des_en = range12_local_des_en ||  GLOBAL_DES_EN. bit 11 :
// range11_des_en policy : 1 range11_des_en = range11_local_des_en && GLOBAL_DES_EN. 0 :
// range11_des_en = range11_local_des_en ||  GLOBAL_DES_EN. bit 10 : range10_des_en policy : 1
// range11_des_en = range10_local_des_en && GLOBAL_DES_EN. 0 : range10_des_en =
// range10_local_des_en ||  GLOBAL_DES_EN. bit  9 : range9_des_en policy  : 1  range9_des_en =
// range9_local_des_en && GLOBAL_DES_EN. 0 :  range9_des_en =  range9_local_des_en ||
// GLOBAL_DES_EN. bit  8 : range8_des_en policy  : 1  range8_des_en =  range8_local_des_en &&
// GLOBAL_DES_EN. 0 :  range8_des_en =  range8_local_des_en ||  GLOBAL_DES_EN. bit  7 :
// range7_des_en policy  : 1  range7_des_en =  range7_local_des_en && GLOBAL_DES_EN. 0 :
// range7_des_en =  range7_local_des_en ||  GLOBAL_DES_EN. bit  6 : range6_des_en policy  : 1
// range6_des_en =  range6_local_des_en && GLOBAL_DES_EN. 0 :  range6_des_en =  range6_local_des_en
// ||  GLOBAL_DES_EN. bit  5 : range5_des_en policy  : 1  range5_des_en =  range5_local_des_en &&
// GLOBAL_DES_EN. 0 :  range5_des_en =  range5_local_des_en ||  GLOBAL_DES_EN. bit  4 :
// range4_des_en policy  : 1  range4_des_en =  range4_local_des_en && GLOBAL_DES_EN. 0 :
// range4_des_en =  range4_local_des_en ||  GLOBAL_DES_EN. bit  3 : range3_des_en policy  : 1
// range3_des_en =  range3_local_des_en && GLOBAL_DES_EN. 0 :  range3_des_en =  range3_local_des_en
// ||  GLOBAL_DES_EN. bit  2 : range2_des_en policy  : 1  range2_des_en =  range2_local_des_en &&
// GLOBAL_DES_EN. 0 :  range2_des_en =  range2_local_des_en ||  GLOBAL_DES_EN. bit  1 :
// range1_des_en policy  : 1  range1_des_en =  range1_local_des_en && GLOBAL_DES_EN. 0 :
// range1_des_en =  range1_local_des_en ||  GLOBAL_DES_EN. bit  0 : range0_des_en policy  : 1
// range0_des_en =  range0_local_des_en && GLOBAL_DES_EN. 0 :  range0_des_en =  range0_local_des_en
// ||  GLOBAL_DES_EN.

#define DMC_DES_KEY0_REG0 0x0502
#define DMC_DES_KEY0_REG1 0x0503
#define DMC_DES_KEY0_REG2 0x0504
#define DMC_DES_KEY0_REG3 0x0505
#define DMC_DES_KEY1_REG0 0x0506
#define DMC_DES_KEY1_REG1 0x0507
#define DMC_DES_KEY1_REG2 0x0508
#define DMC_DES_KEY1_REG3 0x0509

// FROM SC2, the APB bus provided Master ID through PUSER.
// after ID_REMAP, this PUSE provided 8 master ID type.
// they are:
//  8'b0000_0001 : TEE
//  8'h0000_0010 : REE
//  8'h0000_0100 : JTAG
//  8'h0000_1000 : AOCPU
//  8'h0001_0000 : DSPA
//  8'h0010_0000 : DSPB
//  no others.

// FROM SC2, the APB bus provided Master ID through PUSER signals.
// there's total 8 master IDs could access DMC non-secure registers.
// we assign 1 control bit for each APB Master and each DMC non-secure register domains
// and we added one lock bits to lock this setting can't be modified any more.
#define DDR_APB_SEC_CTRL0 0x0510
// APB access  control for dmc REQUEST control register access control register.
// default : 0x005
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL1 0x0511
// APB access control for DMC DRAM timing parameter and DFI interface registers.
// default : 0x005
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL2 0x0512
// APB access control for DMC PLL clock frequency control register.
// default : 0x005
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL3 0x0513
// APB access control for DMC sticky control register.
// default : 0x005
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL4 0x0514
// APB access control for DMC test control register.
// default : 0x005
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL5 0x0515
// APB access control for DMC clk reset control register.
// default : 0x005
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL6 0x0516
// APB access control for DMC protection register.
// default : 0x005
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL7 0x0517
// APB access control for DMC normal register.
// default : 0x0ff
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL8 0x0518
// APB access control for DDR PHY group 0 regsiters.
// default : 0x005
// bit 23:16. PHY PRODUCTION control register enable.
// bit 10  PHY IMEM control 1: force PHY IMEM output 0. 0: normal working mode.
// bit 9   PHY DMEM control 1: force PHY DMEM output 0. 0: normal working mode.
// bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
// bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

// registers to check the security protection and watch point error information.
#define DMC_SEC_STATUS 0x051a
// bit 31~2. not used.
// bit 6
// bit 5
// bit 4
// bit 3   1 : normal security register write violation.( APB bus WDATA not equre the register
// value when APB write).  write 1 to clean this bit to 0. bit 2   sec_alert.   1 DMC secruity
// register alert function triggered. can't clean. only reset DMC can clear this bit. bit 1   write
// security violation. bit 0.  read security violation.

#define DMC_VIO_ADDR0 0x051b
// ddr0 write secure violation address[31:0].
#define DMC_VIO_ADDR1 0x051c
// bit 31:19 . not used. always 0.
// 18.    ddr0 write address secure check error.
// 17     ddr0 write address overflow or not in this DDR channel.
// 16:15  ddr0 write address bit 34:33.
// 14:0   ddr0_write violation USER BIT.
#define DMC_VIO_ADDR2 0x051d
// ddr0 read seure violation address[31:0]
#define DMC_VIO_ADDR3 0x051e
// bit 31:19 not used.
// 18.    ddr0 read address secure check error.
// 17     ddr0 read address overflow or not in this DDR channel.
// 16:15  ddr0 read address bit 34:33.
// 14:0   ddr0_read violation USER BIT.

// 16Gbyte AXI address remap tp 4Gbyte DDR address.
#define DMC_AXI2DDR0 0x0520
// for AXI address 0x0_0000_0000 ~ 0x0_1fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR1 0x0521
// for AXI address 0x0_2000_0000 ~ 0x0_3fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR2 0x0522
// for AXI address 0x0_4000_0000 ~ 0x0_5fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR3 0x0523
// for AXI address 0x0_6000_0000 ~ 0x0_7fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR4 0x0524
// for AXI address 0x0_8000_0000 ~ 0x0_9fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR5 0x0525
// for AXI address 0x0_a000_0000 ~ 0x0_bfff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR6 0x0526
// for AXI address 0x0_c000_0000 ~ 0x0_dfff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR7 0x0527
// for AXI address 0x0_e000_0000 ~ 0x0_ffff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR8 0x0528
// for AXI address 0x1_0000_0000 ~ 0x1_1fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR9 0x0529
// for AXI address 0x1_2000_0000 ~ 0x1_3fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDRA 0x052a
// for AXI address 0x1_4000_0000 ~ 0x1_5fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDRB 0x052b
// for AXI address 0x1_6000_0000 ~ 0x1_7fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDRC 0x052c
// for AXI address 0x1_8000_0000 ~ 0x1_9fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDRD 0x052d
// for AXI address 0x1_a000_0000 ~ 0x1_bfff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDRE 0x052e
// for AXI address 0x1_c000_0000 ~ 0x1_dfff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDRF 0x052f
// for AXI address 0x1_e000_0000 ~ 0x1_ffff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR10 0x0530
// for AXI address 0x2_0000_0000 ~ 0x2_1fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR11 0x0531
// for AXI address 0x2_2000_0000 ~ 0x2_3fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR12 0x0532
// for AXI address 0x2_4000_0000 ~ 0x2_5fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR13 0x0533
// for AXI address 0x2_6000_0000 ~ 0x2_7fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR14 0x0534
// for AXI address 0x2_8000_0000 ~ 0x2_9fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR15 0x0535
// for AXI address 0x2_a000_0000 ~ 0x2_bfff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR16 0x0536
// for AXI address 0x2_c000_0000 ~ 0x2_dfff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR17 0x0537
// for AXI address 0x2_e000_0000 ~ 0x2_ffff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR18 0x0538
// for AXI address 0x3_0000_0000 ~ 0x3_1fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR19 0x0539
// for AXI address 0x3_2000_0000 ~ 0x3_3fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR1A 0x053a
// for AXI address 0x3_4000_0000 ~ 0x3_5fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR1B 0x053b
// for AXI address 0x3_6000_0000 ~ 0x3_7fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR1C 0x053c
// for AXI address 0x3_8000_0000 ~ 0x3_9fff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR1D 0x053d
// for AXI address 0x3_a000_0000 ~ 0x3_bfff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR1E 0x053e
// for AXI address 0x3c_0000_0000 ~ 0x3_dfff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_AXI2DDR1F 0x053f
// for AXI address 0x3_e000_0000 ~ 0x3_ffff_ffff
// bit 31:13. not used.
// bit 12:8.  DDR base address in 128Mbyte unit. 5 bits is enough for 4 GB DDR space.
// bit 7:6.  for strip4 mode:  2'b00:  strip_postion == 2'b00 for this dmc.
// 2'b01:  strip_postion == 2'b01 for this dmc.
// 2'b10:  strip_postion == 2'b10 for this dmc.
// 2'b11:  strip_postion == 2'b11 for this dmc.
// for strip2 mode:
// 2'b00  stip_postion = 1'b0 for this dmc.
// 2'b01  stip postion = 1'b1 for this dmc.
// bit 5. rank_sel.  1 : rank1.  0 : rank0.
// bit 4  not used in P1.
// bit 3  not used in P1.
// bit 2  not used.
// bti 1:0. map mode.  2'b00. this region is no mapped to this DMC channel.
//  2'b01. this region is all maped to this DMC channel.
//  2'b10. this region is mapped to 2 DMC in interleaving mode(strip2 mode ).
//  2'b11. this region is mapped to 4 DMC in interleaving mode(strip4 mode ).

#define DMC_DDR_CTRL 0x0540
// bit 27.   0 : cavnas use 64bytes boundary
// 1 : canvas use 32bytes boundary.
// bit 24:22   3'b000 : ddr3 mode.
// 3'b001 : ddr4 mode.
// 3'b010 : lpddr3 mode.
// 3'b011 : lpddr4 mode.
// bit 21.   rank1 enable bit. if 1,  rank1 used the address map is as bit 5:3 defined.
// bit 20    DDR4 BG1 enable bit.
// bit 18:   ddrphy_16b, DDR PHY DDR SDRAM data bits width.  1: 16bits. 0 : 32 bits.
// bit 16.   ddr_16b,   1: only use 16bits data in a 32bits DDR PHY data interface. 0 : normal
// data interface. bit 7:4 :  ddr1_size.  DDR rank1 size control. 4'b0000 : DDR rank 1 is 128Mbyte.
// 4'b0001 : DDR rank 1 is 256Mbyte.
// 4'b0010 : DDR rank 1 is 512Mbyte.
// 4'b0011 : DDR rank 1 is 1Gbyte.
// 4'b0100 : DDR rank 1 is 2Gbyte.
// 4'b0101 : DDR rank 1 is 4Gbyte.
// 4'b1000 : DDR rank 1 is 192Mbyte.
// 4'b1001 : DDR rank 1 is 374Mbyte.
// 4'b1010 : DDR rank 1 is 768Mbyte.
// 4'b1011 : DDR rank 1 is 1.5Gbyte.
// 4'b1100 : DDR rank 1 is 3Gbyte.
// others :  reserved.
// bit 3:0  :  ddr0_size. DDR rank0 size control.
// 4'b0000 : DDR rank 0 is 128Mbyte.
// 4'b0001 : DDR rank 0 is 256Mbyte.
// 4'b0010 : DDR rank 0 is 512Mbyte.
// 4'b0011 : DDR rank 0 is 1Gbyte.
// 4'b0100 : DDR rank 0 is 2Gbyte.
// 4'b0101 : DDR rank 0 is 4Gbyte.
// 4'b1000 : DDR rank 1 is 192Mbyte.
// 4'b1001 : DDR rank 1 is 374Mbyte.
// 4'b1010 : DDR rank 1 is 768Mbyte.
// 4'b1011 : DDR rank 1 is 1.5Gbyte.
// 4'b1100 : DDR rank 1 is 3Gbyte.
// others :  reserved.

#define DMC_DDR_CTRL1 0x0541
// bit 31. DMC_DDR_LOCK.    1: LOCK DMC_DDR_CTRL, DMC_DDR_CTRL1, DMC_AXI2DDRx, DDR0/1_ADDRMAP_x
// registers. those register can't modified any more.
//  0: all these regsiters can be read/write by secure APB access.
// bit 30~3. not used.
// bit 6.  strict security level control for DMA channel. 1: only sec level input == region sec
// level is allowded.  0:  sec_level input >= region sec level is allow to write. bit 5:2: reserved
// for more strip control.
// 1:0. DDR strip ctrl. if axi2ddr configuration is splited to DMC.
//   2'b00 : 64Byte.  4DMCs: strip_bits = 7:6.  2 DMC: strip bit =6
//   2'b01 : 128Byte. 4DMCs: strip_bits = 8:7.  2 DMC: strip bit =7
//   2'b10 : 256Byte. 4DMCs: strip_bits = 9:8.  2 DMC: strip bit =8
//   2'b11 : 512Byte. 4DMCs: strip_bits = 10:9.  2 DMC: strip bit=9

// DDR3/4 LPDDR3/4 SDRAM address  to 32bits linear address map:
// DDR0_ADDRMAP is used to select RANK0 bank, row, col address selection.
// DDR1_ADDRMAP is used to select RANK1 bank, row, col address selection.
#define DMC_RANK0_ADDRMAP_0 0x0542
// 29:25 ca8.
// 24:20 ca7.
// 19:15 ca6.
// 14:10 ca5.
// 9:5   ca4.
// 4:0   ca3.

#define DMC_RANK0_ADDRMAP_1 0x0543
// 29:25 ra2.
// 24:20 ra1.
// 19:15 ra0.
// 14:10 ca11.
// 9:5   ca10.
// 4:0   ca9.

#define DMC_RANK0_ADDRMAP_2 0x0544
// 29:25 ra8.
// 24:20 ra7.
// 19:15 ra6.
// 14:10 ra5.
// 9:5   ra4.
// 4:0   ra3.

#define DMC_RANK0_ADDRMAP_3 0x0545
// 29:25 ra14.
// 24:20 ra13.
// 19:15 ra12.
// 14:10 ra11.
// 9:5   ra10.
// 4:0   ra9.

#define DMC_RANK0_ADDRMAP_4 0x0546
// 29:25 ra17
// 24:20 ra16
// 19:15 ba2.
// 14:10 ba1.
// 9:5   ba0.
// 4:0   ra15.

#define DMC_RANK1_ADDRMAP_0 0x0547
// 29:25 ca8.
// 24:20 ca7.
// 19:15 ca6.
// 14:10 ca5.
// 9:5   ca4.
// 4:0   ca3.

#define DMC_RANK1_ADDRMAP_1 0x0548
// 29:25 ra2.
// 24:20 ra1.
// 19:15 ra0.
// 14:10 ca11.
// 9:5   ca10.
// 4:0   ca9.

#define DMC_RANK1_ADDRMAP_2 0x0549
// 29:25 ra8.
// 24:20 ra7.
// 19:15 ra6.
// 14:10 ra5.
// 9:5   ra4.
// 4:0   ra3.

#define DMC_RANK1_ADDRMAP_3 0x054a
// 29:25 ra14.
// 24:20 ra13.
// 19:15 ra12.
// 14:10 ra11.
// 9:5   ra10.
// 4:0   ra9.

#define DMC_RANK1_ADDRMAP_4 0x054b
// 29:25 ra17
// 24:20 ra16
// 19:15 ba2
// 14:10 ba1.
// 9:5   ba0.
// 4:0   ra15.

#define DMC_SEC_TEST_STA 0x0550
// 31:20. not used.
// 19:0   the start address reserved for DMC TEST. unit 4Kbyte.
#define DMC_SEC_TEST_EDA 0x0551
// 31:20. not used.
// 19:0   the end address reserved for DMC TEST. unit 4Kbyte.
#define DMC_SEC_TEST_CTRL 0x0552
// bit 7.    1 lock bit.   if this bit = 1, the DMC_SEC_TEST_* register can't changed anymore.
// bit 6.    bist secure enable.  1: enable  dmc_test in this address.  0: dmc_test can't be used.
// bit 5:4.  for 4 DMC interleave: 00: stip postion = 2'b00;  01: strip position = 2'01; 10: strip
// position = 2'b10; 11 : stip position = 2'b11 for 2 DMC interleave mode : 00 : stip postion =
// 1'b0. 01:  stip postion = 1'b1;   10, 11. not used. bit 3:2.  3'h0  64Byte  strip size in
// interleaved mode. 3'h1  128Byte strip size in interleaved mode. 3'h2  256Byte strip size in
// interleaved mode. 3'h3  512Byte strip size in interleaved mode. bit 1:0.    2'b01   this TEST
// address range is for this DMC only 2'b10   this TEST address range is for DMC0 and DMC0
// interleaved. 2'b11   this TEST address range is for 4 DMC( DMC0~DMC3) interleaved.

//
// Closing file:  ../dmc/rtl/dmc_reg.vh
//

#endif // MMC_REG_DEFINE
