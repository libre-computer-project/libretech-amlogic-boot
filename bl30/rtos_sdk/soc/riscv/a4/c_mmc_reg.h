/*
 * Copyright (c) 2021-2022 Amlogic, Inc. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 */

// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_for_mmc_register_map_h.pl
//
// and was applied to the file
//
// Project name: a4
//
// Create time: Fri Nov  4 11:29:51 CST 2022 by chong.gu
//
// ./mmc_reg.vh
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef MMC_REG_DEFINE
#else
#define MMC_REG_DEFINE

#define MMC_Wr(addr, data) (*(volatile uint32_t *)(addr) = (data))
#define MMC_Rd(addr) (*(volatile uint32_t *)(addr))
#define writel(v, c)  (*(volatile uint32_t *)(c) = v)
#define readl(c)  (*(volatile uint32_t *)(c))

//
// Reading file:  ./mmc_reg.vh
//
//
// Reading file:  ./dmc_clk_freq.vh
//
//dmc pll and frequency domain control registers.
// -----------------------------------------------
// REG_BASE:  DMC_FREQ_REG_BASE = 0xfc00e000
// -----------------------------------------------
//        REGISTER_BASE_ADDR  32'hfc00e000
//
//              |               |            |---------->  1/(OD,OD1) -->ddr_dpll_clk_out_a
//  VCO ------> |  1/ reve[5:4] | --VCO_A--->|
//              |               |            |----inv--->  1/(OD,OD1) -->ddr_dpll_clk_out_b
#define AM_DDR_PLL_CNTL0                           ((0x0000  << 2) + 0xfc00e000)
//bit 31    : dpll_lock
//bit 29    : dpll_reset.
//bit 28    : dpll_en.
//bit 27:26 : dpll_clk_en  2'b10: pll_clock output enable. 4xclk output disable. \
						 2'b11,  pll_clock and 4xclk output enable.
			//if set ddr_freq_sel , it would replaced by AM_DDR_FREQ_CTRL bit[11:10];
//bit 25    : dpll_inv_sel.  4xclk inverter. if set ddr_freq_sel, it would replaced \
			by AM_DDR_FREQ_CTRL bit[12]
//bit 21:19 : od1; if set ddr_freq_sel, it would replaced by AM_DDR_FREQ_CTRL[6:4]
//bit 18:16 : od;  if set ddr_freq_sel, it would replaced by AM_DDR_FREQ_CTRL[2:0]
//bit 14:10 : dpll_ref_div_n
//bit 8:0   : dpll_int_num

#define AM_DDR_PLL_CNTL1                           ((0x0001  << 2) + 0xfc00e000)
//bit 18:0    : ddr_dpll_frac
#define AM_DDR_PLL_CNTL2                           ((0x0002  << 2) + 0xfc00e000)
//bit 22:20  : fref_sel
//bit 17:16  : os_ssc
//bit 15:12  : ssc_str_m
//bit 8      : ssc_en
//bit 7:4    : ssc_dep_sel
//bit 1:0    : dpll ss_mode.
#define AM_DDR_PLL_CNTL3                           ((0x0003  << 2) + 0xfc00e000)
//bit 31     : afc bypass
//bit 30     : afc clk sel
//bit 29     : code new
//bit 28     : dco_m_en
//bit 27     : dco_sdm_en
//bit 26     : div2
//bit 25     : div mode
//bit 24     : fast_lock mode
//bit 23     : fb_pre_div
//bit 22     : filter_mode
//bit 21     : fix_en
//bit 20     : freq_shift_en
//bit 19     : load
//bit 18     : load_en
//bit 17     : lock_f
//bit 16     : pulse_width_en
//bit 15     : sdmnc_en
//bit 14     : sdmnc_mode
//bit 13     : sdmnc_range
//bit 12     : tdc_en
//bit 11     : tdc_mode_sel
//bit 10     :  wait_en

#define AM_DDR_PLL_CNTL4                           ((0x0004  << 2) + 0xfc00e000)
//bit 1:0    : pfd_gain
//bit 7:4    : filter_pvt1
//bit 11:8   : filter pvt2
//bit 13:12  : acq_gain
//bit 18:16  : lambda0
//bit 27:24  : rou
//bit 31:28  : alpha
#define AM_DDR_PLL_CNTL5                           ((0x0005  << 2) + 0xfc00e000)
//bit
//bit 30:28  : adj_vco_ldo
//bit 27:24  : lm_w
//bit 21:16  : lm_s
//bit 15:6   : reve[15:6]
//bit 5:4.   : reve[5:4] for chan_A, chan_B phase control. if freq =1, it would \
				replaced by AM_DDR_FREQ_CTRL bit[11:10];
//bit 3:0    : reve[3:0]

#define AM_DDR_PLL_CNTL6                           ((0x0006  << 2) + 0xfc00e000)
//bit 31:30  : afc_hold_t
//bit 29:28  : lkw_sel
//bit 27:26  : dco_sdm_clk_sel
//bit 25:24  : afc_in
//bit 23:22  : afc_nt
//bit 21:20  : vc_in
//bit 19:18  : lock_long
//bit 17:16  : freq_shift_v
//bit 15     : not used.
//bit 14:12  : data_sel
//bit 10:8   : sdmnc_ulms
//bit 6:0    : sdmnc_power

#define AM_DDR_PLL_STS                             ((0x0007  << 2) + 0xfc00e000)
//bit 31     : DDR_PLL_LOCK
//bit 30     : lock_a
//bit 29     : afc_done
//bit 22:16  : sdmnc_monitor
//bit 9:0    : out_rsv

#define AM_DDR_CLK_CNTL                            ((0x0008  << 2) + 0xfc00e000)
//bit 31     Channel 0 ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion.
			// whenever change the DDR_PLL frequency, disable the clock, after the \
			DDR_PLL locked, then enable it again.
//bit 30.    channel 0 ddr_pll_prod_test_en.  enable the clock to clock/32 which to \
			clock frequency measurement and production test pin.
//bit 29.    pll production  clock output selection. 1: select ddr_dpll_clk_out_b. \
			0 : select ddr_dpll_clk_out_a;
//bit 28.    clock generation logic soft reset_n. 0: reset. 1: normal mode.
//bit 27.    channel 0 phy_4xclk phase inverter..
//bit 25.    Channel 0 DDRPHY DfiClk/DfiCtlClk/DMC clock selection.  1:  AM_PLL clk \
			output /2.  0: directly output from AM_PLL .
//bit 24.    Channel 0 AM_PLL CLK output /2 function.   1: enable.  0: disable. \
			if try to use this clkoutput/2 function.

//bit 23     Channel 1 ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion.
			// whenever change the DDR_PLL frequency, disable the clock, after \
			the DDR_PLL locked, then enable it again.
//bit 22.    channel 1 ddr_pll_prod_test_en.  enable the clock to clock/32 which \
			to clock frequency measurement and production test pin.
//bit 21:20. not used.
//bit 19.    channel 1 phy_4xclk phase inverter..
//bit 17.    Channel 1 DDRPHY DfiClk/DfiCtlClk/DMC clock selection. 1: AM_PLL clk \
			output /2.  0: directly output from AM_PLL .
//bit 16.    Channel 1 AM_PLL CLK output /2 function. 1: enable.  0: disable. \
			if try to use this clkoutput/2 function.
//bit 12. ddr1 def_clk_sel   1: select reference clock as LPDDR4-PHY clock.  0: normal.
//bit 11.  ddr1 default clock enable. enable PCLK as LPDDR4_PHY clock. 0: disable.
//bit 10. enable ddr channel 1 dmc_clk.
//bit 9.  enable LPDDR4-PHY channel 1 DfiClk.
//bit 8.  enable LPDDR4-PHY channel 1 DfiCtlClk.
//bit 4.  ddr0 def_clk_sel   1: select reference clock as LPDDR4-PHY clock.  0: normal.
//bit 3.  ddr0 default clock enable. enable PCLK as LPDDR4_PHY clock. 0: disable.
//bit 2.  enable ddr channel 0 dmc_clk.
//bit 1.  enable LPDDR4-PHY channel 0 DfiClk.
//bit 0.  enable LPDDR4-PHY channel 0 DfiCtlClk.

#define AM_DDR_PHY_CTRL                            ((0x0009  << 2) + 0xfc00e000)
// LPDDR4 power on reset need to special combination of PwrOkIn and phy_reset_n.
// please check the PHY PUB data book for detail.
//bit 31:8.  Not used.
//bit 7.   use dmc_clk_freq to control DDR-PHY channel 1 refresh/retrainning/freqency \
			change/phy power etc.
//bit 6.   use dmc_clk_freq to control DDR-PHY channel 0 refresh/retrainning/freqency \
			change/phy power etc.
//bit 5.   DDR_PHY 1 PwrOkIn pin.
//bit 4.   DDR_PHY 0 PwrOkIn pin.
//bit 3.   DDR_PHY 1 APB soft reset_n.
//bit 2.   DDR_PHY 1 phy_reset_n.
//bit 1.   DDR_PHY 0 APB soft reset_n.
//bit 0.   DDR_PHY 0 phy_reset_n.

#define AM_DDR_FREQ_CTRL                           ((0x000c  << 2) + 0xfc00e000)
//bit 31.  write trigger the DDR frequency change prodeure.  read =0 the freqency change done.
//bit 30     currunt FREQ selection.  it can forced to change to select which freqency \
		to select, or it can auto changed by FREQ change hardware.
//bit 29     next freq for frequency change.
//bit 12.    ddr_dpll_inv_sel in frequency1 for 4xclk inverter.
//bit 11:10. ddr_dpll_clk_en in frequency1 for 4xclk and clock output.
//bit 9:8. pll_reseve in frequency1. pll_reseve[5:4] used to tune 2 DMC channel clock phase.
//bit 6:4   OD1 number in frequency 1.
//bit 2:0.  OD  number in frequency 1.

#define AM_DDR_TIMING_F0                           ((0x000d  << 2) + 0xfc00e000)
//freqency 0  auto refresh timing.
//bit 7:0. T100ns. how many clock cycle for 100ns.
//bit15:8. refresh period in 100ns.
#define AM_DDR_TIMING_F1                           ((0x000e  << 2) + 0xfc00e000)
//freqency 1  auto refresh timing.
//bit 7:0. T100ns. how many clock cycle for 100ns.
//bit15:8. refresh period in 100ns.
#define AM_DDR_TIMING_CFG                          ((0x000f  << 2) + 0xfc00e000)
//bit 31.  cfg ddr timing.  write 1 to save the timing parameters to ddr clock domain.
//bit 30.  dmc_clk_freq control the LPDDR4 retraining.
//bit 29.  dmc_clk_freq control the auto refresh timing.
//bit 28:24. not use.
//bit 23:0.  lpddr4 phy retraining timer counter in 100ns.

//
// Closing file:  ./dmc_clk_freq.vh
//
//
// Reading file:  ../mmc_lp4/dmc/rtl/dmc_reg.vh
//

// -----------------------------------------------
// REG_BASE:  DMC_FREQ_REG_BASE = 0xfe036000
// -----------------------------------------------
//        REGISTER_BASE_ADDR  32'hfe036000

#define DMC_REQ_CTRL                               ((0x0000  << 2) + 0xfe036000)
  //bit 7.   enable dmc request of axibus chan 7.
  //bit 6.   enable dmc request of axibus chan 6.
  //bit 5.   enable dmc request of axibus chan 5.  reserved for dmc_test.
  //bit 4.   enable dmc request of axibus chan 4.
  //bit 3.   enable dmc request of axibus chan 3.
  //bit 2.   enable dmc request of axibus chan 2.
  //bit 1.   enable dmc request of axibus chan 1.
  //bit 0.   enable dmc request of axibus chan 0.  CPU async interface.

//DMC CLK and RESET domain register. please check DMC_SEC_APB_CTRLx register for access details.
#define DMC_SOFT_RST                               ((0x0001  << 2) + 0xfe036000)
  //bit 31~8. reserved for future.
  //bit 7:0. 8 software reset for 8 axi ports

#define DMC_SOFT_RST1                              ((0x0002  << 2) + 0xfe036000)
  //To reset the Async interface, you need to disable the interface both clock domain, \
		then reset both n_clk and m_clk domain
  //bit 31~0 not used.  all channels are synchronous interface.

#define DMC_SOFT_RST2                              ((0x0003  << 2) + 0xfe036000)
  //bit 31~11.  reserved for future.
  //bit 10  DMC DFI cmd soft reset_n
  //bit 9   DMC DFI MISC soft reset_n
  //bit 8   DMC DFI data soft reset_n
  //bit 7   DMC DFI dcu soft reset_n
  //bit 6   DMC siu soft reset_n
  //bit 5.  DMC test soft reset_n.  0 : reset. 1 : normal working mode.
  //bit 4.  DMC low power control module soft reset_n.    0 : reset. 1 : normal working mode.
  //bit 3.  DMC QOS monitor module soft reset_n.   0 : reset. 1 : normal working mode.
  //bit 2.  DMC register module soft reset_n.       0 : reset. 1 : normal working mode.
  //bit 1.  not used.
  //bit 0.  DMC command buffers and command generation modules soft reset.  0 = reset. 1:

#define DMC_RST_STS1                               ((0x0004  << 2) + 0xfe036000)
//31~8.  not used.
//7~0.   Read only.  the DMC_SOFT_RST1 signal in n_clk domain. the purpose of this
	//register is when one of the 2 clocks is too slow or too fast, we can read this
	//register to make sure another clock domain reset is done.
#define DMC_CLKG_CTRL0                             ((0x0006  << 2) + 0xfe036000)
  //bit 31:8  not used.
  //bit 7:0.  enable the 8 axi interfaces  n_clk auto clock gating function. \
			each 1 bit for one interface.
#define DMC_CLKG_CTRL1                             ((0x0007  << 2) + 0xfe036000)
  //bit 31:8. not used.
  //bit 7:0.  force to disable the 16 axi interfaces n_clk. each 1 bit for one interface.

#define DMC_CLKG_CTRL2                             ((0x0008  << 2) + 0xfe036000)
  //bit 12  enalbe auto clock gating for awcmdfifo.
  //bit 11  enalbe auto clock gating for arcmdfifo.
  //bit 10  enable auto clock gating for dfi command generation
  //bit 9   enable auto clock gating for dram controller
  //bit 8   enable auto clock gating for dfi data path.
  //bit 7.  enalbe auto clock gating for write rsp generation.
  //bit 6.  enalbe auto clock gating for read rsp generation.
  //bit 5.  enalbe auto clock gating for ddr0 command filter.
  //bit 4.  enalbe auto clock gating for ddr0 write reorder buffer.
  //bit 3.  enalbe auto clock gating for ddr0 write data buffer.
  //bit 2.  enalbe auto clock gating for ddr0 read reorder buffer.
  //bit 1:0.  not used.

#define DMC_CLKG_CTRL3                             ((0x0009  << 2) + 0xfe036000)
  //bit 12  force to disable the clock of awcmdfifo.
  //bit 11  force to disable the clock of arcmdfifo.
  //bit 10  force to disable the clock of dfi command generation
  //bit 9   force to disable the clock of dram controller
  //bit 8   force to disable the clock of dfi data path.
  //bit 7. force to disalbe the clock of write rsp generation.
  //bit 6. force to disalbe the clock of read rsp generation.
  //bit 5.  force to disalbe the clock of  command filter.
  //bit 4.  force to disalbe the clock of  write reorder buffer.
  //bit 3.  force to disalbe the clock of write data buffer.
  //bit 2.  force to disalbe the clock of read reorder buffer.
  //bit 1:0. not used.


#define DMC_MON_CTRL0                              ((0x0010  << 2) + 0xfe036000)
   //bit 31.   qos_mon_en.    write 1 to trigger the enable. polling this bit 0, \
				means finished.  or use interrupt to check finish.
   //bit 30.   qos_mon interrupt clear.  clear the qos monitor result. \
				read 1 = qos mon finish interrupt.
#define DMC_MON_TIMER                              ((0x0011  << 2) + 0xfe036000)
 // timer for the monitor period.
#define DMC_MON_ALL_IDLE_CNT                       ((0x0012  << 2) + 0xfe036000)
  // at the test period,  the whole MMC all channel IDLE time. unit, dmc clock.
#define DMC_MON_ALL_BW                             ((0x0013  << 2) + 0xfe036000)
  // at the test period,  the whole MMC granted data cycles. units one data clock cycle = 16bytes.
#define DMC_MON_ALL16_BW                           ((0x0014  << 2) + 0xfe036000)
  // at the test period,  the whole MMC granted data cycles which goes to 16bits \
		ddr. units one data clock cycle = 16byte.

#define DMC_MON0_CTRL                              ((0x0018  << 2) + 0xfe036000)
  //BW monitor 0 address range ctrol.  start address <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON0_CTRL1                             ((0x0019  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 0 channel select.   8 ambus port and 16 AXI port selection. \
		1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of \
		this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON0_CTRL2                             ((0x001a  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 0 port select for the selected channel.
#define DMC_MON0_BW                                ((0x001b  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the selected channel and ports.

#define DMC_MON1_CTRL                              ((0x001c  << 2) + 0xfe036000)
  //BW monitor 1 address range ctrol.  start address <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON1_CTRL1                             ((0x001d  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 1 channel select.   8 ambus port and 16 AXI port \
		selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid \
		of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON1_CTRL2                             ((0x001e  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 1 port select for the selected channel.
#define DMC_MON1_BW                                ((0x001f  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the selected channel and ports.

#define DMC_MON2_CTRL                              ((0x0020  << 2) + 0xfe036000)
  //BW monitor 2 address range ctrol.  start address <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON2_CTRL1                             ((0x0021  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 2 channel select.   8 ambus port and 16 AXI port \
		selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid \
		of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON2_CTRL2                             ((0x0022  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 2 port select for the selected channel.
#define DMC_MON2_BW                                ((0x0023  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the selected channel and ports.

#define DMC_MON3_CTRL                              ((0x0024  << 2) + 0xfe036000)
  //BW monitor 3 address range ctrol.  start address <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON3_CTRL1                             ((0x0025  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 3 channel select.   8 ambus port and 16 AXI port \
		selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid \
		of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON3_CTRL2                             ((0x0026  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 3 port select for the selected channel.
#define DMC_MON3_BW                                ((0x0027  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the selected channel and ports.

#define DMC_MON4_CTRL                              ((0x0028  << 2) + 0xfe036000)
  //BW monitor 4 address range ctrol.  start address <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON4_CTRL1                             ((0x0029  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 4 channel select.   8 ambus port and 16 AXI port \
	selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any \
	subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON4_CTRL2                             ((0x002a  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 4 port select for the selected channel.
#define DMC_MON4_BW                                ((0x002b  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the selected channel and ports.

#define DMC_MON5_CTRL                              ((0x002c  << 2) + 0xfe036000)
  //BW monitor 5 address range ctrol.  start address <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON5_CTRL1                             ((0x002d  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 5 channel select.   8 ambus port and 16 AXI port \
		selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid \
		of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON5_CTRL2                             ((0x002e  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 5 port select for the selected channel.
#define DMC_MON5_BW                                ((0x002f  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the selected channel and ports.

#define DMC_MON6_CTRL                              ((0x0030  << 2) + 0xfe036000)
  //BW monitor 6 address range ctrol.  start address <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON6_CTRL1                             ((0x0031  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 6 channel select.   8 ambus port and 16 AXI port \
		selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid \
		of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON6_CTRL2                             ((0x0032  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 6 port select for the selected channel.

#define DMC_MON6_BW                                ((0x0033  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the selected channel and ports.

#define DMC_MON7_CTRL                              ((0x0034  << 2) + 0xfe036000)
  //BW monitor 7 address range ctrol.  start address <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON7_CTRL1                             ((0x0035  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 7 channel select.   8 ambus port and 16 AXI port \
	selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid \
	of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON7_CTRL2                             ((0x0036  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 7 port select for the selected channel.
#define DMC_MON7_BW                                ((0x0037  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the selected channel and ports.




#define DMC_CMD_FILTER_CTRL0                       ((0x004a  << 2) + 0xfe036000)
#define DMC_CMD_FILTER_CTRL1                       ((0x0040  << 2) + 0xfe036000)
#define DMC_CMD_FILTER_CTRL2                       ((0x0041  << 2) + 0xfe036000)
  //31:24. keep the bank active if there's urgent level 3 read bank hit request.
  //23:16. keep the bank active if there's urgent level 2 read bank hit request.
  //15:8.  keep the bank active if there's urgent level 1 read bank hit request.
  //7:0.   keep the bank active if there's urgent level 0 read bank hit request.

#define DMC_CMD_FILTER_CTRL3                       ((0x0042  << 2) + 0xfe036000)
  //bit 31.    force wbuf empty.
  //bit 30:26  wbuf high level number
  //bit 25:21  wbuf mid  level number
  //bit 20:16  wbuf low level number
  //bit 14:10  rbuf high level number
  //bit 9:5    rbuf middle level number
  //bit 4:0    rbuf low level number

#define DMC_CMD_FILTER_CTRL4                       ((0x0043  << 2) + 0xfe036000)
  //bit 29:25.  tITW.long
  //bit 24:20.  tITW. short
  //bit 19:12   tAP auto precharge the bank not used if idle that long time.
  //bit 11:6    write to read accesses if there write hit request.
  //bit 5:0     read to write accesses if there write hit request.

#define DMC_CMD_FILTER_CTRL5                       ((0x0044  << 2) + 0xfe036000)
//bit 31:24   Once ddr data bus switch to read, the maxmum read command \
	number to give up the bus when there's write request pending for write buffer.
//bit 23:16   Once ddr data bus switch to write, the maxmum write command \
	number to give up the bus when there's read request pending too long.
//bit 15:8.   Once ddr data bus switch to read, the minimum read command \
	number to transfer back to write stage if there's still pending read request.
//bit 7:0.    Once ddr data bus switch to write, the minimum write command \
	number to transfer back to read stage if there's still pending write request.

#define DMC_CMD_FILTER_CTRL6                       ((0x0045  << 2) + 0xfe036000)
  //bit 31:24   write urgent 3 request pending hold num.
  //bit 23:16   write urgent 2 request pending hold num.
  //bit 15:8.   write urgent 1 request pending hold num.
  //bit 7:0.    write urgent 0 request pending hold num.

#define DMC_CMD_FILTER_CTRL7                       ((0x0046  << 2) + 0xfe036000)
  //bit 31:24.  aw_req_pending signal assertion after wbuf full.
  //bit 23:16   aw_req_pending signal hold how long if wbuf not full.
  //bit 15:8    write to read waiting cycles if there write hit request.
  //bit 7:0     read to write waiting cycles if there write hit request.

#define DMC_CMD_FILTER_CTRL8                       ((0x0047  << 2) + 0xfe036000)
  //bit 31:8    reserved.
  //bit 7:0     rank limit to change to another rank.


#define DMC_CMD_BUFFER_CTRL                        ((0x0048  << 2) + 0xfe036000)
  //bit 31:26  total write buffer number. default 32.
  //bit 25:20  total read buffer number. default 32.
  //bit 19:8    reserved.
  //bit 7:0    aw_pending_inc_num.  incease write ugent level 1 when write \
			command waiting to in write buffer that long.

#define DMC_CMD_BUFFER_CTRL1                       ((0x0049  << 2) + 0xfe036000)
  //bit 29:24  read buffer number in non-urgent request.
  //bit 23:16  read buffer bank miss watch dog threshold.
  //bit 15:12  read buffer urgent level 3 counter inc weight.
  //bit 11:8   read buffer urgent level 2 counter inc weight.
  //bit 7:4    read buffer urgent level 1 counter inc weight.
  //bit 3:0    read buffer urgent level 0 counter inc weight.

#define DMC_2ARB_CTRL                              ((0x004c  << 2) + 0xfe036000)
  //32:24. Waiting limit to use the highest urgent level in the pipelines.
  //23:0.  Not used.

#define DMC_VERSION                                ((0x004f  << 2) + 0xfe036000)
   //read only 32'h01000016  for A4

#define DMC_AXI0_CHAN_CTRL                         ((0x0080  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI0_HOLD_CTRL                         ((0x0081  << 2) + 0xfe036000)
//31:24 write hold num.   max outstanding request number.
//23:16  write hold release num. if the outstanding request == hold num, then
	//hold this request unless the outstanding request number bellow the hold release
	//number, then continue to request.
//15:8 read hold num.   max outstanding request number.
//7:0  read hold release num. if the outstanding request == hold num, then
	//hold this request unless the outstanding request number bellow the hold release
	//number, then continue to request.

#define DMC_AXI0_CHAN_CTRL1                        ((0x0082  << 2) + 0xfe036000)
  //31:28.  FIQ  chan0 QOS setting.
  //27:24.  IRQ  chan0 QOS setting.
  //23:23.  chan0 write QOS with VPU request.
  //19:16.  chan0 write QOS with other request .
  //15:12.  chan0 write QOS with none other requests.
  //11:8.   chan0 read QOS with VPU request.
  //7:4.    chan0 read QOS with other request .
  //3:0.    chan0 read QOS with none other requests.

#define DMC_AXI0_CHAN_CTRL2                        ((0x0083  << 2) + 0xfe036000)
 //bit 31:4.  Not used.
 //bit 3.     CPU FIQ QOS ctrl_en.
 //bit 2.     CPU IRQ QOS ctrl_en.
 //bit 1.     CPU read channel auto QOS enable (based on other traffic).
 //bit 0.     CPU write channel auto QOS enable( based on other traffic).


#define DMC_AXI1_CHAN_CTRL                         ((0x0084  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight

#define DMC_AXI1_HOLD_CTRL                         ((0x0085  << 2) + 0xfe036000)
//bit 31:24 write hold num.   max outstanding request number.
//bit 23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number bellow the
	//hold release number, then continue to request.
//bit 15:8 read hold num.   max outstanding request number.
//bit 7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number bellow the
	//hold release number, then continue to request.
#define DMC_AXI1_CHAN_CTRL1                        ((0x0086  << 2) + 0xfe036000)


#define DMC_AXI2_CHAN_CTRL                         ((0x0088  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight

#define DMC_AXI2_HOLD_CTRL                         ((0x0089  << 2) + 0xfe036000)
//31:24 write hold num.   max outstanding request number.
//23:16  write hold release num. if the outstanding request == hold num, then
	//hold this request unless the outstanding request number bellow the hold release
	//number, then continue to request.
//15:8 read hold num.   max outstanding request number.
//7:0  read hold release num. if the outstanding request == hold num, then
	//hold this request unless the outstanding request number bellow the hold release
	//number, then continue to request.
#define DMC_AXI2_CHAN_CTRL1                        ((0x008a  << 2) + 0xfe036000)
//bit 31:29. not used.
//bit 28:20. when write/read side band signal used to block other request. \
			configure which master we can block. each bit for one master.
			//Note. don't block vpu itself and  CPU or other urgent request.
//bit 19. use side band write urgent control signal to control AWQOS.  1: enabe. 0: disable.
//bit 18. use side band read  urgent control signal to control ARQOS.  1: enabe. 0: disable.
//bit 17. use side band write urgent control signal to block other master request. \
	1 : enable. 0 disable.
//bit 16. use side band read urgent control signal to block other master request. \
	1 : enable. 0 disable.
//bit 15:12.  the AWQOS value when side band write urgent control signal = 1 \
	while bit 19 enabled.
//bit 11:8.   the ARQOS value when side band read  urgent control signal = 1 \
	while bit 18 enabled.
//bit 7:0.    Not used.


#define DMC_AXI3_CHAN_CTRL                         ((0x008c  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI3_HOLD_CTRL                         ((0x008d  << 2) + 0xfe036000)
//31:24 write hold num.   max outstanding request number.
//23:16  write hold release num. if the outstanding request == hold num, then hold
	//this request unless the outstanding request number bellow the hold release number,
	//then continue to request.
//15:8 read hold num.   max outstanding request number.
//7:0  read hold release num. if the outstanding request == hold num, then hold this
	//request unless the outstanding request number bellow the hold release number, then
	//continue to request.
#define DMC_AXI3_CHAN_CTRL1                        ((0x008e  << 2) + 0xfe036000)

#define DMC_AXI4_CHAN_CTRL                         ((0x0090  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI4_HOLD_CTRL                         ((0x0091  << 2) + 0xfe036000)
//31:24 write hold num. max outstanding request number.
//23:16  write hold release num. if the outstanding request == hold num, then hold
	//this request unless the outstanding request number bellow the hold release number,
	//then continue to request.
//15:8 read hold num.   max outstanding request number.
//7:0  read hold release num. if the outstanding request == hold num, then hold this
	//request unless the outstanding request number bellow the hold release number, then
	//continue to request.
#define DMC_AXI4_CHAN_CTRL1                        ((0x0092  << 2) + 0xfe036000)

#define DMC_AXI5_CHAN_CTRL                         ((0x0094  << 2) + 0xfe036000)
  //not used.
#define DMC_AXI5_HOLD_CTRL                         ((0x0095  << 2) + 0xfe036000)
//31:24 write hold num.   max outstanding request number.
//23:16  write hold release num. if the outstanding request == hold num, then hold
	//this request unless the outstanding request number bellow the hold release number,
	//then continue to request.
//15:8 read hold num.   max outstanding request number.
//7:0  read hold release num. if the outstanding request == hold num, then hold this
	//request unless the outstanding request number bellow the hold release number, then
	//continue to request.


#define DMC_AXI6_CHAN_CTRL                         ((0x0098  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI6_HOLD_CTRL                         ((0x0099  << 2) + 0xfe036000)
//31:24 write hold num.   max outstanding request number.
//23:16  write hold release num. if the outstanding request == hold num, then hold
	//this request unless the outstanding request number bellow the hold release number,
	//then continue to request.
//15:8 read hold num.   max outstanding request number.
//7:0  read hold release num. if the outstanding request == hold num, then hold this
	//request unless the outstanding request number bellow the hold release number, then
	//continue to request.
#define DMC_AXI6_CHAN_CTRL1                        ((0x009a  << 2) + 0xfe036000)

#define DMC_AXI7_CHAN_CTRL                         ((0x009c  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI7_HOLD_CTRL                         ((0x009d  << 2) + 0xfe036000)
//31:24 write hold num.   max outstanding request number.
//23:16  write hold release num. if the outstanding request == hold num, then hold
	//this request unless the outstanding request number bellow the hold release number,
	//then continue to request.
//15:8 read hold num.   max outstanding request number.
//7:0  read hold release num. if the outstanding request == hold num, then hold this
	//request unless the outstanding request number bellow the hold release number, then
	//continue to request.
#define DMC_AXI7_CHAN_CTRL1                        ((0x009e  << 2) + 0xfe036000)

#define DMC_AXI0_CHAN_STS                          ((0x00a0  << 2) + 0xfe036000)
  // AXI0 Async interface status.
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.   not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI1_CHAN_STS                          ((0x00a1  << 2) + 0xfe036000)
  // Mali virtual channel status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  write data fifo counter.
  //7:0.   mali master side wddata valid for AWVALID counter.
#define DMC_AXI2_CHAN_STS                          ((0x00a2  << 2) + 0xfe036000)
  //AXI chan2 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI3_CHAN_STS                          ((0x00a3  << 2) + 0xfe036000)
  //AXI chan3 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI4_CHAN_STS                          ((0x00a4  << 2) + 0xfe036000)
  //AXI chan4 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI5_CHAN_STS                          ((0x00a5  << 2) + 0xfe036000)
  //AXI chan4 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  write address without read data counter.
  //7:0.  not used.
#define DMC_AXI6_CHAN_STS                          ((0x00a6  << 2) + 0xfe036000)
  //AXI channel 6 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI7_CHAN_STS                          ((0x00a7  << 2) + 0xfe036000)
  //AXI channel 7 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.


#define DMC_AXI0_CHAN_STS1                         ((0x00b0  << 2) + 0xfe036000)
  //7:4. CPU FIQ STS
  //3:0. CPU IRQ STS.

#define DMC_CHAN_STS                               ((0x00bc  << 2) + 0xfe036000)
  //AXI0  is first CPU and Mali combined channel from CCI-400 directly. \
		The first 2Gbyte address will go through this channel.
  //AXI10  is the second CPU, Mali channel combined with NNA  from NIC-400. \
		The upper 2Gbyte address will go through this channel.
  // read only register.
  // the second mali and NNA channel IDLE.
  // the second CPU channel IDLE.
  // the first mali channel IDLE.
  // the first CPU channel IDLE.
  //bit 31:27   not used. always 1
  //bit 26      ddr0 write data buffer idle. 1 : idle 0: busy.
  //bit 25      always 1.
  //bit 24      ddr0 wbuf idle.              1 : idle 0: busy.
  //bit 23:8    not used.   always 1.
  //bit 7       AXI channel7 idle.
  //bit 6       AXI channel6 idle.
  //bit 5       AXI channel5 idle.
  //bit 4       AXI channel4 idle.
  //bit 3       always 1.
  //bit 2       AXI channel2 idle.
  //bit 1       always 1.
  //bit 0       AXI channel0 idle.

#define DMC_MON_IRQ_STS                            ((0x00db  << 2) + 0xfe036000)
  //bit 31:1   Not used.
  //bit 0 :    QOS Monitor interrupt flag.  1: means there's QOS monitor interrupt. \
				write 1 to clean this interrupt.




//DMC protection function domain register.
// one protection can chose upto 4 master IDs to monitors.
//for these 4 master IDs, you can chose either include them. or exclude them.
#define DMC_PROT0_STA                              ((0x00e0  << 2) + 0xfe036000)
  //31:20. not used.
  //19:0   protection 0 start address . unit 4Kbyte.
#define DMC_PROT0_EDA                              ((0x00e1  << 2) + 0xfe036000)
  //31:20. not used.
  //19:0   protection 0 end address. unit 4Kbyte.
#define DMC_PROT0_CTRL                             ((0x00e2  << 2) + 0xfe036000)
  //bit 27.  protection 0 write monitor enable.
  //bit 26.  protection 0 read monitor enable.
  //bit 8.   monitor policy:  1 include the ids.  0: exclude the IDS.
  //bit 3.   ID3 enable.
  //bit 2.   ID2 enable.
  //bit 1.   ID1 enable.
  //bit 0.   ID0 enable.
#define DMC_PROT0_CTRL1                            ((0x00e3  << 2) + 0xfe036000)
  //bit 31:24.   ID3 id number.
  //bit 23:16.   ID2 id number.
  //bit 15:8     ID1 id number.
  //bit 7:0.     ID0 id number.
#define DMC_PROT1_STA                              ((0x00e4  << 2) + 0xfe036000)
  //bit 31:20. not used.
  //bit 19:0   protection 1 start address . unit 4Kbyte.
#define DMC_PROT1_EDA                              ((0x00e5  << 2) + 0xfe036000)
  //bit 31:20. not used.
  //bit 19:0   protection 1 end address. unit 4Kbyte.
#define DMC_PROT1_CTRL                             ((0x00e6  << 2) + 0xfe036000)
  //bit 27.  protection 1 write monitor enable.
  //bit 26.  protection 1 read monitor enable.
  //bit 8.   monitor policy:  1 include the ids.  0: exclude the IDS.
  //bit 3.   ID3 enable.
  //bit 2.   ID2 enable.
  //bit 1.   ID1 enable.
  //bit 0.   ID0 enable.
#define DMC_PROT1_CTRL1                            ((0x00e7  << 2) + 0xfe036000)
  //bit 31:24.   ID3 id number.
  //bit 23:16.   ID2 id number.
  //bit 15:8     ID1 id number.
  //bit 7:0.     ID0 id number.

#define DMC_PROT_VIO_0                             ((0x00e8  << 2) + 0xfe036000)
  //protection write violation low 32bits address.
#define DMC_PROT_VIO_1                             ((0x00e9  << 2) + 0xfe036000)
  //bit 23.     protection 1 violation.
  //bit 22.     protection 0 violation.
  //bit 21:15.  7'b0.
  //bit 14:0    AWUSER  please refer  AXI bus AWUSER bits define.
#define DMC_PROT_VIO_2                             ((0x00ea  << 2) + 0xfe036000)
  //protection read violation low 32bits address. ARADDR[31:0].
#define DMC_PROT_VIO_3                             ((0x00eb  << 2) + 0xfe036000)
  //bit 23.     protection 1 violation.
  //bit 22.     protection 0 violation.
  //bit 21:15.  7'b0.
  //bit 14:0    ARUSER  please refer  AXI bus AWUSER bits define.

#define DMC_PROT_IRQ_CTRL_STS                      ((0x00ec  << 2) + 0xfe036000)
  //bit 2.   protection IRQ enable.
  //bit 1.   read for write prot violation. write 1 to clean the write protection \
								status and interrupt.
  //bit 0.   read for read prot violation. write 1 to clean the read protection \
								status and interrupt.

#define DMC_PROT0_CTRL2                            ((0x00ed  << 2) + 0xfe036000)
  //bit 19.  prot0 SubID3 en for prot0 id3.
  //bit 18.  prot0 SubID2 en for prot0 id2.
  //bit 17.  prot0 SubID1 en for prot0 id1.
  //bit 16.  prot0 SubID0 en for prot0 id0.
  //bit 15:12.prot0 subid3 id number.
  //bit 11:8. prot0 subid2 id number.
  //bit 7:4.  prot0 subid1 id number.
  //bit 3:0.  prot0 subid0 id number.
#define DMC_PROT1_CTRL2                            ((0x00ee  << 2) + 0xfe036000)
  //bit 19.   prot1 SubID3 en for prot0 id3.
  //bit 18.   prot1 SubID2 en for prot0 id2.
  //bit 17.   prot1 SubID1 en for prot0 id1.
  //bit 16.   prot1 SubID0 en for prot0 id0.
  //bit 15:12.prot1 subid3 id number.
  //bit 11:8. prot1 subid2 id number.
  //bit 7:4.  prot1 subid1 id number.
  //bit 3:0.  prot1 subid0 id number.

//SIU register.
//there's 2 set of timing DDR timing parameter for 2 set of DDR freqency parameter.
//when change frequency, the hardware would automatically select one of these two set of \
	timing parameter
//DMC_DRAM_* is for Frequency set 0.
//DMC_NFQ_* is for Freqency set 1.
#define DMC_DRAM_TMRD                              ((0x0100  << 2) + 0xfe036000)
   //bit 4:0.  tMRD. //MR command cycles, in DDR3/4.  in LPDDR4, it should be value of tMRW
#define DMC_DRAM_TRFC                              ((0x0101  << 2) + 0xfe036000)
   //bit 25:16 tRFCpb
   //bit 9:0   tRFCab
#define DMC_DRAM_TRP                               ((0x0102  << 2) + 0xfe036000)
   //bit 21:16.  tRP for precharge all banks.
   //bit 5:0.    tRP for precharge one bank.
#define DMC_DRAM_TRTW                              ((0x0103  << 2) + 0xfe036000)
   //bit 31:6:   Not used.
   //bit 5:0     DDR3/4 mode : tRTW.
   // For LPDDR4 .  The total read command -> write command = (RL + BL/2 - tWODTON) + \
			TDQSCK_MAX + tWPRE + RD(tRPST).
   //                 tRTW = TDQSCK_max + tWPRE + tRD(tRPST)  + (delay margin)
#define DMC_DRAM_TCL                               ((0x0104  << 2) + 0xfe036000)
  //bit 5:0  tCL/tRL. read latency.
#define DMC_DRAM_TCWL                              ((0x0105  << 2) + 0xfe036000)
  //bit 5:0.  CWL:  write latency.
#define DMC_DRAM_TRAS                              ((0x0106  << 2) + 0xfe036000)
  //bit 7:0.  tRAS.  minimum active to precharge time for same bank.
#define DMC_DRAM_TRC                               ((0x0107  << 2) + 0xfe036000)
  //bit 7:0.  tRC.  minimum active to active time for same bank.
#define DMC_DRAM_TRCD                              ((0x0108  << 2) + 0xfe036000)
  //bit 7:0  tRCD  active to read/write timing for same bank.
#define DMC_DRAM_TRRD                              ((0x0109  << 2) + 0xfe036000)
  //bit 21:16.  tRRD_l  active bank A to active B in same band group for DDR4.
  //bit 5:0.    tRRD/tRRD_s   active bank A to active bank b time.
		//tRRD_s:   active bank A to active bank b in different bank grousp for DDR4.
#define DMC_DRAM_TFAW                              ((0x010a  << 2) + 0xfe036000)
  //bit 8:0   tFAW.  four active command windows
#define DMC_DRAM_TRTP                              ((0x010b  << 2) + 0xfe036000)
  //bit 5:0  tRTP. in LPDDR5 should be tBL + tRBTP
#define DMC_DRAM_TWR                               ((0x010c  << 2) + 0xfe036000)
  //bit 5:0 tWR.
#define DMC_DRAM_TWTR                              ((0x010d  << 2) + 0xfe036000)
  //bit 21:16 tWTR_l   For DDR4 WTR_l.  FOR DDR3/LPDDR4 same as tWTR_s.
  //bit 5:0 tWTR_s.
#define DMC_DRAM_TCCD                              ((0x010e  << 2) + 0xfe036000)
  //bit 19:16. tCCD/tCCD_l.
  //bit 3:0 tCCD/tCCD_s    read to read command time or write to write command time.
#define DMC_DRAM_TEXSR                             ((0x010f  << 2) + 0xfe036000)
  //bit 12:0. tEXSR.  EXIT SELF-REFRESH to read/write command.
#define DMC_DRAM_TXS                               ((0x0110  << 2) + 0xfe036000)
  //bit 9:0  tXS.  EXIT SELF_REFRESH to other command time
#define DMC_DRAM_TXP                               ((0x0111  << 2) + 0xfe036000)
  //bit 6:0. LPDDR4 tXP.  EXIT power down to other command time
			//LPDDR5 tCSL
#define DMC_DRAM_TXPDLL                            ((0x0112  << 2) + 0xfe036000)
  //bit 12:0.  tXPDLL,  EXIT power down to read/write command time(need to relock PLL).
#define DMC_DRAM_TZQCS                             ((0x0113  << 2) + 0xfe036000)
  //bit 11:0.  ZQCS command to other command time.
#define DMC_DRAM_TCKSRE                            ((0x0114  << 2) + 0xfe036000)
  //bit 4:0. enter self refresh to disable clock time.
#define DMC_DRAM_TCKSRX                            ((0x0115  << 2) + 0xfe036000)
  //bit 4:0. enable clock to exit self refresh time.
#define DMC_DRAM_TCKE                              ((0x0116  << 2) + 0xfe036000)
  //bit 4:0.  CKE high or low minimum time.
				//LPDDR5: tCSPD. power down to power up
#define DMC_DRAM_TMOD                              ((0x0117  << 2) + 0xfe036000)
  //bit 4:0  tMOD.  MRR/MRW to other command time. in LPDDR4, still use this register \
					but it called tMRD.

#define DMC_DRAM_TDQS                              ((0x0118  << 2) + 0xfe036000)
  //bit 31:28 reserved
  //bit 27:24 tDQS. the delay for write after read in different rank.
  //bit 23:20 reserved
  //bit 19:16 tDQS. the delay for read after write in different rank.
  //bit 15:12 reserved
  //bit 11:8  tDQS. the delay for write after write in different rank.
  //bit 7:4 reserved
  //bit 3:0 tDQS. the delay for read after read in different rank.
#define DMC_DRAM_TRSTL                             ((0x0119  << 2) + 0xfe036000)
  //not used.
#define DMC_DRAM_TZQLAT                            ((0x011a  << 2) + 0xfe036000)
  //bit 5:0 ZQ LATCH command to other command timing in LPDDR4 mode.
#define DMC_DRAM_TMRR                              ((0x011b  << 2) + 0xfe036000)
  //bit 7:0 tMRR  not used in DMC.

#define DMC_DRAM_TCKESR                            ((0x011c  << 2) + 0xfe036000)
 //bit 9:0 tCKESR.   CKE low minimum pulse in self refresh mode.
#define DMC_DRAM_TDPD                              ((0x011d  << 2) + 0xfe036000)
 //not support.
#define DMC_DRAM_DFITCTRLDELAY                     ((0x011e  << 2) + 0xfe036000)
  //bit 3:0. DFI_t_ctrldealy
#define DMC_DRAM_DFITPHYWRDATA                     ((0x011f  << 2) + 0xfe036000)
  //bit 5:0.  dfi_t_phy_wrdata.
#define DMC_DRAM_DFITPHYWRLAT                      ((0x0120  << 2) + 0xfe036000)
  //bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATAEN                      ((0x0121  << 2) + 0xfe036000)
  //bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define DMC_DRAM_DFITPHYRDLAT                      ((0x0122  << 2) + 0xfe036000)
  //bit 5:0.  dfi_t_rdlat.
#define DMC_DRAM_DFITCTRLUPDMIN                    ((0x0123  << 2) + 0xfe036000)
  //bit 7:0.  CTRLUPD_MIN  minimum clock cycle to maintain CTRLUPD_REQ.
#define DMC_DRAM_DFITCTRLUPDMAX                    ((0x0124  << 2) + 0xfe036000)
  //bit 7:0   CTRLUPD_MAX.  maxmum clock cycle to maintain CTRLUPD_REQ if no CTRLUPD_ACK response.
#define DMC_DRAM_DFITREFMSKI                       ((0x0126  << 2) + 0xfe036000)
  //not used.
#define DMC_DRAM_DFITCTRLUPDI                      ((0x0127  << 2) + 0xfe036000)
  //not used.
#define DMC_DRAM_DFITDRAMCLK                       ((0x0128  << 2) + 0xfe036000)
//bit 17    dram clk1 enable.
//bit 16    dram clk0 enable.
//bit 15:8  DRAM CLK disable waiting time
//bit 7:0   DRAM CLK enable  enable timer

#define DMC_DRAM_DFITLPRESP                        ((0x012a  << 2) + 0xfe036000)
//bit 4:0.  dfi_lp_ctrl_req response time. after dfi_lp_ctrl_req asserted, and after response \
		time if there's still no dfi_lp_ack respone, then drop the dfi_lp_ctrl_req.

#define DMC_DRAM_TCKECK                            ((0x012c  << 2) + 0xfe036000)
//bit 4:0. tCKECK  from CKE low to assert dfi_dram_clk_disable time. this time + dfi_t_ctrl_delay
			//in LPDDR5 tCSLCK


#define DMC_DRAM_TREFI                             ((0x012d  << 2) + 0xfe036000)
//write this register will update the auto refresh related register to the auto refresh \
	control logic.
//bit 31:24:  tZQCI dmc send zqci period.  unit is how much auto refresh period.
//bit 23:16   pvti  dmc send dfi_ctrlupd_req period.  unit is one auto refresh period.
//bit 15:8.   tREFI.dmc send auto refresh command period. unit is 100ns.
//bit 7:0.    t100ns period. unit is dmc clock cycles
#define DMC_DRAM_TSR                               ((0x012e  << 2) + 0xfe036000)
//bit 5:0 tSR.  self resfresh enter to exit time.
#define DMC_DRAM_TCCDMW                            ((0x012f  << 2) + 0xfe036000)
//bit 5:0.  4*tCCD in LPDDR4 mask write.
#define DMC_DRAM_TESCKE                            ((0x0130  << 2) + 0xfe036000)
//bit 5:0  tESCKE.  enter self refresh to power time for LPDDR4.
#define DMC_DRAM_TREFI_DDR3                        ((0x0131  << 2) + 0xfe036000)
//9:0. use this register to reset refi_disable_cnt. the unit is t100ns.
//use this to check in 8*tREFI time, the DMC should not sent more than 16 auto REFRESH command.
#define DMC_DRAM_TZQCAL                            ((0x0132  << 2) + 0xfe036000)
//15:0. ZQCAL for LPDDR4.  tZQCAL4/8/16 for LP5.
#define DMC_DRAM_T10US                             ((0x0133  << 2) + 0xfe036000)
//10us clock cycle number used for LP2 mode.
#define DMC_DRAM_TMRRI                             ((0x0134  << 2) + 0xfe036000)
//bit 7:0   tMRRI for MRR
#define DMC_DRAM_TXS_FAST                          ((0x0135  << 2) + 0xfe036000)
//bit 9:0 DDR4 mode XS_FAST exit self_refrest to zqcl/zqcs/mrs command.
#define DMC_DRAM_DFIODTCFG                         ((0x0136  << 2) + 0xfe036000)
//bit 12.  rank1 ODT default. default value for ODT[1] pins if theres no read/write activity.
//bit 11.  rank1 ODT write sel.  enable ODT[1] if there's write occur in rank1.
//bit 10.  rank1 ODT write nsel. enable ODT[1] if theres's write occur in rank0.
//bit 9.   rank1 odt read sel.   enable ODT[1] if there's read occur in rank1.
//bit 8.   rank1 odt read nsel.  enable ODT[1] if there's read occur in rank0.
//bit 4.   rank0 ODT default.    default value for ODT[0] pins if theres no read/write activity.
//bit 3.   rank0 ODT write sel.  enable ODT[0] if there's write occur in rank0.
//bit 2.   rank0 ODT write nsel. enable ODT[0] if theres's write occur in rank1.
//bit 1.   rank0 odt read sel.   enable ODT[0] if there's read occur in rank0.
//bit 0.   rank0 odt read nsel.  enable ODT[0] if there's read occur in rank1.
#define DMC_DRAM_DFIODTCFG1                        ((0x0137  << 2) + 0xfe036000)
//bit 27:24  ODT length for BL8 read transfer.
//bit 19:16. ODT length for BL8 write transfer.
//bit 12:8.  ODT latency for reads.  suppose to be 0.
//bit 4:0.   ODT latency for writes.  suppose to be 0.

#define DMC_DRAM_TWODTON                           ((0x0138  << 2) + 0xfe036000)
//bit 5:0   DRAM write access ODT on time.
//   in DDR3/4 should be same as WL.
//   in LPDDR4 ODT enable  mode:  tODTLon + tODTon.min
//   In LPDDR4 ODT disable mode:  tWL.

#define DMC_DRAM_PHYADDRON                         ((0x013a  << 2) + 0xfe036000)
  //bit 5:0 PHY_CTRL_ADDR_ON for new PHY. default : 12 unit: DfiClk
#define DMC_DRAM_PHYWRON                           ((0x013b  << 2) + 0xfe036000)
  //bit 6:0 PHY_CTRL_ADDR_ON for new PHY. unit: ddr clk
  // PHY_CTRL_WR_ON.  = 20 + WL + (tDQSS+ tDQS2DQ + tWPST)/ddr_clk + BL/2
#define DMC_DRAM_PHYRDON                           ((0x013c  << 2) + 0xfe036000)
  // PHY_CTRL_RD_ON.  = 20 + RL + (tDQSCK+ tRPST + tDQSQ)/ddr_clk + BL/2

#define DMC_DRAM_ZQCTRL                            ((0x013d  << 2) + 0xfe036000)
  //tZQCI bits in DMC_DRAM_TREFI  defined how many refresh period send ZQCS/ZQUPD/command.
  //this register defines in 0~tZQCI period, which refresh period count to send partial \
			ZQCS/ZACAL/ZQUPD command
  //31:24.  in LPDDR4 case when to send ZQLAT comman to both RANKs of LPDDR4 SDRAM
  //23:16.  when to send PHY ZQ UPDATE command.
  //15:8.   when to send ZQCS/ZQCAL to rank1 DDR SDRAM.
  //7:0.    when to senc ZQCS/ZQCAL to rank0 DDR SDRAM.

#define DMC_DRAM_DFITPHYWRLATCSN                   ((0x013e  << 2) + 0xfe036000)
  //bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATACSN                     ((0x013f  << 2) + 0xfe036000)
  //bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define DMC_DRAM_TPBR                              ((0x01a0  << 2) + 0xfe036000)
  //bit 23:16 tPBR2ACT
  //bit 7:0   tPBR2PBR
#define DMC_DRAM_TWCK_FS                           ((0x01a1  << 2) + 0xfe036000)
  //timing for wck_fs sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_WR                           ((0x01a2  << 2) + 0xfe036000)
  //timing for wck_wr sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_RD                           ((0x01a3  << 2) + 0xfe036000)
  //timing for wck_rd sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define DMC_DRAM_TWCK_OFF                          ((0x01a4  << 2) + 0xfe036000)
  //timing for wck_rd sync command
  //bit 31:24 not used.
  //bit 23:16 timing from write command to wck off timing.
			//  = WL + BURST + TWCKPOST + tWCK2DQI ?
  //bit 15:8  WCKOFF cmd to other command timing.
  //bit 7:0   timing from read command to wck off timing.
			//  = RL + BURST + TWCKPOST + tWCK2DQO ?
#define DMC_DRAM_TPPD                              ((0x01a5  << 2) + 0xfe036000)
  //bit 31:24 not used.
  //bit 7:0.  tPPD. precharge to precharge delay in LPDDR5.
#define DMC_DRAM_TCSH                              ((0x01a6  << 2) + 0xfe036000)
  //bit 7:0.  tCSH for LPDDR5
#define DMC_DRAM_TCMDPD                            ((0x01a7  << 2) + 0xfe036000)
  //bit 7:0.  tCMDPD for LPDDR5
#define DMC_DRAM_TOSCPD                            ((0x01a8  << 2) + 0xfe036000)
  //bit 7:0.  tOSCPD for LPDDR5 : tOSCPD + tOSC
#define DMC_DRAM_TWCK2DQ                           ((0x01a9  << 2) + 0xfe036000)
 //bit 23:16. tWCK2DQI max
 //bit 7:0.   tWCK2DQO max
#define DMC_DRAM_TRFM                              ((0x01aa  << 2) + 0xfe036000)
 //9:0. tRFMpb for lpddr5
#define DMC_DRAM_TCKMAX                            ((0x01ab  << 2) + 0xfe036000)
 //7:0  tclk(max).    100ns in LPDDR4.


//timing parameter for frequency set 1.
#define DMC_NFQ_TMRD                               ((0x0140  << 2) + 0xfe036000)
#define DMC_NFQ_TRFC                               ((0x0141  << 2) + 0xfe036000)
#define DMC_NFQ_TRP                                ((0x0142  << 2) + 0xfe036000)
#define DMC_NFQ_TRTW                               ((0x0143  << 2) + 0xfe036000)
#define DMC_NFQ_TCL                                ((0x0144  << 2) + 0xfe036000)
#define DMC_NFQ_TCWL                               ((0x0145  << 2) + 0xfe036000)
#define DMC_NFQ_TRAS                               ((0x0146  << 2) + 0xfe036000)
#define DMC_NFQ_TRC                                ((0x0147  << 2) + 0xfe036000)
#define DMC_NFQ_TRCD                               ((0x0148  << 2) + 0xfe036000)
#define DMC_NFQ_TRRD                               ((0x0149  << 2) + 0xfe036000)
#define DMC_NFQ_TFAW                               ((0x014a  << 2) + 0xfe036000)
#define DMC_NFQ_TRTP                               ((0x014b  << 2) + 0xfe036000)
#define DMC_NFQ_TWR                                ((0x014c  << 2) + 0xfe036000)
#define DMC_NFQ_TWTR                               ((0x014d  << 2) + 0xfe036000)
#define DMC_NFQ_TCCD                               ((0x014e  << 2) + 0xfe036000)
#define DMC_NFQ_TEXSR                              ((0x014f  << 2) + 0xfe036000)
#define DMC_NFQ_TXS                                ((0x0150  << 2) + 0xfe036000)
#define DMC_NFQ_TXP                                ((0x0151  << 2) + 0xfe036000)
#define DMC_NFQ_TXPDLL                             ((0x0152  << 2) + 0xfe036000)
#define DMC_NFQ_TZQCS                              ((0x0153  << 2) + 0xfe036000)
#define DMC_NFQ_TCKSRE                             ((0x0154  << 2) + 0xfe036000)
#define DMC_NFQ_TCKSRX                             ((0x0155  << 2) + 0xfe036000)
#define DMC_NFQ_TCKE                               ((0x0156  << 2) + 0xfe036000)
#define DMC_NFQ_TMOD                               ((0x0157  << 2) + 0xfe036000)
#define DMC_NFQ_TDQS                               ((0x0158  << 2) + 0xfe036000)
#define DMC_NFQ_TRSTL                              ((0x0159  << 2) + 0xfe036000)
#define DMC_NFQ_TZQLAT                             ((0x015a  << 2) + 0xfe036000)
#define DMC_NFQ_TMRR                               ((0x015b  << 2) + 0xfe036000)
#define DMC_NFQ_TCKESR                             ((0x015c  << 2) + 0xfe036000)
#define DMC_NFQ_TDPD                               ((0x015d  << 2) + 0xfe036000)
#define DMC_NFQ_DFITCTRLDELAY                      ((0x015e  << 2) + 0xfe036000)
#define DMC_NFQ_DFITPHYWRDATA                      ((0x015f  << 2) + 0xfe036000)
#define DMC_NFQ_DFITPHYWRLAT                       ((0x0160  << 2) + 0xfe036000)
#define DMC_NFQ_DFITRDDATAEN                       ((0x0161  << 2) + 0xfe036000)
#define DMC_NFQ_DFITPHYRDLAT                       ((0x0162  << 2) + 0xfe036000)
#define DMC_NFQ_DFITCTRLUPDMIN                     ((0x0163  << 2) + 0xfe036000)
#define DMC_NFQ_DFITCTRLUPDMAX                     ((0x0164  << 2) + 0xfe036000)
#define DMC_NFQ_DFITREFMSKI                        ((0x0166  << 2) + 0xfe036000)
#define DMC_NFQ_DFITCTRLUPDI                       ((0x0167  << 2) + 0xfe036000)
#define DMC_NFQ_DFITDRAMCLK                        ((0x0168  << 2) + 0xfe036000)
#define DMC_NFQ_DFITLPRESP                         ((0x016a  << 2) + 0xfe036000)
#define DMC_NFQ_TCKECK                             ((0x016c  << 2) + 0xfe036000)
#define DMC_NFQ_TREFI                              ((0x016d  << 2) + 0xfe036000)
#define DMC_NFQ_TSR                                ((0x016e  << 2) + 0xfe036000)
#define DMC_NFQ_TCCDMW                             ((0x016f  << 2) + 0xfe036000)
#define DMC_NFQ_TESCKE                             ((0x0170  << 2) + 0xfe036000)
#define DMC_NFQ_TREFI_DDR3                         ((0x0171  << 2) + 0xfe036000)
#define DMC_NFQ_TZQCAL                             ((0x0172  << 2) + 0xfe036000)
#define DMC_NFQ_T10US                              ((0x0173  << 2) + 0xfe036000)
#define DMC_NFQ_TMRRI                              ((0x0174  << 2) + 0xfe036000)
#define DMC_NFQ_TXS_FAST                           ((0x0175  << 2) + 0xfe036000)
#define DMC_NFQ_DFIODTCFG                          ((0x0176  << 2) + 0xfe036000)
#define DMC_NFQ_DFIODTCFG1                         ((0x0177  << 2) + 0xfe036000)
#define DMC_NFQ_TWODTON                            ((0x0178  << 2) + 0xfe036000)
#define DMC_NFQ_PHYADDRON                          ((0x017a  << 2) + 0xfe036000)
#define DMC_NFQ_PHYWRON                            ((0x017b  << 2) + 0xfe036000)
#define DMC_NFQ_PHYRDON                            ((0x017c  << 2) + 0xfe036000)
#define DMC_NFQ_ZQCTRL                             ((0x017d  << 2) + 0xfe036000)
#define DMC_NFQ_DFITPHYWRLATCSN                    ((0x017e  << 2) + 0xfe036000)
#define DMC_NFQ_DFITRDDATACSN                      ((0x017f  << 2) + 0xfe036000)

#define DMC_NFQ_TPBR                               ((0x01b0  << 2) + 0xfe036000)
#define DMC_NFQ_TWCK_FS                            ((0x01b1  << 2) + 0xfe036000)
#define DMC_NFQ_TWCK_WR                            ((0x01b2  << 2) + 0xfe036000)
#define DMC_NFQ_TWCK_RD                            ((0x01b3  << 2) + 0xfe036000)
#define DMC_NFQ_TWCK_OFF                           ((0x01b4  << 2) + 0xfe036000)
#define DMC_NFQ_TPPD                               ((0x01b5  << 2) + 0xfe036000)
#define DMC_NFQ_TCSH                               ((0x01b6  << 2) + 0xfe036000)
#define DMC_NFQ_TCMDPD                             ((0x01b7  << 2) + 0xfe036000)
#define DMC_NFQ_TOSCPD                             ((0x01b8  << 2) + 0xfe036000)
#define DMC_NFQ_TWCK2DQ                            ((0x01b9  << 2) + 0xfe036000)
#define DMC_NFQ_TRFM                               ((0x01ba  << 2) + 0xfe036000)
#define DMC_NFQ_TCKMAX                             ((0x01bb  << 2) + 0xfe036000)



#define DMC_DRAM_DFITPHYUPDTYPE0                   ((0x0180  << 2) + 0xfe036000)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 0.
#define DMC_DRAM_DFITPHYUPDTYPE1                   ((0x0181  << 2) + 0xfe036000)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 1.
#define DMC_DRAM_DFITPHYUPDTYPE2                   ((0x0182  << 2) + 0xfe036000)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 2.
#define DMC_DRAM_DFITPHYUPDTYPE3                   ((0x0183  << 2) + 0xfe036000)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 3.

#define DMC_DRAM_MCFG                              ((0x0186  << 2) + 0xfe036000)
 //bit 31:27  not used.
 //bit 29.    freq_change request from dmc_clk_feq. 1 : enable. 0 use local dmc freq_change request.
 //bit 28.    in LPDDR4 mode, retraining request from dmc_clk_freq. \
				1 : enable.  0 : use local dmc retraining request.
 //bit 27.    rank1 16bits is 16bits in 32bits mode.
 //bit 26:24  rank1_d16_sel.  16bit mode, rank 1 byte selection.
 //bit 23.    rank0 16bits is 16bits in 32bits mode.
 //bit 22:20. rank0_d16_sel. 16bit mode, rank 0 byte selection.
       //3'b000 :  16bits is byte 0 and byte 1
       //3'b001 :  16bits is byte 0 and byte 2
       //3'b010 :  16bits is byte 0 and byte 3
       //3'b011 :  16bits is byte 1 and byte 2
       //3'b100 :  16bits is byte 1 and byte 3
       //3'b101 :  16bits is byte 2 and byte 3
 //bit 19.   send PHY ZQ command  after siu self refresh exit. 1 : enable.  0 : disable.
 //bit 18.   send retrain command after siu self refresh exit. 1 : enable. 0 : disable.
 //bit 17.   in DDR3/4 mode, send ZQCL command after exit register triggered self refresh.
 //bit 16.   send refresh command after finish frequency change. 1 : enable. 0 : disable.
 //bit 15.   send refresh command after finish LPDDR4 retraining. 1 : enable. 0 : disable.
 //bit 14.   1: cke init low.  0 : cke init high.
 //bit 13    1: dbi write enable only for LPDDR4.
 //bit 12.   1: dbi read inversion.   0:  dbi read high inversion.
 //bit 11.   1: dbi read enable. 0:  dbi not enabled.
 //bit 10    1: enable staggered chip select for 2 ranks DRAM.
 //bit 9     1: enable send auto refresh command to DDR SDRAM when PCTL is in CFG/STOP state.
 //bit 8     send auto refr cmd before enter register triggered  self refresh
 //bit 7     send auto refr cmd after exit register triggered self refresh mode.
 //bit 6     disable dram clock after enter register triggered self refresh.
 //bit 5     send DFI_LP_REQ to PHY after enter register triggered elf refresh mode.
 //bit 4     send DRAM to power down mode after enter self refresh. ONLY for LPDDR4.
 //bit 3     send DFI_CTRLUPD_REQ after exit register triggered self refresh.
 //bit 2     send ZQCS command after exit register triggered self refresh.
 //bit 1     enable PHY triggered DFI_PHYUPD_REQ.
 //bit 0     2T mode. always 1 in DDR3/4 mode.

#define DMC_DRAM_ZQ_CTRL                           ((0x0187  << 2) + 0xfe036000)
 //bit 31:16. how long PHY will finish PHY ZQ calibration. so DMC can send update request.
 //bit 15:4 not used.
 //bit 3  enable PHY ZQ CAL in ASR mode.
 //bit 2  ZQ command must be send in different time.
 //bit 1  ZQ command can be send at same time.
 //bit 0  rank0 ZQ only

#define DMC_DRAM_MCFG1                             ((0x0188  << 2) + 0xfe036000)
 //bit 22.  mrr_dbi_en. to enable dbi function for MR read.
 //bit 21;  enable separate dfi_lp_data_req. 1: enable. 0: dfi_lp_data_req same as dfi_lp_ctrl_req.
 //bit 20:16 dfi_lp_data_wakeup value.
 //bit 14.  enable SIU read data with DBI result.
 //bit 13.  LPDDR5 LINK_ECC read enable.
 //bit 12.  LPDDR5 LINK_ECC write enable.
 //bit 9.   LPDDR5 use WCK always on mode.
 //bit 8    LPDDR5 wck use WCK_FS command for fast 2 rank wck sync command.
 //bit 7:0.  LPDDR4 MRW DBI data mask pattern.  //default 8'b11111000;


#define DMC_DRAM_DFI_CTRL                          ((0x0189  << 2) + 0xfe036000)
//bit 31 siu_dfi_lat err generation enable.  1: if dfi read latency violation, \
generate data error. 0 : disable.
//bit 19: dfi_init_complete wait enable.  1: after dfi_init_complete, wait additional
	//EXSR time for new command. 0 : phy will handle all the timing after dfi_init_complete
	//DMC can do everything they want.
//bit 18:  dfi_rddata_cs_n polarity.  0 : rank0 select = 2'b10. rank1 select = 2'b10. \
		1 : rank0 select = 2'b01, rank1_select = 2'b10.
//bit 17:  dfi_wrdata_cs_n polarity.  0 : rank0 select = 2'b10. rank1 select = 2'b10. \
		1 : rank0 select = 2'b01, rank1_select = 2'b10.
//bit 16:  force PHY ctrl_on  if = 1, phy_ctrl_on signal will keep on.
//bit 15 siu_dfi1_lp_en
//bit 14 siu_dfi_lp_ack_and
//bit 13 siu_dfi_lp_ack_or
//bit 12 siu_dfi1_init_start_en
//bit 11 siu_dfi_init_com_and
//bit 10 siu_dfi_init_com_or
//bit  9 siu_dfi1_freq_en
//bit  8 siu_dfi1_dram_clk_dis_en
//bit  7 siu_dfi_phyupd_type_sel
//bit  6 siu_dfi1_phyupd_ack_en
//bit  5 siu_dfi_phyupd_req_and
//bit  4 siu_dfi_phyupd_req_or
//bit  3 siu_dfi_ctrlupd_ack_and
//bit  2 siu_dfi_ctrlupd_ack_or
//bit  1 siu_dfi1_ctrlupd_req_en
//bit  0 siu_dfi1_cmd_en

#define DMC_DRAM_DFIINITCFG                        ((0x018a  << 2) + 0xfe036000)
  //bit 31.     dfi_init_complete status. read only.
  //bit 19:18.  Frequency set 1 dfi_freq_fsp value.
  //bit 17:16.  Frequency set 0 dfi_freq_fsp value.
  //bit 15:14.  Frequency set 1 dfi_freq_ratio value.
  //bit 12:8    Frequency set 1 dfi_freq value.
  //bit 7:6     Frequency set 0 dfi_freq_ratio value.
  //bit 5:1     Frequency set 0 dfi_freq value.
  //bit 0.      dfi_init_start value  can be use manually config dfi_init_start signal.

#define DMC_DRAM_APD_CTRL                          ((0x018c  << 2) + 0xfe036000)
 //bit 19:16  DFI_LP_WAKEUP value in APD DFI_LP_REQ mode
 //bit 12    1: exit power down slow mode(waiting PLL LOCK).  0 : fast mode.
 //bit 11    enable DFI_LP_REQ when enter Auto power down mode.
 //bit 10    disable DFI_clk_disable when enter auto power down mode.
 //bit 9:0    0  disable auto power down mode.
	//non zero value to enable auto power down when DMC is in idle state for \
		this number of clock cycles.

#define DMC_DRAM_ASR_CTRL                          ((0x018d  << 2) + 0xfe036000)
  //bit 31. enable RETRAIN PHY after auto selfrefresh exit. for AM_PHY only.
  //bit 30. in DDR3/4 mode, send ZQCL command after exit from auto self refresh mode.
  //bit 29. enable PHY clock in LP2 mode.  1: enable. 0 : disable.
  //bit [28:24] DFI_LP_WAKEUP value in self refresh DFI_LP_REQ mode.
  //bit 23 : send REFRESH command after exit from auto self refersh mode(ASR).
  //bit 22 : send REFERSH command before enter to Auto self refresh mode(ASR).
  //bit 21 : send ZQCS command after exit from Auto self refresh mode(ASR).
  //bit 20 : send dfi_ctrl_upd after exit from ASR mode
  //bit 19 : send power down command when enter ASR mode. //for LPDDR4 only.
  //bit 18 : set the PHY enter LP2 mode after enter ASR mode. //not support for P1 LP5PHY
  //bit 17 : send DFI_LP_REQ  after enter ASR mode.
  //bit 16 : set DFI_CLK_DISABLE after enter ASR mode.
  //bit 15:0.   0 disable auto ASR mode.
	// Non-zero value enable ASR mode. when DMC is in idle state for this number \
		of clock cycles, the DMC will enter ASR mode.

#define DMC_DRAM_REFR_CTRL                         ((0x0192  << 2) + 0xfe036000)
  //bit 28  enable send phy pvt request after PHY ZQ calibration request.
  //bit 27:24 refresh postpone number threshold.
  //bit 23  enable Per Bank refresh mode.
  //bit 22  dmc to control DFI_CTRLUPD_REQ  with zq generation together.
  //bit 21  dmc to control PHY ZQ generation enable.
  //bit 20  dmc to control zqlat(in LPDDR4 mode) generation enable.
  //bit 19  dmc to control zqcs1 generation enable.
  //bit 18  dmc to control zqcs0 generation enable.
  //bit 17:8 auto refresh request pending cnt if there's page hit request.
  //bit 7  not used.
  //bit 6  Disabled auto refresh command if over 16 auto refresh command sent in 2 TREFI_DDR3 period
  //bit 5  enable dmc send ZQCS command .
  //bit 4. enable dmc send DFI_CTRUPD_REQ.
  //bit 3:1. how many refresh command send for one period. = this number + 1
  //bit 0.  enable dmc send auto refresh command.


#define DMC_DRAM_FREQ_CTRL                         ((0x0193  << 2) + 0xfe036000)
//bit 31 .  write 1 to change freqency   read 0: finished.
//bit 30.   waiting for software to send some manual command.  1 : waiting. 0 : not ready yet.
//bit 29:22.  not used.
//bit 21     after Freqchange send PHY ZQ update.
//bit 20    send CTRLUPD_REQ to PHY after freq_change finished.
//bit 19:16. how many cycles to send PLL change req after init_complete signal to low.
//bit 15.   freq pre  config_en. Before freq enter stop state let DMC configure DDR SDRAM.
//bit 14.   freq post config_en. After  freq enter stop state let DMC configure DDR SDRAM.
//bit 13.   send zqcl after freq change in DDR3/4 mode.
//bit 12.   send zqcs after freq change. 1: enable. 0 not send.
//bit 11.   in AUTO MRW function: the data format.  1: use USR_CMD format.  0: MRW format.
//bit 10.   AUTO MRW function:  1 use hardware auto MRW function.  0: don't do auto MRW.
//bit 9.  1 : FREQ MRW done. let FREQ change machine continue.
//bit 8   FREQ WAIT. 1 when freq change finishes, state machine stop at self refresh \
			state in case there's something need to handle.
			//0 after freq change finishes  the state machine go back to access state.
//bit 7   when change PLL setting, disable dmc clock
//bit 6   when change PLL setting, disable PHY DfiClk and DfiCtlClk.
//bit 5   check vpu_sleep_en ==1 when do FREQ change.  if vpu_sleep_en == 0, just wait.
//bit 4   nxt frequency selection.  1 = freq1. 0 = freq0.
//bit 3:1.  not used.
//bit 0.   current frequency selection.

#define DMC_DRAM_SCFG                              ((0x0194  << 2) + 0xfe036000)
	// bit 2:0 only one bit can be high at same time.
	// bit 2  1 : to ask PCTL enter ACCESS STATE.  0 : deassert the request.
	// bit 1  1 : to ask PCTL enter SELF REFRESH STATE.  0 : deassert the request.
	// bit 0  1 : to ask PCTL enter STOP/CONFIG STATE .  0 : deassert the request.

#define DMC_DRAM_STAT                              ((0x0195  << 2) + 0xfe036000)
	//bit 31     rd latency error. 1: means after dfiphytrdlat cycles, the read \
				data still not back.
	//bit 30.     not used.
	//bit 29:24   dram_sr_state
	//bit 23:20   stop_st
	//bit 19:16  freq_st.
	//4'h0: IDLE
	//4'h1 : FREQ_CHECK_VPU
	//4'h2 : FREQ_WAITING_STOP
	//4'h3 : FREQ_DRAM_CFG.  waiting DMC/software to send special MRW/MPC command \
			to configure DDR SDRAM either before Freq change or after freq change.
	//4'h4 : FREQ_SELF_REFR_ST.
	//4'h5 : FREQ_SET_DFI_FREQ.
	//4'h6 : FREQ_DFI_INIT_START_HIGH.
	//4'h7 : FREQ_CHANGE PLL_ST.
	//4'h8 : FREQ_UPDATA REG.
	//4'h9 : FREQ_DFI_INIT_START_LOW.
	//4'ha : FREQ_WAITING_FINISH
	//4'hb : FREQ_ZQCS
	//4'hc : FREQ_ZQ_LATCH
	//4'hd : FREQ_PVT
	//bit 15:12  ACCESS STATUS 0 :  ACCESS is in normal working mode.
	//1 :   ACCESS sending precharge command.
	//2 :   ACCESS sending AUTO REFRESH command.
	//3 :   ACCESS sending DIF_CTRLUPD_REQ command.
	//4 :   ACCESS sending ZQCS command to DDR DRAM(ZQCAL for LPDDR4).
	//5 :   ACCESS sending ZQLATCH command to  LPDDR4 only.

	//bit 11:8   APD STATUS:   0 :   APD_IDLE
	//1 :    APD sending PRECHARGE command
	//2 :    APD sending CKE low command
	//3 :    APD sending DISABLE DRAM CLOCK command
	//4 :    APD sending DFI_LP_CTRL_REQ
	//5 :    APD in Auto Power down mode.
	//6 :    APD deassert DFI_LP_CTRL_REQ
	//7 :    APD sending enable DRAM CLOCK command
	//8 :    APD sending out CKE high command.
	//bit 7:4: DRAM_STATUS:  0  :    DRAM IDLE
	//1  :    DRAM_STOP/DRAM_CFG
	//2  :    DRAM_ACCESS
	//3  :    DRAM_SLEEP
	//4  :    DRAM APD(AUTO POWER DOWN).
	//5  :    IDLE -> STOP/CONFIG
	//6  :    STOP -> SLEEP
	//7  :    STOP -> ACCESS
	//8  :    ACCESS -> SLEEP.
	//9  :    ACCESS -> STOP
	//A  :    ACCESS -> APD
	//B  :    SLEEP -> STOP
	//C  :    SLEEP -> ACCESS
	//D  :    APD -> ACCESS
	//bit 3        reserved.
	//bit 2        1 : DRAM enter normal working state.
	//bit 1        1 : DRAM enter sleep state. self refresh state.
	//bit 0        1 : dram enter cfg state.

#define DMC_DRAM_STAT1                             ((0x0196  << 2) + 0xfe036000)
  //bit 12:8   sleep_st
  //bit  7:5   train_st
  //bit  4:0   dram_phy_st


#define DMC_PHY_RETRAINING_CTRL                    ((0x0197  << 2) + 0xfe036000)
//bit 31 :  phy_retraining enable.
//bit 30 :  check  vpu sleep_en.
//bit 29 :  retrain_only 1: use full 28:24 as retrain dfi_freq value 0: use only 28:27 + \
			original dfi_freq2:0 as the retrain dfi_freq.
//bit 28:24 : retraining dfi_freq[4:3], the [2:0] bit still use the dfi_freq bits to keep \
			the frequency.
//bit 23:    retrain cke mode enable use for LPDDR4 mode. before send dfi_init_start request \
			to DDR_PHY,
	//1: put LPDDR4 SDRAM into self_refresh + power down mode. 0: put LPDDR4 SDRAM \
			in self-refresh mode.
//bit 15:0: retraining period unit : one refresh period.


#define DMC_DFI_ERR_STAT                           ((0x0198  << 2) + 0xfe036000)
 //LPDDR4 PHY DFI error information.
 //bit 31:20. not used.
 //bit 9.    ddr0_dfi_error
 //bit 8:5   ddr0_dfi_error_info.
 //bit 4.    ddr1_dfi_error.
 //bit 3:0.  ddr1_dfi_error_info.


#define DMC_LP2_TIMER                              ((0x019a  << 2) + 0xfe036000)
//bit 15:0.   timer setting to measure how long the chip is entered LP2 mode.
//this timer is 40bits counter with DMC PCLK.
//we use the high 16bits to compare this register. if the counter is large than this number, \
that means  the PHY need addition 10us after wakeup the PHY and before exit self_refresh mode.

#define DMC_DRAM_COMPLETE_WAIT                     ((0x019b  << 2) + 0xfe036000)
 //read only how long to waiting for DFI_INIT_COMPLETE become high after DFI_INIT_START triggered.

#define DMC_OSC_CTRL                               ((0x019c  << 2) + 0xfe036000)
//bit 31  osc_en. for LPDDR4 enable MPC DQS2DQ OSC counter .
//bit 30:16.  siu_osc_run.  LPDDR4 DQS interval timer run time in n_clk unit.
//bit 15:0 osc counter value in tREFI time. how long to trigger one DQS2DQ retrain.

#define DMC_TEMP_CTRL                              ((0x019d  << 2) + 0xfe036000)
//bit 31  mr temp read control.
//bit 23:0 counter value in t100NS.

#define DMC_TEMP_CTRL1                             ((0x019e  << 2) + 0xfe036000)
//bit 7:0  mr index.


#define DMC_DRAM_DFI_SWAP_0                        ((0x01c0  << 2) + 0xfe036000)
#define DMC_DRAM_DFI_SWAP_1                        ((0x01c1  << 2) + 0xfe036000)
#define DMC_DRAM_DFI_SWAP_2                        ((0x01c2  << 2) + 0xfe036000)
#define DMC_DRAM_DFI_SWAP_3                        ((0x01c3  << 2) + 0xfe036000)
#define DMC_DRAM_DFI_SWAP_4                        ((0x01c4  << 2) + 0xfe036000)



#define DMC_DRAM_CMD                               ((0x01d0  << 2) + 0xfe036000)
//bit 31. cmd done.  write 0 to clean.
//bit 30. data done. write 0 to clean.
//bit 8 . dram command is for data 16 bits.
//bit 7:6 2'b01: user command with data read.
		//2'b10: user command with data write.
		//2'b00: user command without data.
//bit 5.  user defined command.
//bit 4.  LPDDR4 MPC write data command( MPC WR FIFO). not support in LPDDR5.
//bit 3.  LPDDR4 MPC read data command (MPC RD Calibration and RD FIFO). not support in LPDDR5
//bit 2.  LPDDR4 MPC-1 command ( NOP,  Start DQS interval ....)
//bit 1.  mrr command.
//bit 0.  mrw command.

#define DMC_DRAM_CMD_CODE                          ((0x01d1  << 2) + 0xfe036000)
	//bit 31:28  user command case: DDR4: = {act_n, ras_n, cas_n, we_n}. LP4 case. \
		bit 28 = 1 used for 2 cycle command. bit 28 = 0 : used for 1 cycle command.
	//bit 27:26. 128bits data cycles . 0:1 clock cycles; 1:2 clock cycles; \
						2:3 clock cycles; 3:4 clock cycles.
	//           LPDDR4 : 2 clock cycles;
	//           LPDDR5 : 2 clock cycles for MRR command. 4 cycles for RFF command.
	//bit 25     MRW/MRR/MPC command rank 1 select.  1: select.  0: not select.
	//bit 24.    MRW/MRR/MPC command rank 0 select.  1: select.  0: not select.
	//bit 23:16  MR addr.
	//bit 15:0   opcode.

#define DMC_DRAM_CMD_TIME                          ((0x01d2  << 2) + 0xfe036000)
//bit 31:16  PRE  CMD timer. //delay how many cycle to start the command.
//bit 15:0   POST CMD timer  //delay how many cycle after the command execute.

#define DMC_DRAM_WSTRB0                            ((0x01d3  << 2) + 0xfe036000)
#define DMC_DRAM_WSTRB1                            ((0x01d4  << 2) + 0xfe036000)
#define DMC_DRAM_RDBI0                             ((0x01d5  << 2) + 0xfe036000)
  //MPC RD FIFO command DBI read back data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.
#define DMC_DRAM_RDBI1                             ((0x01d6  << 2) + 0xfe036000)
  //MPC RD FIFO command DBI read back data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.

//WD0~16 and RD0~16 can be used as MRW command as Frequency change .
//WD0~16 is for Freq1 DRAM MR setting, it would send to DRAM right before FREQ0-> FREQ1
//RD0_16 is for Freq0 DRAM MR setting. it would send to DRAM right before FREQ1-> FREQ0.
//each register can be one MRW command. So total 16 MRW command can be sent to DRAM.
//The register formats:
//bit 31.   MRW/USER command enable.  1: enabled command. 0 not enabled.
//bit 30.   last MRW/USER command.   if this bit =1, After send this command, \
		the DRAM controller will contine frequency next stage.
//bit 29:26. USER COMMAND parameter: in DDR3/DDR4.  {act_n, ras_n, cas_n, we_n} \
value for user command in LPDDR4. bit 16 : 1 4 cycles command. 0 2 cycles command.
//bit 25     MRW/USER command rank 1 select.  1: select.  0: not select.
//bit 24.    MRW/USER command rank 0 select.  1: select.  0: not select.
//bit 23:0.  USER command.
//DDR3:    18:16 bank address. 15:0:  address.
//DDR4:    20:19 bank group address.   18:16: bank address. 15:0 address.
//LPDDR3:   9:0. rising edge address.  19:10.  falling edge address.
//LPDDR4.   5:0, first edge address,  11:6 second edge address, 17:12: third edge \
		address. 23:18, forth edge address.
//MRW command format:
//bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
//bit 15:0   opcode.
#define DMC_DRAM_WD0                               ((0x01e0  << 2) + 0xfe036000)
#define DMC_DRAM_WD1                               ((0x01e1  << 2) + 0xfe036000)
#define DMC_DRAM_WD2                               ((0x01e2  << 2) + 0xfe036000)
#define DMC_DRAM_WD3                               ((0x01e3  << 2) + 0xfe036000)
#define DMC_DRAM_WD4                               ((0x01e4  << 2) + 0xfe036000)
#define DMC_DRAM_WD5                               ((0x01e5  << 2) + 0xfe036000)
#define DMC_DRAM_WD6                               ((0x01e6  << 2) + 0xfe036000)
#define DMC_DRAM_WD7                               ((0x01e7  << 2) + 0xfe036000)
#define DMC_DRAM_WD8                               ((0x01e8  << 2) + 0xfe036000)
#define DMC_DRAM_WD9                               ((0x01e9  << 2) + 0xfe036000)
#define DMC_DRAM_WD10                              ((0x01ea  << 2) + 0xfe036000)
#define DMC_DRAM_WD11                              ((0x01eb  << 2) + 0xfe036000)
#define DMC_DRAM_WD12                              ((0x01ec  << 2) + 0xfe036000)
#define DMC_DRAM_WD13                              ((0x01ed  << 2) + 0xfe036000)
#define DMC_DRAM_WD14                              ((0x01ee  << 2) + 0xfe036000)
#define DMC_DRAM_WD15                              ((0x01ef  << 2) + 0xfe036000)

#define DMC_DRAM_RD0                               ((0x01f0  << 2) + 0xfe036000)
#define DMC_DRAM_RD1                               ((0x01f1  << 2) + 0xfe036000)
#define DMC_DRAM_RD2                               ((0x01f2  << 2) + 0xfe036000)
#define DMC_DRAM_RD3                               ((0x01f3  << 2) + 0xfe036000)
#define DMC_DRAM_RD4                               ((0x01f4  << 2) + 0xfe036000)
#define DMC_DRAM_RD5                               ((0x01f5  << 2) + 0xfe036000)
#define DMC_DRAM_RD6                               ((0x01f6  << 2) + 0xfe036000)
#define DMC_DRAM_RD7                               ((0x01f7  << 2) + 0xfe036000)
#define DMC_DRAM_RD8                               ((0x01f8  << 2) + 0xfe036000)
#define DMC_DRAM_RD9                               ((0x01f9  << 2) + 0xfe036000)
#define DMC_DRAM_RD10                              ((0x01fa  << 2) + 0xfe036000)
#define DMC_DRAM_RD11                              ((0x01fb  << 2) + 0xfe036000)
#define DMC_DRAM_RD12                              ((0x01fc  << 2) + 0xfe036000)
#define DMC_DRAM_RD13                              ((0x01fd  << 2) + 0xfe036000)
#define DMC_DRAM_RD14                              ((0x01fe  << 2) + 0xfe036000)
#define DMC_DRAM_RD15                              ((0x01ff  << 2) + 0xfe036000)

#define DMC_DRAM_MRR0                              ((0x0280  << 2) + 0xfe036000)
 //7:0  the 1st MR read result for snoop
#define DMC_DRAM_MRR1                              ((0x0281  << 2) + 0xfe036000)
 //7:0  the 2nd MR read result for snoop
#define DMC_DRAM_MRR2                              ((0x0282  << 2) + 0xfe036000)
// //7:0  the 3rd MR read result for snoop
#define DMC_DRAM_MRR3                              ((0x0283  << 2) + 0xfe036000)
// //7:0  the 4th MR read result for snoop
#define DMC_DRAM_MRR4                              ((0x0284  << 2) + 0xfe036000)
// //7:0  the 5th MR read result for snoop
#define DMC_DRAM_MRR5                              ((0x0285  << 2) + 0xfe036000)
// //7:0  the 6th MR read result for snoop
#define DMC_DRAM_MRR6                              ((0x0286  << 2) + 0xfe036000)
// //7:0  the 7th MR read result for snoop
#define DMC_DRAM_MRR7                              ((0x0287  << 2) + 0xfe036000)
// //7:0  the 8th MR read result for snoop
#define DMC_DRAM_MRR8                              ((0x0288  << 2) + 0xfe036000)
// //7:0  the 1st MR read result for rfc rate
#define DMC_DRAM_MRR9                              ((0x0289  << 2) + 0xfe036000)
// //7:0  the 2nd MR read result for rfc rate

//STICKY registers.
//those register is for software save some temporary value. and because it's in
//RAM. it won't lose if DMC get reseted.
#define DMC_STICKY_0                               ((0x0200  << 2) + 0xfe036000)
#define DMC_STICKY_1                               ((0x0201  << 2) + 0xfe036000)
#define DMC_STICKY_2                               ((0x0202  << 2) + 0xfe036000)
#define DMC_STICKY_3                               ((0x0203  << 2) + 0xfe036000)
#define DMC_STICKY_4                               ((0x0204  << 2) + 0xfe036000)
#define DMC_STICKY_5                               ((0x0205  << 2) + 0xfe036000)
#define DMC_STICKY_6                               ((0x0206  << 2) + 0xfe036000)
#define DMC_STICKY_7                               ((0x0207  << 2) + 0xfe036000)
#define DMC_STICKY_8                               ((0x0208  << 2) + 0xfe036000)
#define DMC_STICKY_9                               ((0x0209  << 2) + 0xfe036000)
#define DMC_STICKY_10                              ((0x020a  << 2) + 0xfe036000)
#define DMC_STICKY_11                              ((0x020b  << 2) + 0xfe036000)
#define DMC_STICKY_12                              ((0x020c  << 2) + 0xfe036000)
#define DMC_STICKY_13                              ((0x020d  << 2) + 0xfe036000)
#define DMC_STICKY_14                              ((0x020e  << 2) + 0xfe036000)
#define DMC_STICKY_15                              ((0x020f  << 2) + 0xfe036000)
#define DMC_STICKY_16                              ((0x0210  << 2) + 0xfe036000)
#define DMC_STICKY_17                              ((0x0211  << 2) + 0xfe036000)
#define DMC_STICKY_18                              ((0x0212  << 2) + 0xfe036000)
#define DMC_STICKY_19                              ((0x0213  << 2) + 0xfe036000)
#define DMC_STICKY_20                              ((0x0214  << 2) + 0xfe036000)
#define DMC_STICKY_21                              ((0x0215  << 2) + 0xfe036000)
#define DMC_STICKY_22                              ((0x0216  << 2) + 0xfe036000)
#define DMC_STICKY_23                              ((0x0217  << 2) + 0xfe036000)
#define DMC_STICKY_24                              ((0x0218  << 2) + 0xfe036000)
#define DMC_STICKY_25                              ((0x0219  << 2) + 0xfe036000)
#define DMC_STICKY_26                              ((0x021a  << 2) + 0xfe036000)
#define DMC_STICKY_27                              ((0x021b  << 2) + 0xfe036000)
#define DMC_STICKY_28                              ((0x021c  << 2) + 0xfe036000)
#define DMC_STICKY_29                              ((0x021d  << 2) + 0xfe036000)
#define DMC_STICKY_30                              ((0x021e  << 2) + 0xfe036000)
#define DMC_STICKY_31                              ((0x021f  << 2) + 0xfe036000)
#define DMC_STICKY_32                              ((0x0220  << 2) + 0xfe036000)
#define DMC_STICKY_33                              ((0x0221  << 2) + 0xfe036000)
#define DMC_STICKY_34                              ((0x0222  << 2) + 0xfe036000)
#define DMC_STICKY_35                              ((0x0223  << 2) + 0xfe036000)
#define DMC_STICKY_36                              ((0x0224  << 2) + 0xfe036000)
#define DMC_STICKY_37                              ((0x0225  << 2) + 0xfe036000)
#define DMC_STICKY_38                              ((0x0226  << 2) + 0xfe036000)
#define DMC_STICKY_39                              ((0x0227  << 2) + 0xfe036000)
#define DMC_STICKY_40                              ((0x0228  << 2) + 0xfe036000)
#define DMC_STICKY_41                              ((0x0229  << 2) + 0xfe036000)
#define DMC_STICKY_42                              ((0x022a  << 2) + 0xfe036000)
#define DMC_STICKY_43                              ((0x022b  << 2) + 0xfe036000)
#define DMC_STICKY_44                              ((0x022c  << 2) + 0xfe036000)
#define DMC_STICKY_45                              ((0x022d  << 2) + 0xfe036000)
#define DMC_STICKY_46                              ((0x022e  << 2) + 0xfe036000)
#define DMC_STICKY_47                              ((0x022f  << 2) + 0xfe036000)
#define DMC_STICKY_48                              ((0x0230  << 2) + 0xfe036000)
#define DMC_STICKY_49                              ((0x0231  << 2) + 0xfe036000)
#define DMC_STICKY_50                              ((0x0232  << 2) + 0xfe036000)
#define DMC_STICKY_51                              ((0x0233  << 2) + 0xfe036000)
#define DMC_STICKY_52                              ((0x0234  << 2) + 0xfe036000)
#define DMC_STICKY_53                              ((0x0235  << 2) + 0xfe036000)
#define DMC_STICKY_54                              ((0x0236  << 2) + 0xfe036000)
#define DMC_STICKY_55                              ((0x0237  << 2) + 0xfe036000)
#define DMC_STICKY_56                              ((0x0238  << 2) + 0xfe036000)
#define DMC_STICKY_57                              ((0x0239  << 2) + 0xfe036000)
#define DMC_STICKY_58                              ((0x023a  << 2) + 0xfe036000)
#define DMC_STICKY_59                              ((0x023b  << 2) + 0xfe036000)
#define DMC_STICKY_60                              ((0x023c  << 2) + 0xfe036000)
#define DMC_STICKY_61                              ((0x023d  << 2) + 0xfe036000)
#define DMC_STICKY_62                              ((0x023e  << 2) + 0xfe036000)
#define DMC_STICKY_63                              ((0x023f  << 2) + 0xfe036000)


//DMC TEST.
//DMC test use AXI 16Gbyte address. So user should guarantee
#define DMC_TEST_STA                               ((0x0350  << 2) + 0xfe036000)
//test start address. for non-sha mode, the last 5 bits would be ignored.
//			the test address at 32bytes boundary.
//                     for sha mode, address must be in 64 bytes boundary.
//                     that mean the last 6 bits must be 0.
#define DMC_TEST_EDA                               ((0x0351  << 2) + 0xfe036000)
	//test end address.  for non-sha mode,  the last 5 bits would be ignored. \
						the test address at 32bytes boundary.
	//                   for sha mode, address must be in 64 bytes boundary. \
						that mean the last 6bits must be 1.
#define DMC_TEST_CTRL                              ((0x0352  << 2) + 0xfe036000)
	//bit 31.  enable test.
	//bit 30.  when enable test, enable the write to DDR function.
	//bit 29.  when enable test, enable the read from DDR function.
	//bit 28.  when enable test,  enable the sha calculation function must be same as read \
			enable but without write function.
	//bit 27.  enabe to compare data.  when do the read enable to enable the error comparison. \
			suppose the read data should be same as the data in the write buffer.
	//bit 26.  0: save sha result to test_sha_message registers.  1 : don't save.
	//bit 25.  address generation type.  0: continuous increase the address in the range of \
							test start address and test end address.
	//				1: test module would pick the random address from test \
							start address  and test end address.
	//bit 24.  done type.      0 : use the DMC_TEST_NUM register as the counter of test numbers.
	//for write if the write command number == the DMC_TEST_NUM, the write is done.
	//for read if the read command number == the DMC TEST_num, the read id done.
	//for one read command can be repeated repeat number times.
	//                         1 : finshed at end address.
	//bit 23.  wdata type.     1 : the first write is {WD3, WD2,WD1,WD0}, then \
		the latter is the previous data plus a pattern.({ + WD7,  + WD6, + WD5, + WD4}).
	//                         0 : the WDATA is the data in write register.
	//bit 23.  1  compare the sha result with the test sha message registers. \
				0 : dont compare the result.
	//bit 22:20.   read repeat times.  for non-sha function, we can define multi times of the \
				read. the test module would repeat the same address repeat times.
	//bit 19.     limit write.  0: no outstanding write request limitation.
	//		1: limit the outstanding write commands to the number of bits [15:8]
	//bit 18.     limit read.   0. no outstanding read request limitation.
	//		1. limit the read outstanding request to the number of bits[7:0].
	//bit 17:16.  sha mode for sha function enabled. 00 : not used.  01 : sha1. \
				2 : sha2-256. 3 : sha2_224. not used in GXL fixed to be Sha 2.
	//bit 15:8.   write outstanding commands limit.
	//bit 7:0.    read  outstanding commands limit.

#define DMC_TEST_NUM                               ((0x0353  << 2) + 0xfe036000)
   // how many test command for the test if the DMC_TEST_CTRL bit 24 is 0.

#define DMC_TEST_WDG                               ((0x0354  << 2) + 0xfe036000)
  //31:16.  write response watch dog.
  //15:0.   read response  watch dog.

#define DMC_TEST_COMP_MASK                         ((0x0355  << 2) + 0xfe036000)
  //32bits for DMC TEST COMPARE bit enable.
  //1 : to MASK this bit.  0: compare this bit.

#define DMC_TEST_WSTRB0                            ((0x0356  << 2) + 0xfe036000)
  //MPC WR FIFO command DM bit write data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.

#define DMC_TEST_WSTRB1                            ((0x0357  << 2) + 0xfe036000)
  //MPC WR FIFO command DM bit write data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.

#define DMC_TEST_WD0                               ((0x0360  << 2) + 0xfe036000)
  // write data 0 for write command. also for read back data comparison.
#define DMC_TEST_WD1                               ((0x0361  << 2) + 0xfe036000)
#define DMC_TEST_WD2                               ((0x0362  << 2) + 0xfe036000)
#define DMC_TEST_WD3                               ((0x0363  << 2) + 0xfe036000)
#define DMC_TEST_WD4                               ((0x0364  << 2) + 0xfe036000)
#define DMC_TEST_WD5                               ((0x0365  << 2) + 0xfe036000)
#define DMC_TEST_WD6                               ((0x0366  << 2) + 0xfe036000)
#define DMC_TEST_WD7                               ((0x0367  << 2) + 0xfe036000)
#define DMC_TEST_WD8                               ((0x0368  << 2) + 0xfe036000)
#define DMC_TEST_WD9                               ((0x0369  << 2) + 0xfe036000)
#define DMC_TEST_WD10                              ((0x036a  << 2) + 0xfe036000)
#define DMC_TEST_WD11                              ((0x036b  << 2) + 0xfe036000)
#define DMC_TEST_WD12                              ((0x036c  << 2) + 0xfe036000)
#define DMC_TEST_WD13                              ((0x036d  << 2) + 0xfe036000)
#define DMC_TEST_WD14                              ((0x036e  << 2) + 0xfe036000)
#define DMC_TEST_WD15                              ((0x036f  << 2) + 0xfe036000)


#define DMC_TEST_ERR_ADDR                          ((0x0340  << 2) + 0xfe036000)
  //read only. it capture the first error address.
#define DMC_TEST_ERR_CNT                           ((0x0341  << 2) + 0xfe036000)
  //read only. how many data error happens in the whole test period.
#define DMC_TEST_STS                               ((0x0342  << 2) + 0xfe036000)
  //read only.
  //bit 31,   test done bit. write 1 to clean.
  //bit 30,   indicate address err
  //bit 29~7.  not used.
  //bit 6.    read data resp error(caused by security or rd latency).
  //bit 5.    test MRR/MPR rd latency error. write 1 clear
  //bit 4,    sha done.     write 1 to clean.
  //bit 3,    write done.   write 1 to clean.
  //bit 2,    read done.    write 1 to clean
  //bit 1,    write watchdog triggered.   write 1 to clean
  //bit 0,    read watchdog triggered.    write 1 to clean.


#define DMC_TEST_WRCMD_ADDR                        ((0x0343  << 2) + 0xfe036000)
  //read only. the current write cmd address.
#define DMC_TEST_RDCMD_ADDR                        ((0x0344  << 2) + 0xfe036000)
   //read only. the current read command address.
#define DMC_TEST_RDRSP_ADDR                        ((0x0345  << 2) + 0xfe036000)
  //read only. rdrsp address.


#define DMC_TEST_RD0                               ((0x0330  << 2) + 0xfe036000)
   // the read back data 0.  if error happens, it would capture the first error data.
#define DMC_TEST_RD1                               ((0x0331  << 2) + 0xfe036000)
   // the read back data 1.  if error happens, it would capture the first error data.
#define DMC_TEST_RD2                               ((0x0332  << 2) + 0xfe036000)
   // the read back data 2.  if error happens, it would capture the first error data.
#define DMC_TEST_RD3                               ((0x0333  << 2) + 0xfe036000)
   // the read back data 3.  if error happens, it would capture the first error data.
#define DMC_TEST_RD4                               ((0x0334  << 2) + 0xfe036000)
   // the read back data 4.  if error happens, it would capture the first error data.
#define DMC_TEST_RD5                               ((0x0335  << 2) + 0xfe036000)
   // the read back data 5.  if error happens, it would capture the first error data.
#define DMC_TEST_RD6                               ((0x0336  << 2) + 0xfe036000)
   // the read back data 6.  if error happens, it would capture the first error data.
#define DMC_TEST_RD7                               ((0x0337  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD8                               ((0x0338  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD9                               ((0x0339  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD10                              ((0x033a  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD11                              ((0x033b  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD12                              ((0x033c  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD13                              ((0x033d  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD14                              ((0x033e  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD15                              ((0x033f  << 2) + 0xfe036000)
   // the read back data 7.  if error happens, it would capture the first error data.


//DMC Security control registers.

 //there's total 16 ranges in the whole memory range.
// 15 ranges can be defined in 64kbyte boundary start address and end address.
// the 16th range is all other space not defined by 15 ranges.
// Each range can be enabled or disabled and  each range use security level \
	bit to select key to do data scramble.
// The ranges can be overlapped or crossover.  But from 0 to 15 ranges, \
	the earlier has higher priority.

//region0(RANGE0) related register.
#define DMC_SEC_RANGE0_STA                         ((0x0400  << 2) + 0xfe036000)
  //bit 31:20. not used.
  //bit 19:0.   region start address AXI address [31:12] unit 4Kbyte.
#define DMC_SEC_RANGE0_EDA                         ((0x0401  << 2) + 0xfe036000)
  //bit 31:20. not used.
  //bit 19:0.   region end address.for AXI address[31:12]. unit 4Kbyte.
#define DMC_SEC_RANGE0_CTRL                        ((0x0402  << 2) + 0xfe036000)
	//bit 7:5 | 0 | range0_security_level | range0 security level for DMC and DEMUX only.
	//bit 4  | 0 | range0_prot_en       | range0 allow protect monitor function. \
		1 : allowed.  0 : not allowed.
	//bit 3  | 0 | range0_local_des_en  | range0 data descramble enable. 1 : enable.
		//0 : disable. this bit works together with GLOBAL_DES_EN to decide this region
		//data descramble enable or not.
	//bit 2  | 0 | range0_lock  |  lock range 0 registers. write 1 to lock range 0 \
							register. can't change anymore.
	//bit 1  | 0 | range0_key_sel | range 0 data describe key selection.  1 : key1. 0 : key0.
	//bit 0  | 0 | range0_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE0_RID_CTRL0                   ((0x0403  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE0_RID_CTRL1                   ((0x0404  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE0_RID_CTRL2                   ((0x0405  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];

#define DMC_SEC_RANGE0_WID_CTRL0                   ((0x0408  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE0_WID_CTRL1                   ((0x0409  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE0_WID_CTRL2                   ((0x040a  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];


//region0(RANGE1) related register.
#define DMC_SEC_RANGE1_STA                         ((0x0410  << 2) + 0xfe036000)
#define DMC_SEC_RANGE1_EDA                         ((0x0411  << 2) + 0xfe036000)
#define DMC_SEC_RANGE1_CTRL                        ((0x0412  << 2) + 0xfe036000)

#define DMC_SEC_RANGE1_RID_CTRL0                   ((0x0413  << 2) + 0xfe036000)
//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE1_RID_CTRL1                   ((0x0414  << 2) + 0xfe036000)
//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE1_RID_CTRL2                   ((0x0415  << 2) + 0xfe036000)
//range_rd_sid_en[95:64];

#define DMC_SEC_RANGE1_WID_CTRL0                   ((0x0418  << 2) + 0xfe036000)
//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE1_WID_CTRL1                   ((0x0419  << 2) + 0xfe036000)
//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE1_WID_CTRL2                   ((0x041a  << 2) + 0xfe036000)
//range_rd_sid_en[95:64];


//region2(RANGE2) related register.
#define DMC_SEC_RANGE2_STA                         ((0x0420  << 2) + 0xfe036000)
#define DMC_SEC_RANGE2_EDA                         ((0x0421  << 2) + 0xfe036000)
#define DMC_SEC_RANGE2_CTRL                        ((0x0422  << 2) + 0xfe036000)

#define DMC_SEC_RANGE2_RID_CTRL0                   ((0x0423  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE2_RID_CTRL1                   ((0x0424  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE2_RID_CTRL2                   ((0x0425  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];

#define DMC_SEC_RANGE2_WID_CTRL0                   ((0x0428  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE2_WID_CTRL1                   ((0x0429  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE2_WID_CTRL2                   ((0x042a  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];


//region3(RANGE3) related register.
#define DMC_SEC_RANGE3_STA                         ((0x0430  << 2) + 0xfe036000)
#define DMC_SEC_RANGE3_EDA                         ((0x0431  << 2) + 0xfe036000)
#define DMC_SEC_RANGE3_CTRL                        ((0x0432  << 2) + 0xfe036000)

#define DMC_SEC_RANGE3_RID_CTRL0                   ((0x0433  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE3_RID_CTRL1                   ((0x0434  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE3_RID_CTRL2                   ((0x0435  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];

#define DMC_SEC_RANGE3_WID_CTRL0                   ((0x0438  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE3_WID_CTRL1                   ((0x0439  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE3_WID_CTRL2                   ((0x043a  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region4(RANGE4) related register.
#define DMC_SEC_RANGE4_STA                         ((0x0440  << 2) + 0xfe036000)
#define DMC_SEC_RANGE4_EDA                         ((0x0441  << 2) + 0xfe036000)
#define DMC_SEC_RANGE4_CTRL                        ((0x0442  << 2) + 0xfe036000)

#define DMC_SEC_RANGE4_RID_CTRL0                   ((0x0443  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE4_RID_CTRL1                   ((0x0444  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE4_RID_CTRL2                   ((0x0445  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];

#define DMC_SEC_RANGE4_WID_CTRL0                   ((0x0448  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE4_WID_CTRL1                   ((0x0449  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE4_WID_CTRL2                   ((0x044a  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region5(RANGE5) related register.
#define DMC_SEC_RANGE5_STA                         ((0x0450  << 2) + 0xfe036000)
#define DMC_SEC_RANGE5_EDA                         ((0x0451  << 2) + 0xfe036000)
#define DMC_SEC_RANGE5_CTRL                        ((0x0452  << 2) + 0xfe036000)

#define DMC_SEC_RANGE5_RID_CTRL0                   ((0x0453  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE5_RID_CTRL1                   ((0x0454  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE5_RID_CTRL2                   ((0x0455  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];

#define DMC_SEC_RANGE5_WID_CTRL0                   ((0x0458  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE5_WID_CTRL1                   ((0x0459  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE5_WID_CTRL2                   ((0x045a  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region6(RANGE6) related register.
#define DMC_SEC_RANGE6_STA                         ((0x0460  << 2) + 0xfe036000)
#define DMC_SEC_RANGE6_EDA                         ((0x0461  << 2) + 0xfe036000)
#define DMC_SEC_RANGE6_CTRL                        ((0x0462  << 2) + 0xfe036000)

#define DMC_SEC_RANGE6_RID_CTRL0                   ((0x0463  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE6_RID_CTRL1                   ((0x0464  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE6_RID_CTRL2                   ((0x0465  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];

#define DMC_SEC_RANGE6_WID_CTRL0                   ((0x0468  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE6_WID_CTRL1                   ((0x0469  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE6_WID_CTRL2                   ((0x046a  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region7(RANGE7) related register.
#define DMC_SEC_RANGE7_STA                         ((0x0470  << 2) + 0xfe036000)

#define DMC_SEC_RANGE7_EDA                         ((0x0471  << 2) + 0xfe036000)
#define DMC_SEC_RANGE7_CTRL                        ((0x0472  << 2) + 0xfe036000)

#define DMC_SEC_RANGE7_RID_CTRL0                   ((0x0473  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE7_RID_CTRL1                   ((0x0474  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE7_RID_CTRL2                   ((0x0475  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE7_WID_CTRL0                   ((0x0478  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE7_WID_CTRL1                   ((0x0479  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE7_WID_CTRL2                   ((0x047a  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region8(RANGE8) related register.
#define DMC_SEC_RANGE8_STA                         ((0x0480  << 2) + 0xfe036000)
#define DMC_SEC_RANGE8_EDA                         ((0x0481  << 2) + 0xfe036000)
#define DMC_SEC_RANGE8_CTRL                        ((0x0482  << 2) + 0xfe036000)

#define DMC_SEC_RANGE8_RID_CTRL0                   ((0x0483  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE8_RID_CTRL1                   ((0x0484  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE8_RID_CTRL2                   ((0x0485  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE8_WID_CTRL0                   ((0x0488  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE8_WID_CTRL1                   ((0x0489  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE8_WID_CTRL2                   ((0x048a  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region9(RANGE9) related register.
#define DMC_SEC_RANGE9_STA                         ((0x0490  << 2) + 0xfe036000)
#define DMC_SEC_RANGE9_EDA                         ((0x0491  << 2) + 0xfe036000)
#define DMC_SEC_RANGE9_CTRL                        ((0x0492  << 2) + 0xfe036000)

#define DMC_SEC_RANGE9_RID_CTRL0                   ((0x0493  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE9_RID_CTRL1                   ((0x0494  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE9_RID_CTRL2                   ((0x0495  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE9_WID_CTRL0                   ((0x0498  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE9_WID_CTRL1                   ((0x0499  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE9_WID_CTRL2                   ((0x049a  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region10(RANGE10) related register.
#define DMC_SEC_RANGE10_STA                        ((0x04a0  << 2) + 0xfe036000)
#define DMC_SEC_RANGE10_EDA                        ((0x04a1  << 2) + 0xfe036000)
#define DMC_SEC_RANGE10_CTRL                       ((0x04a2  << 2) + 0xfe036000)

#define DMC_SEC_RANGE10_RID_CTRL0                  ((0x04a3  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE10_RID_CTRL1                  ((0x04a4  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE10_RID_CTRL2                  ((0x04a5  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE10_WID_CTRL0                  ((0x04a8  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE10_WID_CTRL1                  ((0x04a9  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE10_WID_CTRL2                  ((0x04aa  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];

//region9(RANGE11) related register.
#define DMC_SEC_RANGE11_STA                        ((0x04b0  << 2) + 0xfe036000)
#define DMC_SEC_RANGE11_EDA                        ((0x04b1  << 2) + 0xfe036000)
#define DMC_SEC_RANGE11_CTRL                       ((0x04b2  << 2) + 0xfe036000)

#define DMC_SEC_RANGE11_RID_CTRL0                  ((0x04b3  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE11_RID_CTRL1                  ((0x04b4  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE11_RID_CTRL2                  ((0x04b5  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE11_WID_CTRL0                  ((0x04b8  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE11_WID_CTRL1                  ((0x04b9  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE11_WID_CTRL2                  ((0x04ba  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region12(RANGE12) related register.
#define DMC_SEC_RANGE12_STA                        ((0x04c0  << 2) + 0xfe036000)
#define DMC_SEC_RANGE12_EDA                        ((0x04c1  << 2) + 0xfe036000)
#define DMC_SEC_RANGE12_CTRL                       ((0x04c2  << 2) + 0xfe036000)

#define DMC_SEC_RANGE12_RID_CTRL0                  ((0x04c3  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE12_RID_CTRL1                  ((0x04c4  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE12_RID_CTRL2                  ((0x04c5  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE12_WID_CTRL0                  ((0x04c8  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE12_WID_CTRL1                  ((0x04c9  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE12_WID_CTRL2                  ((0x04ca  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region13(RANGE13) related register.
#define DMC_SEC_RANGE13_STA                        ((0x04d0  << 2) + 0xfe036000)
#define DMC_SEC_RANGE13_EDA                        ((0x04d1  << 2) + 0xfe036000)
#define DMC_SEC_RANGE13_CTRL                       ((0x04d2  << 2) + 0xfe036000)

#define DMC_SEC_RANGE13_RID_CTRL0                  ((0x04d3  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE13_RID_CTRL1                  ((0x04d4  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE13_RID_CTRL2                  ((0x04d5  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE13_WID_CTRL0                  ((0x04d8  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE13_WID_CTRL1                  ((0x04d9  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE13_WID_CTRL2                  ((0x04da  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region14(RANGE14) related register.
#define DMC_SEC_RANGE14_STA                        ((0x04e0  << 2) + 0xfe036000)
#define DMC_SEC_RANGE14_EDA                        ((0x04e1  << 2) + 0xfe036000)
#define DMC_SEC_RANGE14_CTRL                       ((0x04e2  << 2) + 0xfe036000)

#define DMC_SEC_RANGE14_RID_CTRL0                  ((0x04e3  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE14_RID_CTRL1                  ((0x04e4  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE14_RID_CTRL2                  ((0x04e5  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE14_WID_CTRL0                  ((0x04e8  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE14_WID_CTRL1                  ((0x04e9  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE14_WID_CTRL2                  ((0x04ea  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];


//region15(RANGE15) related register.
#define DMC_SEC_RANGE15_STA                        ((0x04f0  << 2) + 0xfe036000)
#define DMC_SEC_RANGE15_EDA                        ((0x04f1  << 2) + 0xfe036000)
#define DMC_SEC_RANGE15_CTRL                       ((0x04f2  << 2) + 0xfe036000)

#define DMC_SEC_RANGE15_RID_CTRL0                  ((0x04f3  << 2) + 0xfe036000)
	//range_rd_sid_en[31:0];
#define DMC_SEC_RANGE15_RID_CTRL1                  ((0x04f4  << 2) + 0xfe036000)
	//range_rd_sid_en[63:32];
#define DMC_SEC_RANGE15_RID_CTRL2                  ((0x04f5  << 2) + 0xfe036000)
	//range_rd_sid_en[95:64];
#define DMC_SEC_RANGE15_WID_CTRL0                  ((0x04f8  << 2) + 0xfe036000)
	//range_wr_sid_en[31:0];
#define DMC_SEC_RANGE15_WID_CTRL1                  ((0x04f9  << 2) + 0xfe036000)
	//range_wr_sid_en[63:32];
#define DMC_SEC_RANGE15_WID_CTRL2                  ((0x04fa  << 2) + 0xfe036000)
	//range_wr_sid_en[95:64];




#define DMC_DES_PADDING                            ((0x0500  << 2) + 0xfe036000)
//bit 31:0 | 0 | des_pading | 32bits address padding used for DES dkey generation.

#define DMC_DES_CTRL                               ((0x0501  << 2) + 0xfe036000)
//bit 1 | 0 | GLOBAL_DES_EN |  1: Global DES enable. 0 : global DES disable. default is 0.
//bit 0 | 0 | DES_lock  |  one time lock bit. after write 1 to this bit, \
				DMC_DES_CTRL,DMC_DES_PADDING can't be write and read.

#define DMC_DES_CTRL1                              ((0x050a  << 2) + 0xfe036000)
	//bit 31:16 unused
	//bit 15 : range15_des_en policy : 1 range15_des_en = range15_local_des_en && \
		GLOBAL_DES_EN. 0 : range15_des_en = range15_local_des_en ||  GLOBAL_DES_EN.
	//bit 14 : range14_des_en policy : 1 range14_des_en = range14_local_des_en && \
		GLOBAL_DES_EN. 0 : range14_des_en = range14_local_des_en ||  GLOBAL_DES_EN.
	//bit 13 : range13_des_en policy : 1 range13_des_en = range13_local_des_en && \
		GLOBAL_DES_EN. 0 : range13_des_en = range13_local_des_en ||  GLOBAL_DES_EN.
	//bit 12 : range12_des_en policy : 1 range12_des_en = range12_local_des_en && \
		GLOBAL_DES_EN. 0 : range12_des_en = range12_local_des_en ||  GLOBAL_DES_EN.
	//bit 11 : range11_des_en policy : 1 range11_des_en = range11_local_des_en && \
		GLOBAL_DES_EN. 0 : range11_des_en = range11_local_des_en ||  GLOBAL_DES_EN.
	//bit 10 : range10_des_en policy : 1 range11_des_en = range10_local_des_en && \
		GLOBAL_DES_EN. 0 : range10_des_en = range10_local_des_en ||  GLOBAL_DES_EN.
	//bit  9 : range9_des_en policy  : 1  range9_des_en =  range9_local_des_en && \
		GLOBAL_DES_EN. 0 :  range9_des_en =  range9_local_des_en ||  GLOBAL_DES_EN.
	//bit  8 : range8_des_en policy  : 1  range8_des_en =  range8_local_des_en && \
		GLOBAL_DES_EN. 0 :  range8_des_en =  range8_local_des_en ||  GLOBAL_DES_EN.
	//bit  7 : range7_des_en policy  : 1  range7_des_en =  range7_local_des_en && \
		GLOBAL_DES_EN. 0 :  range7_des_en =  range7_local_des_en ||  GLOBAL_DES_EN.
	//bit  6 : range6_des_en policy  : 1  range6_des_en =  range6_local_des_en && \
		GLOBAL_DES_EN. 0 :  range6_des_en =  range6_local_des_en ||  GLOBAL_DES_EN.
	//bit  5 : range5_des_en policy  : 1  range5_des_en =  range5_local_des_en && \
		GLOBAL_DES_EN. 0 :  range5_des_en =  range5_local_des_en ||  GLOBAL_DES_EN.
	//bit  4 : range4_des_en policy  : 1  range4_des_en =  range4_local_des_en && \
		GLOBAL_DES_EN. 0 :  range4_des_en =  range4_local_des_en ||  GLOBAL_DES_EN.
	//bit  3 : range3_des_en policy  : 1  range3_des_en =  range3_local_des_en && \
		GLOBAL_DES_EN. 0 :  range3_des_en =  range3_local_des_en ||  GLOBAL_DES_EN.
	//bit  2 : range2_des_en policy  : 1  range2_des_en =  range2_local_des_en && \
		GLOBAL_DES_EN. 0 :  range2_des_en =  range2_local_des_en ||  GLOBAL_DES_EN.
	//bit  1 : range1_des_en policy  : 1  range1_des_en =  range1_local_des_en && \
		GLOBAL_DES_EN. 0 :  range1_des_en =  range1_local_des_en ||  GLOBAL_DES_EN.
	//bit  0 : range0_des_en policy  : 1  range0_des_en =  range0_local_des_en && \
		GLOBAL_DES_EN. 0 : range0_des_en =  range0_local_des_en ||  GLOBAL_DES_EN.


#define DMC_DES_KEY0_REG0                          ((0x0502  << 2) + 0xfe036000)
#define DMC_DES_KEY0_REG1                          ((0x0503  << 2) + 0xfe036000)
#define DMC_DES_KEY0_REG2                          ((0x0504  << 2) + 0xfe036000)
#define DMC_DES_KEY0_REG3                          ((0x0505  << 2) + 0xfe036000)
#define DMC_DES_KEY1_REG0                          ((0x0506  << 2) + 0xfe036000)
#define DMC_DES_KEY1_REG1                          ((0x0507  << 2) + 0xfe036000)
#define DMC_DES_KEY1_REG2                          ((0x0508  << 2) + 0xfe036000)
#define DMC_DES_KEY1_REG3                          ((0x0509  << 2) + 0xfe036000)

//FROM SC2, the APB bus provided Master ID through PUSER.
//after ID_REMAP, this PUSE provided 8 master ID type.
//they are:
//  8'b0000_0001 : TEE
//  8'h0000_0010 : REE
//  8'h0000_0100 : JTAG
//  8'h0000_1000 : AOCPU
//  8'h0001_0000 : DSPA
//  8'h0010_0000 : DSPB
//  no others.

//FROM SC2, the APB bus provided Master ID through PUSER signals.
//there's total 8 master IDs could access DMC non-secure registers.
//we assign 1 control bit for each APB Master and each DMC non-secure register domains
//and we added one lock bits to lock this setting can't be modified any more.
#define DDR_APB_SEC_CTRL0                          ((0x0510  << 2) + 0xfe036000)
   // APB access  control for dmc REQUEST control register access control register.
   // default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL1                          ((0x0511  << 2) + 0xfe036000)
   // APB access control for DMC DRAM timing parameter and DFI interface registers.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL2                          ((0x0512  << 2) + 0xfe036000)
   // APB access control for DMC PLL clock frequency control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL3                          ((0x0513  << 2) + 0xfe036000)
   // APB access control for DMC sticky control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL4                          ((0x0514  << 2) + 0xfe036000)
   // APB access control for DMC test control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL5                          ((0x0515  << 2) + 0xfe036000)
   // APB access control for DMC clk reset control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL6                          ((0x0516  << 2) + 0xfe036000)
   // APB access control for DMC protection register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL7                          ((0x0517  << 2) + 0xfe036000)
   // APB access control for DMC normal register.
   //default : 0x0ff
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL8                          ((0x0518  << 2) + 0xfe036000)
   // APB access control for DDR PHY group 0 registers.
   //default : 0x005
   //bit 23:16. PHY PRODUCTION control register enable.
   //bit 15:9  unused
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.



//registers to check the security protection and watch point error information.
#define DMC_SEC_STATUS                             ((0x051a  << 2) + 0xfe036000)
 //bit 31~2. not used.
 //bit 6
 //bit 5
 //bit 4
 //bit 3   1 : normal security register write violation.( APB bus WDATA not equal the \
			register value when APB write).  write 1 to clean this bit to 0.
 //bit 2   sec_alert.   1 DMC security register alert function triggered. can't clean. \
			only reset DMC can clear this bit.
 //bit 1   write security violation.
 //bit 0.  read security violation.

#define DMC_VIO_ADDR0                              ((0x051b  << 2) + 0xfe036000)
  //ddr0 write secure violation address[31:0].
#define DMC_VIO_ADDR1                              ((0x051c  << 2) + 0xfe036000)
  //bit 31:24 . not used. always 0.
  //23.    ddr0 write address secure check error.
  //22     ddr0 write address overflow or not in this DDR channel.
  //21:15  7'b0.
  //14:0   ddr0_write violation USER BIT.
#define DMC_VIO_ADDR2                              ((0x051d  << 2) + 0xfe036000)
  //ddr0 read secure violation address[31:0]
#define DMC_VIO_ADDR3                              ((0x051e  << 2) + 0xfe036000)
  //bit 31:24 not used.
  //23.    ddr0 read address secure check error.
  //22     ddr0 read address overflow or not in this DDR channel.
  //21:15  7'b0.
  //14:0   ddr0_read violation USER BIT.


#define DMC_AXI2DDR0                               ((0x0520  << 2) + 0xfe036000)
  //for AXI address first 256MB  AXI ADDRESS[31:28] == 4'b0000.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr data 16bits mode   0 : 32bits.  1: 16 bits valid data in a 32bits data bus.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_AXI2DDR1                               ((0x0521  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b0001.

#define DMC_AXI2DDR2                               ((0x0522  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b0010.

#define DMC_AXI2DDR3                               ((0x0523  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b0011.

#define DMC_AXI2DDR4                               ((0x0524  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b0100.

#define DMC_AXI2DDR5                               ((0x0525  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b0101.

#define DMC_AXI2DDR6                               ((0x0526  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b0110.

#define DMC_AXI2DDR7                               ((0x0527  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b0111.

#define DMC_AXI2DDR8                               ((0x0528  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b1000.

#define DMC_AXI2DDR9                               ((0x0529  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b1001.

#define DMC_AXI2DDRA                               ((0x052a  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b1010.

#define DMC_AXI2DDRB                               ((0x052b  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b1011.

#define DMC_AXI2DDRC                               ((0x052c  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b1100.

#define DMC_AXI2DDRD                               ((0x052d  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b1101.

#define DMC_AXI2DDRE                               ((0x052e  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b1110.

#define DMC_AXI2DDRF                               ((0x052f  << 2) + 0xfe036000)
  //for AXI_ADDRESS[31:28] == 4'b1111.




#define DMC_DDR_CTRL                               ((0x0540  << 2) + 0xfe036000)
   //bit 27.   0 : cavnas use 64bytes boundary
		//1 : canvas use 32bytes boundary.
  //bit 24:22     3'b000 : ddr3 mode.
		//3'b001 : ddr4 mode.
		//3'b010 : lpddr3 mode.
		//3'b011 : lpddr4 mode.
   //bit 21.   rank1 enable bit. if 1,  rank1 used the address map is as bit 5:3 defined.
   //bit 20    DDR4 BG1 enable bit.
   //bit 18:   ddrphy_16b, DDR PHY DDR SDRAM data bits width.  1: 16bits. 0 : 32 bits.
   //bit 16.   ddr_16b,   1: only use 16bits data in a 32bits DDR PHY data interface. \
			  0 : normal data interface.
  //bit 7:4 :  ddr1_size.  DDR rank1 size control.
     //4'b0000 : DDR rank 1 is 128Mbyte.
     //4'b0001 : DDR rank 1 is 256Mbyte.
     //4'b0010 : DDR rank 1 is 512Mbyte.
     //4'b0011 : DDR rank 1 is 1Gbyte.
     //4'b0100 : DDR rank 1 is 2Gbyte.
     //4'b0101 : DDR rank 1 is 4Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 374Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.
  //bit 3:0  :  ddr0_size. DDR rank0 size control.
     //4'b0000 : DDR rank 0 is 128Mbyte.
     //4'b0001 : DDR rank 0 is 256Mbyte.
     //4'b0010 : DDR rank 0 is 512Mbyte.
     //4'b0011 : DDR rank 0 is 1Gbyte.
     //4'b0100 : DDR rank 0 is 2Gbyte.
     //4'b0101 : DDR rank 0 is 4Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 374Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.

#define DMC_DDR_CTRL1                              ((0x0541  << 2) + 0xfe036000)
	//bit 31. DMC_DDR_LOCK. 1: LOCK DMC_DDR_CTRL, DMC_DDR_CTRL1, DMC_AXI2DDRx, \
		DDR0/1_ADDRMAP_x registers. those register can't modified any more. \
	0: all these registers can be read/write by secure APB access.
	//bit 30~3. not used.
	//bit 6.  strict security level control for DMA channel.
	//1: only sec level input == region sec level is allowed.
	//0:  sec_level input >= region sec level is allow to write.
	//bit 5:2: reserved for more strip control.
	//	1:0. DDR strip ctrl. if axi2ddr configuration is splited to DMC.
	//2'b00 : 64Byte.  4DMCs : strip_bits = 7:6.  2 DMC : strip bit = 6
	//2'b01 : 128Byte. 4DMCs : strip_bits = 8:7.  2 DMC : strip bit = 7
	//2'b10 : 256Byte. 4DMCs : strip_bits = 9:8.  2 DMC : strip bit = 8
	//2'b11 : 512Byte. 4DMCs : strip_bits = 10:9.  2 DMC : strip bit= 9


//DDR3/4 LPDDR3/4 SDRAM address  to 32bits linear address map:
//DDR0_ADDRMAP is used to select RANK0 bank, row, col address selection.
//DDR1_ADDRMAP is used to select RANK1 bank, row, col address selection.
#define DMC_RANK0_ADDRMAP_0                        ((0x0542  << 2) + 0xfe036000)
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.

#define DMC_RANK0_ADDRMAP_1                        ((0x0543  << 2) + 0xfe036000)
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.

#define DMC_RANK0_ADDRMAP_2                        ((0x0544  << 2) + 0xfe036000)
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.

#define DMC_RANK0_ADDRMAP_3                        ((0x0545  << 2) + 0xfe036000)
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.

#define DMC_RANK0_ADDRMAP_4                        ((0x0546  << 2) + 0xfe036000)
  //29:25 ra17
  //24:20 ra16
  //19:15 ba2.
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.


#define DMC_RANK1_ADDRMAP_0                        ((0x0547  << 2) + 0xfe036000)
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.

#define DMC_RANK1_ADDRMAP_1                        ((0x0548  << 2) + 0xfe036000)
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.

#define DMC_RANK1_ADDRMAP_2                        ((0x0549  << 2) + 0xfe036000)
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.

#define DMC_RANK1_ADDRMAP_3                        ((0x054a  << 2) + 0xfe036000)
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.

#define DMC_RANK1_ADDRMAP_4                        ((0x054b  << 2) + 0xfe036000)
  //29:25 ra17
  //24:20 ra16
  //19:15 ba2
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.







//
// Closing file:  ../mmc_lp4/dmc/rtl/dmc_reg.vh
//
//
// Closing file:  ./mmc_reg.vh
//

#endif // MMC_REG_DEFINE

